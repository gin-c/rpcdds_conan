/* Generated by opendds_idl.exe version 3.3 (ACE version 5.6a_p13) running on input file CalculatorRequestReply.idl*/
#include "CalculatorRequestReplyTypeSupportImpl.h"

#include <cstring>
#include <stdexcept>
#include "dds/DCPS/BuiltInTopicUtils.h"
#include "dds/DCPS/ContentFilteredTopicImpl.h"
#include "dds/DCPS/FilterEvaluator.h"
#include "dds/DCPS/MultiTopicDataReader_T.h"
#include "dds/DCPS/PublicationInstance.h"
#include "dds/DCPS/PublisherImpl.h"
#include "dds/DCPS/Qos_Helper.h"
#include "dds/DCPS/RakeData.h"
#include "dds/DCPS/RakeResults_T.h"
#include "dds/DCPS/ReceivedDataElementList.h"
#include "dds/DCPS/Registered_Data_Types.h"
#include "dds/DCPS/Service_Participant.h"
#include "dds/DCPS/SubscriberImpl.h"
#include "dds/DCPS/Util.h"
#include "dds/DCPS/debug.h"
#include "dds/DdsDcpsDomainC.h"
#include "MessageHeaderTypeSupportImpl.h"


/* Begin STRUCT: Calculator_additionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_additionRequest& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
}

bool operator<<(Serializer& strm, const Calculator_additionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.x)
    && (strm << stru.y);
}

bool operator>>(Serializer& strm, Calculator_additionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.x)
    && (strm >> stru.y);
}

bool gen_is_bounded_size(const Calculator_additionRequest&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_additionRequest& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_additionRequest>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_additionRequest> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_additionRequest> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_additionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_additionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_additionRequest&)
{
  return false;
}

}  }

Calculator_additionRequestTypeSupportImpl::Calculator_additionRequestTypeSupportImpl ()
{
}

Calculator_additionRequestTypeSupportImpl::~Calculator_additionRequestTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_additionRequestTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_additionRequestTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_additionRequestTypeSupportImpl::create_datawriter ()
{
  Calculator_additionRequestDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_additionRequestDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_additionRequestTypeSupportImpl::create_datareader ()
{
  Calculator_additionRequestDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_additionRequestDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_additionRequestTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_additionRequest,
    Calculator_additionRequestDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_additionRequestTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_additionRequest>();
}

#endif

bool
Calculator_additionRequestTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_additionRequest());
}


Calculator_additionRequestDataWriterImpl::Calculator_additionRequestDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_additionRequestDataWriterImpl::~Calculator_additionRequestDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_additionRequestDataWriterImpl::register_instance (
    const ::Calculator_additionRequest & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_additionRequestDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_additionRequest & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_additionRequestDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::unregister_instance (
    const ::Calculator_additionRequest & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_additionRequest & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_additionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_additionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_additionRequestDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_additionRequestDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::write (
    const ::Calculator_additionRequest & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::write_w_timestamp (
    const ::Calculator_additionRequest & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_additionRequestDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::dispose (
    const ::Calculator_additionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_additionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_additionRequestDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::get_key_value (
    ::Calculator_additionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_additionRequestDataWriterImpl::lookup_instance (
    const ::Calculator_additionRequest & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_additionRequestDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_additionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_additionRequest > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::enable_specific ()
{
  ::Calculator_additionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionRequestDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_additionRequestDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_additionRequestDataWriterImpl::dds_marshal(
  const ::Calculator_additionRequest& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_additionRequest > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_additionRequest& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_additionRequestDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_additionRequest failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_additionRequestDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_additionRequestDataReaderImpl::Calculator_additionRequestDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionRequestDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_additionRequestDataReaderImpl::~Calculator_additionRequestDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionRequestSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_w_condition (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_w_condition (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_next_sample (
    ::Calculator_additionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_additionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_next_sample (
    ::Calculator_additionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_additionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_instance (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_instance_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_instance (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_instance_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_next_instance (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_next_instance_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_next_instance (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_next_instance_i (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_additionRequestDataReaderImpl::release_loan (
    ::Calculator_additionRequestSeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_additionRequestDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_additionRequest* const ptr
        = static_cast< ::Calculator_additionRequest* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_additionRequest );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::return_loan (
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::get_key_value (
    ::Calculator_additionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_additionRequestDataReaderImpl::lookup_instance (
    const ::Calculator_additionRequest & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_additionRequestDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_additionRequest* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionRequestSeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_additionRequestDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_additionRequest*>(data));
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_additionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_additionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_additionRequestDataReaderImpl::store_synthetic_data(const Calculator_additionRequest& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_additionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_additionRequest*>(data_allocator_->malloc(sizeof(Calculator_additionRequest))),
      Calculator_additionRequest(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_additionRequestDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_additionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_additionRequest*>(data_allocator_->malloc(sizeof(Calculator_additionRequest))),
      Calculator_additionRequest);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_additionRequestDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_additionRequest* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_additionRequest *>(
                            data_allocator_->malloc(sizeof(::Calculator_additionRequest))),
                           ::Calculator_additionRequest);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_additionRequest>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_additionRequestDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_additionRequest data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_additionRequest>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_additionRequestDataReaderImpl::store_instance_data(
    ::Calculator_additionRequest *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_additionRequest );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionRequest );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_additionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_additionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_additionRequestDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_additionRequest failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_additionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_additionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_additionRequest failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionRequest );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionRequest );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_additionRequest );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_additionRequest );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_additionRequest );
  }
}

void
Calculator_additionRequestDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_additionRequestDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_additionRequestSeq& received_data =
    *static_cast< ::Calculator_additionRequestSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_additionRequestDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_additionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_additionRequestSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionRequestDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_additionRequestDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_additionRequestDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_additionRequestDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_additionRequest> : MetaStruct {
  typedef Calculator_additionRequest T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_additionRequest& typed = *static_cast<const Calculator_additionRequest*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<RequestHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionRequest)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<RequestHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionRequest)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "x", "y", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionRequest)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const RequestHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionRequest)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionRequest)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_additionRequest>()
{
  static MetaStructImpl<Calculator_additionRequest> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_additionRequest */


/* Begin STRUCT: Calculator_additionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_additionReply& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.addition_ret);
}

bool operator<<(Serializer& strm, const Calculator_additionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.addition_ret);
}

bool operator>>(Serializer& strm, Calculator_additionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.addition_ret);
}

bool gen_is_bounded_size(const Calculator_additionReply&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_additionReply& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_additionReply>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_additionReply> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_additionReply> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_additionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_additionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_additionReply&)
{
  return false;
}

}  }

Calculator_additionReplyTypeSupportImpl::Calculator_additionReplyTypeSupportImpl ()
{
}

Calculator_additionReplyTypeSupportImpl::~Calculator_additionReplyTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_additionReplyTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_additionReplyTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_additionReplyTypeSupportImpl::create_datawriter ()
{
  Calculator_additionReplyDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_additionReplyDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_additionReplyTypeSupportImpl::create_datareader ()
{
  Calculator_additionReplyDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_additionReplyDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_additionReplyTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_additionReply,
    Calculator_additionReplyDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_additionReplyTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_additionReply>();
}

#endif

bool
Calculator_additionReplyTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_additionReply());
}


Calculator_additionReplyDataWriterImpl::Calculator_additionReplyDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_additionReplyDataWriterImpl::~Calculator_additionReplyDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_additionReplyDataWriterImpl::register_instance (
    const ::Calculator_additionReply & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_additionReplyDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_additionReply & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_additionReplyDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::unregister_instance (
    const ::Calculator_additionReply & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_additionReply & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_additionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_additionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_additionReplyDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_additionReplyDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::write (
    const ::Calculator_additionReply & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::write_w_timestamp (
    const ::Calculator_additionReply & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_additionReplyDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::dispose (
    const ::Calculator_additionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_additionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_additionReplyDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::get_key_value (
    ::Calculator_additionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_additionReplyDataWriterImpl::lookup_instance (
    const ::Calculator_additionReply & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_additionReplyDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_additionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_additionReply > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::enable_specific ()
{
  ::Calculator_additionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionReplyDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_additionReplyDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_additionReplyDataWriterImpl::dds_marshal(
  const ::Calculator_additionReply& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_additionReply > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_additionReply& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_additionReplyDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_additionReply failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_additionReplyDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_additionReplyDataReaderImpl::Calculator_additionReplyDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionReplyDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_additionReplyDataReaderImpl::~Calculator_additionReplyDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionReplySeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_w_condition (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_w_condition (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_next_sample (
    ::Calculator_additionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_additionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_next_sample (
    ::Calculator_additionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_additionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_instance (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_instance_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_instance (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_instance_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_additionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_additionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_next_instance (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_next_instance_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_next_instance (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_next_instance_i (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_additionReplyDataReaderImpl::release_loan (
    ::Calculator_additionReplySeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_additionReplyDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_additionReply* const ptr
        = static_cast< ::Calculator_additionReply* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_additionReply );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::return_loan (
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::get_key_value (
    ::Calculator_additionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_additionReplyDataReaderImpl::lookup_instance (
    const ::Calculator_additionReply & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_additionReplyDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_additionReply* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionReplySeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_additionReplyDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_additionReply*>(data));
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_additionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_additionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_additionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_additionReplyDataReaderImpl::store_synthetic_data(const Calculator_additionReply& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_additionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_additionReply*>(data_allocator_->malloc(sizeof(Calculator_additionReply))),
      Calculator_additionReply(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_additionReplyDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_additionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_additionReply*>(data_allocator_->malloc(sizeof(Calculator_additionReply))),
      Calculator_additionReply);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_additionReplyDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_additionReply* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_additionReply *>(
                            data_allocator_->malloc(sizeof(::Calculator_additionReply))),
                           ::Calculator_additionReply);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_additionReply>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_additionReplyDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_additionReply data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_additionReply>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_additionReplyDataReaderImpl::store_instance_data(
    ::Calculator_additionReply *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_additionReply );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionReply );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_additionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_additionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_additionReplyDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_additionReply failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_additionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_additionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_additionReply failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionReply );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_additionReply );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_additionReply );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_additionReply );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_additionReply );
  }
}

void
Calculator_additionReplyDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_additionReplyDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_additionReplySeq& received_data =
    *static_cast< ::Calculator_additionReplySeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_additionReplyDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_additionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_additionReplySeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_additionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_additionReplyDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_additionReplyDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_additionReplyDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_additionReplyDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_additionReply> : MetaStruct {
  typedef Calculator_additionReply T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_additionReply& typed = *static_cast<const Calculator_additionReply*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<ReplyHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "addition_ret") == 0) {
      return typed.addition_ret;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionReply)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<ReplyHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "addition_ret") == 0) {
      return make_field_cmp(&T::addition_ret, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionReply)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "addition_ret", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "addition_ret") == 0) {
      return &static_cast<const T*>(stru)->addition_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionReply)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const ReplyHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "addition_ret") == 0) {
      static_cast<T*>(lhs)->addition_ret = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionReply)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "addition_ret") == 0) {
      return static_cast<const T*>(lhs)->addition_ret == static_cast<const T*>(rhs)->addition_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_additionReply)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_additionReply>()
{
  static MetaStructImpl<Calculator_additionReply> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_additionReply */


/* Begin STRUCT: Calculator_substractionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_substractionRequest& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
}

bool operator<<(Serializer& strm, const Calculator_substractionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.x)
    && (strm << stru.y);
}

bool operator>>(Serializer& strm, Calculator_substractionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.x)
    && (strm >> stru.y);
}

bool gen_is_bounded_size(const Calculator_substractionRequest&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_substractionRequest& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_substractionRequest>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_substractionRequest> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_substractionRequest> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_substractionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_substractionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_substractionRequest&)
{
  return false;
}

}  }

Calculator_substractionRequestTypeSupportImpl::Calculator_substractionRequestTypeSupportImpl ()
{
}

Calculator_substractionRequestTypeSupportImpl::~Calculator_substractionRequestTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_substractionRequestTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_substractionRequestTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_substractionRequestTypeSupportImpl::create_datawriter ()
{
  Calculator_substractionRequestDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_substractionRequestDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_substractionRequestTypeSupportImpl::create_datareader ()
{
  Calculator_substractionRequestDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_substractionRequestDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_substractionRequestTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_substractionRequest,
    Calculator_substractionRequestDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_substractionRequestTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_substractionRequest>();
}

#endif

bool
Calculator_substractionRequestTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_substractionRequest());
}


Calculator_substractionRequestDataWriterImpl::Calculator_substractionRequestDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_substractionRequestDataWriterImpl::~Calculator_substractionRequestDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_substractionRequestDataWriterImpl::register_instance (
    const ::Calculator_substractionRequest & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_substractionRequestDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_substractionRequest & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_substractionRequestDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::unregister_instance (
    const ::Calculator_substractionRequest & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_substractionRequest & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_substractionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_substractionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_substractionRequestDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_substractionRequestDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::write (
    const ::Calculator_substractionRequest & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::write_w_timestamp (
    const ::Calculator_substractionRequest & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_substractionRequestDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::dispose (
    const ::Calculator_substractionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_substractionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_substractionRequestDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::get_key_value (
    ::Calculator_substractionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_substractionRequestDataWriterImpl::lookup_instance (
    const ::Calculator_substractionRequest & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_substractionRequestDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_substractionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_substractionRequest > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::enable_specific ()
{
  ::Calculator_substractionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionRequestDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_substractionRequestDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_substractionRequestDataWriterImpl::dds_marshal(
  const ::Calculator_substractionRequest& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_substractionRequest > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_substractionRequest& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_substractionRequestDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_substractionRequest failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_substractionRequestDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_substractionRequestDataReaderImpl::Calculator_substractionRequestDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionRequestDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_substractionRequestDataReaderImpl::~Calculator_substractionRequestDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionRequestSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_w_condition (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_w_condition (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_next_sample (
    ::Calculator_substractionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_substractionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_next_sample (
    ::Calculator_substractionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_substractionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_instance (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_instance_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_instance (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_instance_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_next_instance (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_next_instance_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_next_instance (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_next_instance_i (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_substractionRequestDataReaderImpl::release_loan (
    ::Calculator_substractionRequestSeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_substractionRequestDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_substractionRequest* const ptr
        = static_cast< ::Calculator_substractionRequest* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_substractionRequest );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::return_loan (
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::get_key_value (
    ::Calculator_substractionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_substractionRequestDataReaderImpl::lookup_instance (
    const ::Calculator_substractionRequest & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_substractionRequestDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_substractionRequest* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionRequestSeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_substractionRequestDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_substractionRequest*>(data));
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_substractionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_substractionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_substractionRequestDataReaderImpl::store_synthetic_data(const Calculator_substractionRequest& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_substractionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_substractionRequest*>(data_allocator_->malloc(sizeof(Calculator_substractionRequest))),
      Calculator_substractionRequest(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_substractionRequestDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_substractionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_substractionRequest*>(data_allocator_->malloc(sizeof(Calculator_substractionRequest))),
      Calculator_substractionRequest);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_substractionRequestDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_substractionRequest* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_substractionRequest *>(
                            data_allocator_->malloc(sizeof(::Calculator_substractionRequest))),
                           ::Calculator_substractionRequest);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_substractionRequest>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_substractionRequestDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_substractionRequest data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_substractionRequest>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_substractionRequestDataReaderImpl::store_instance_data(
    ::Calculator_substractionRequest *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_substractionRequest );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionRequest );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_substractionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_substractionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_substractionRequestDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_substractionRequest failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_substractionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_substractionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_substractionRequest failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionRequest );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionRequest );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_substractionRequest );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_substractionRequest );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_substractionRequest );
  }
}

void
Calculator_substractionRequestDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_substractionRequestDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_substractionRequestSeq& received_data =
    *static_cast< ::Calculator_substractionRequestSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_substractionRequestDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_substractionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_substractionRequestSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionRequestDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_substractionRequestDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_substractionRequestDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_substractionRequestDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_substractionRequest> : MetaStruct {
  typedef Calculator_substractionRequest T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_substractionRequest& typed = *static_cast<const Calculator_substractionRequest*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<RequestHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionRequest)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<RequestHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionRequest)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "x", "y", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionRequest)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const RequestHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionRequest)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionRequest)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_substractionRequest>()
{
  static MetaStructImpl<Calculator_substractionRequest> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_substractionRequest */


/* Begin STRUCT: Calculator_substractionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_substractionReply& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.substraction_ret);
}

bool operator<<(Serializer& strm, const Calculator_substractionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.substraction_ret);
}

bool operator>>(Serializer& strm, Calculator_substractionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.substraction_ret);
}

bool gen_is_bounded_size(const Calculator_substractionReply&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_substractionReply& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_substractionReply>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_substractionReply> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_substractionReply> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_substractionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_substractionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_substractionReply&)
{
  return false;
}

}  }

Calculator_substractionReplyTypeSupportImpl::Calculator_substractionReplyTypeSupportImpl ()
{
}

Calculator_substractionReplyTypeSupportImpl::~Calculator_substractionReplyTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_substractionReplyTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_substractionReplyTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_substractionReplyTypeSupportImpl::create_datawriter ()
{
  Calculator_substractionReplyDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_substractionReplyDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_substractionReplyTypeSupportImpl::create_datareader ()
{
  Calculator_substractionReplyDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_substractionReplyDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_substractionReplyTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_substractionReply,
    Calculator_substractionReplyDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_substractionReplyTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_substractionReply>();
}

#endif

bool
Calculator_substractionReplyTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_substractionReply());
}


Calculator_substractionReplyDataWriterImpl::Calculator_substractionReplyDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_substractionReplyDataWriterImpl::~Calculator_substractionReplyDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_substractionReplyDataWriterImpl::register_instance (
    const ::Calculator_substractionReply & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_substractionReplyDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_substractionReply & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_substractionReplyDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::unregister_instance (
    const ::Calculator_substractionReply & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_substractionReply & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_substractionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_substractionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_substractionReplyDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_substractionReplyDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::write (
    const ::Calculator_substractionReply & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::write_w_timestamp (
    const ::Calculator_substractionReply & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_substractionReplyDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::dispose (
    const ::Calculator_substractionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_substractionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_substractionReplyDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::get_key_value (
    ::Calculator_substractionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_substractionReplyDataWriterImpl::lookup_instance (
    const ::Calculator_substractionReply & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_substractionReplyDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_substractionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_substractionReply > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::enable_specific ()
{
  ::Calculator_substractionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionReplyDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_substractionReplyDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_substractionReplyDataWriterImpl::dds_marshal(
  const ::Calculator_substractionReply& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_substractionReply > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_substractionReply& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_substractionReplyDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_substractionReply failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_substractionReplyDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_substractionReplyDataReaderImpl::Calculator_substractionReplyDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionReplyDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_substractionReplyDataReaderImpl::~Calculator_substractionReplyDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionReplySeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_w_condition (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_w_condition (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_next_sample (
    ::Calculator_substractionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_substractionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_next_sample (
    ::Calculator_substractionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_substractionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_instance (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_instance_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_instance (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_instance_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_substractionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_substractionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_next_instance (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_next_instance_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_next_instance (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_next_instance_i (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_substractionReplyDataReaderImpl::release_loan (
    ::Calculator_substractionReplySeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_substractionReplyDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_substractionReply* const ptr
        = static_cast< ::Calculator_substractionReply* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_substractionReply );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::return_loan (
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::get_key_value (
    ::Calculator_substractionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_substractionReplyDataReaderImpl::lookup_instance (
    const ::Calculator_substractionReply & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_substractionReplyDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_substractionReply* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionReplySeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_substractionReplyDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_substractionReply*>(data));
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_substractionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_substractionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_substractionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_substractionReplyDataReaderImpl::store_synthetic_data(const Calculator_substractionReply& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_substractionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_substractionReply*>(data_allocator_->malloc(sizeof(Calculator_substractionReply))),
      Calculator_substractionReply(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_substractionReplyDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_substractionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_substractionReply*>(data_allocator_->malloc(sizeof(Calculator_substractionReply))),
      Calculator_substractionReply);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_substractionReplyDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_substractionReply* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_substractionReply *>(
                            data_allocator_->malloc(sizeof(::Calculator_substractionReply))),
                           ::Calculator_substractionReply);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_substractionReply>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_substractionReplyDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_substractionReply data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_substractionReply>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_substractionReplyDataReaderImpl::store_instance_data(
    ::Calculator_substractionReply *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_substractionReply );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionReply );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_substractionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_substractionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_substractionReplyDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_substractionReply failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_substractionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_substractionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_substractionReply failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionReply );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_substractionReply );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_substractionReply );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_substractionReply );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_substractionReply );
  }
}

void
Calculator_substractionReplyDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_substractionReplyDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_substractionReplySeq& received_data =
    *static_cast< ::Calculator_substractionReplySeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_substractionReplyDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_substractionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_substractionReplySeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_substractionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_substractionReplyDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_substractionReplyDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_substractionReplyDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_substractionReplyDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_substractionReply> : MetaStruct {
  typedef Calculator_substractionReply T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_substractionReply& typed = *static_cast<const Calculator_substractionReply*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<ReplyHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "substraction_ret") == 0) {
      return typed.substraction_ret;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionReply)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<ReplyHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "substraction_ret") == 0) {
      return make_field_cmp(&T::substraction_ret, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionReply)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "substraction_ret", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "substraction_ret") == 0) {
      return &static_cast<const T*>(stru)->substraction_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionReply)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const ReplyHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "substraction_ret") == 0) {
      static_cast<T*>(lhs)->substraction_ret = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionReply)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "substraction_ret") == 0) {
      return static_cast<const T*>(lhs)->substraction_ret == static_cast<const T*>(rhs)->substraction_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_substractionReply)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_substractionReply>()
{
  static MetaStructImpl<Calculator_substractionReply> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_substractionReply */


/* Begin STRUCT: Calculator_multiplicationRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_multiplicationRequest& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
}

bool operator<<(Serializer& strm, const Calculator_multiplicationRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.x)
    && (strm << stru.y);
}

bool operator>>(Serializer& strm, Calculator_multiplicationRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.x)
    && (strm >> stru.y);
}

bool gen_is_bounded_size(const Calculator_multiplicationRequest&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_multiplicationRequest& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_multiplicationRequest>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_multiplicationRequest> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_multiplicationRequest> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_multiplicationRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_multiplicationRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_multiplicationRequest&)
{
  return false;
}

}  }

Calculator_multiplicationRequestTypeSupportImpl::Calculator_multiplicationRequestTypeSupportImpl ()
{
}

Calculator_multiplicationRequestTypeSupportImpl::~Calculator_multiplicationRequestTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_multiplicationRequestTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_multiplicationRequestTypeSupportImpl::create_datawriter ()
{
  Calculator_multiplicationRequestDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_multiplicationRequestDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_multiplicationRequestTypeSupportImpl::create_datareader ()
{
  Calculator_multiplicationRequestDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_multiplicationRequestDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_multiplicationRequestTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_multiplicationRequest,
    Calculator_multiplicationRequestDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_multiplicationRequestTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_multiplicationRequest>();
}

#endif

bool
Calculator_multiplicationRequestTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_multiplicationRequest());
}


Calculator_multiplicationRequestDataWriterImpl::Calculator_multiplicationRequestDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_multiplicationRequestDataWriterImpl::~Calculator_multiplicationRequestDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataWriterImpl::register_instance (
    const ::Calculator_multiplicationRequest & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_multiplicationRequest & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::unregister_instance (
    const ::Calculator_multiplicationRequest & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_multiplicationRequest & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_multiplicationRequestDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_multiplicationRequestDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::write (
    const ::Calculator_multiplicationRequest & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::write_w_timestamp (
    const ::Calculator_multiplicationRequest & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::dispose (
    const ::Calculator_multiplicationRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_multiplicationRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::get_key_value (
    ::Calculator_multiplicationRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataWriterImpl::lookup_instance (
    const ::Calculator_multiplicationRequest & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_multiplicationRequestDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_multiplicationRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_multiplicationRequest > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::enable_specific ()
{
  ::Calculator_multiplicationRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_multiplicationRequestDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_multiplicationRequestDataWriterImpl::dds_marshal(
  const ::Calculator_multiplicationRequest& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_multiplicationRequest > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_multiplicationRequest& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_multiplicationRequestDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_multiplicationRequest failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_multiplicationRequestDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_multiplicationRequestDataReaderImpl::Calculator_multiplicationRequestDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_multiplicationRequestDataReaderImpl::~Calculator_multiplicationRequestDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationRequestSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_w_condition (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_w_condition (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_next_sample (
    ::Calculator_multiplicationRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_multiplicationRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_next_sample (
    ::Calculator_multiplicationRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_multiplicationRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_instance (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_instance_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_instance (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_instance_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_next_instance (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_next_instance_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_next_instance (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_next_instance_i (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_multiplicationRequestDataReaderImpl::release_loan (
    ::Calculator_multiplicationRequestSeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_multiplicationRequestDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_multiplicationRequest* const ptr
        = static_cast< ::Calculator_multiplicationRequest* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_multiplicationRequest );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::return_loan (
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::get_key_value (
    ::Calculator_multiplicationRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataReaderImpl::lookup_instance (
    const ::Calculator_multiplicationRequest & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_multiplicationRequestDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_multiplicationRequest* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationRequestSeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_multiplicationRequest*>(data));
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_multiplicationRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_multiplicationRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_multiplicationRequestDataReaderImpl::store_synthetic_data(const Calculator_multiplicationRequest& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_multiplicationRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_multiplicationRequest*>(data_allocator_->malloc(sizeof(Calculator_multiplicationRequest))),
      Calculator_multiplicationRequest(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_multiplicationRequestDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_multiplicationRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_multiplicationRequest*>(data_allocator_->malloc(sizeof(Calculator_multiplicationRequest))),
      Calculator_multiplicationRequest);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_multiplicationRequestDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_multiplicationRequest* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_multiplicationRequest *>(
                            data_allocator_->malloc(sizeof(::Calculator_multiplicationRequest))),
                           ::Calculator_multiplicationRequest);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_multiplicationRequest>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_multiplicationRequestDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_multiplicationRequest data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_multiplicationRequest>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_multiplicationRequestDataReaderImpl::store_instance_data(
    ::Calculator_multiplicationRequest *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_multiplicationRequest );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationRequest );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_multiplicationRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_multiplicationRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_multiplicationRequestDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_multiplicationRequest failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_multiplicationRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_multiplicationRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_multiplicationRequest failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationRequest );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationRequest );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_multiplicationRequest );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_multiplicationRequest );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_multiplicationRequest );
  }
}

void
Calculator_multiplicationRequestDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_multiplicationRequestDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_multiplicationRequestSeq& received_data =
    *static_cast< ::Calculator_multiplicationRequestSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_multiplicationRequestDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_multiplicationRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_multiplicationRequestSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationRequestDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_multiplicationRequestDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_multiplicationRequestDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_multiplicationRequestDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_multiplicationRequest> : MetaStruct {
  typedef Calculator_multiplicationRequest T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_multiplicationRequest& typed = *static_cast<const Calculator_multiplicationRequest*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<RequestHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationRequest)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<RequestHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationRequest)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "x", "y", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationRequest)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const RequestHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationRequest)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationRequest)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_multiplicationRequest>()
{
  static MetaStructImpl<Calculator_multiplicationRequest> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_multiplicationRequest */


/* Begin STRUCT: Calculator_multiplicationReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_multiplicationReply& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.multiplication_ret);
}

bool operator<<(Serializer& strm, const Calculator_multiplicationReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.multiplication_ret);
}

bool operator>>(Serializer& strm, Calculator_multiplicationReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.multiplication_ret);
}

bool gen_is_bounded_size(const Calculator_multiplicationReply&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_multiplicationReply& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_multiplicationReply>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_multiplicationReply> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_multiplicationReply> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_multiplicationReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_multiplicationReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_multiplicationReply&)
{
  return false;
}

}  }

Calculator_multiplicationReplyTypeSupportImpl::Calculator_multiplicationReplyTypeSupportImpl ()
{
}

Calculator_multiplicationReplyTypeSupportImpl::~Calculator_multiplicationReplyTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_multiplicationReplyTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_multiplicationReplyTypeSupportImpl::create_datawriter ()
{
  Calculator_multiplicationReplyDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_multiplicationReplyDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_multiplicationReplyTypeSupportImpl::create_datareader ()
{
  Calculator_multiplicationReplyDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_multiplicationReplyDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_multiplicationReplyTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_multiplicationReply,
    Calculator_multiplicationReplyDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_multiplicationReplyTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_multiplicationReply>();
}

#endif

bool
Calculator_multiplicationReplyTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_multiplicationReply());
}


Calculator_multiplicationReplyDataWriterImpl::Calculator_multiplicationReplyDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_multiplicationReplyDataWriterImpl::~Calculator_multiplicationReplyDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataWriterImpl::register_instance (
    const ::Calculator_multiplicationReply & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_multiplicationReply & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::unregister_instance (
    const ::Calculator_multiplicationReply & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_multiplicationReply & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_multiplicationReplyDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_multiplicationReplyDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::write (
    const ::Calculator_multiplicationReply & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::write_w_timestamp (
    const ::Calculator_multiplicationReply & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::dispose (
    const ::Calculator_multiplicationReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_multiplicationReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::get_key_value (
    ::Calculator_multiplicationReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataWriterImpl::lookup_instance (
    const ::Calculator_multiplicationReply & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_multiplicationReplyDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_multiplicationReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_multiplicationReply > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::enable_specific ()
{
  ::Calculator_multiplicationReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_multiplicationReplyDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_multiplicationReplyDataWriterImpl::dds_marshal(
  const ::Calculator_multiplicationReply& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_multiplicationReply > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_multiplicationReply& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_multiplicationReplyDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_multiplicationReply failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_multiplicationReplyDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_multiplicationReplyDataReaderImpl::Calculator_multiplicationReplyDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_multiplicationReplyDataReaderImpl::~Calculator_multiplicationReplyDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationReplySeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_w_condition (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_w_condition (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_next_sample (
    ::Calculator_multiplicationReply & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_multiplicationReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_next_sample (
    ::Calculator_multiplicationReply & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_multiplicationReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_instance (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_instance_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_instance (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_instance_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_multiplicationReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_multiplicationReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_next_instance (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_next_instance_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_next_instance (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_next_instance_i (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_multiplicationReplyDataReaderImpl::release_loan (
    ::Calculator_multiplicationReplySeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_multiplicationReplyDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_multiplicationReply* const ptr
        = static_cast< ::Calculator_multiplicationReply* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_multiplicationReply );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::return_loan (
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::get_key_value (
    ::Calculator_multiplicationReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataReaderImpl::lookup_instance (
    const ::Calculator_multiplicationReply & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_multiplicationReplyDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_multiplicationReply* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationReplySeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_multiplicationReply*>(data));
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_multiplicationReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_multiplicationReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_multiplicationReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_multiplicationReplyDataReaderImpl::store_synthetic_data(const Calculator_multiplicationReply& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_multiplicationReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_multiplicationReply*>(data_allocator_->malloc(sizeof(Calculator_multiplicationReply))),
      Calculator_multiplicationReply(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_multiplicationReplyDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_multiplicationReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_multiplicationReply*>(data_allocator_->malloc(sizeof(Calculator_multiplicationReply))),
      Calculator_multiplicationReply);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_multiplicationReplyDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_multiplicationReply* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_multiplicationReply *>(
                            data_allocator_->malloc(sizeof(::Calculator_multiplicationReply))),
                           ::Calculator_multiplicationReply);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_multiplicationReply>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_multiplicationReplyDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_multiplicationReply data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_multiplicationReply>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_multiplicationReplyDataReaderImpl::store_instance_data(
    ::Calculator_multiplicationReply *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_multiplicationReply );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationReply );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_multiplicationReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_multiplicationReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_multiplicationReplyDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_multiplicationReply failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_multiplicationReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_multiplicationReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_multiplicationReply failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationReply );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_multiplicationReply );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_multiplicationReply );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_multiplicationReply );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_multiplicationReply );
  }
}

void
Calculator_multiplicationReplyDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_multiplicationReplyDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_multiplicationReplySeq& received_data =
    *static_cast< ::Calculator_multiplicationReplySeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_multiplicationReplyDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_multiplicationReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_multiplicationReplySeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_multiplicationReplyDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_multiplicationReplyDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_multiplicationReplyDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_multiplicationReplyDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_multiplicationReply> : MetaStruct {
  typedef Calculator_multiplicationReply T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_multiplicationReply& typed = *static_cast<const Calculator_multiplicationReply*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<ReplyHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "multiplication_ret") == 0) {
      return typed.multiplication_ret;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationReply)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<ReplyHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "multiplication_ret") == 0) {
      return make_field_cmp(&T::multiplication_ret, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationReply)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "multiplication_ret", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "multiplication_ret") == 0) {
      return &static_cast<const T*>(stru)->multiplication_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationReply)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const ReplyHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "multiplication_ret") == 0) {
      static_cast<T*>(lhs)->multiplication_ret = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationReply)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "multiplication_ret") == 0) {
      return static_cast<const T*>(lhs)->multiplication_ret == static_cast<const T*>(rhs)->multiplication_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_multiplicationReply)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_multiplicationReply>()
{
  static MetaStructImpl<Calculator_multiplicationReply> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_multiplicationReply */


/* Begin STRUCT: Calculator_divisionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_divisionRequest& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.x);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.y);
}

bool operator<<(Serializer& strm, const Calculator_divisionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.x)
    && (strm << stru.y);
}

bool operator>>(Serializer& strm, Calculator_divisionRequest& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.x)
    && (strm >> stru.y);
}

bool gen_is_bounded_size(const Calculator_divisionRequest&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_divisionRequest& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_divisionRequest>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_divisionRequest> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_divisionRequest> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_divisionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_divisionRequest> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_divisionRequest&)
{
  return false;
}

}  }

Calculator_divisionRequestTypeSupportImpl::Calculator_divisionRequestTypeSupportImpl ()
{
}

Calculator_divisionRequestTypeSupportImpl::~Calculator_divisionRequestTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_divisionRequestTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_divisionRequestTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_divisionRequestTypeSupportImpl::create_datawriter ()
{
  Calculator_divisionRequestDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_divisionRequestDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_divisionRequestTypeSupportImpl::create_datareader ()
{
  Calculator_divisionRequestDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_divisionRequestDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_divisionRequestTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_divisionRequest,
    Calculator_divisionRequestDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_divisionRequestTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_divisionRequest>();
}

#endif

bool
Calculator_divisionRequestTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_divisionRequest());
}


Calculator_divisionRequestDataWriterImpl::Calculator_divisionRequestDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_divisionRequestDataWriterImpl::~Calculator_divisionRequestDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_divisionRequestDataWriterImpl::register_instance (
    const ::Calculator_divisionRequest & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_divisionRequestDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_divisionRequest & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_divisionRequestDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::unregister_instance (
    const ::Calculator_divisionRequest & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_divisionRequest & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_divisionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_divisionRequestDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_divisionRequestDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_divisionRequestDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::write (
    const ::Calculator_divisionRequest & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::write_w_timestamp (
    const ::Calculator_divisionRequest & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_divisionRequestDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::dispose (
    const ::Calculator_divisionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_divisionRequest & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_divisionRequestDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::get_key_value (
    ::Calculator_divisionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_divisionRequestDataWriterImpl::lookup_instance (
    const ::Calculator_divisionRequest & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_divisionRequestDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_divisionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_divisionRequest > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::enable_specific ()
{
  ::Calculator_divisionRequest data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionRequestDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionRequestDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_divisionRequestDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_divisionRequestDataWriterImpl::dds_marshal(
  const ::Calculator_divisionRequest& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_divisionRequest > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_divisionRequest& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_divisionRequestDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_divisionRequest failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_divisionRequestDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_divisionRequestDataReaderImpl::Calculator_divisionRequestDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionRequestDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_divisionRequestDataReaderImpl::~Calculator_divisionRequestDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionRequestSeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_w_condition (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_w_condition (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_next_sample (
    ::Calculator_divisionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_divisionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_next_sample (
    ::Calculator_divisionRequest & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_divisionRequest *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_instance (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_instance_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_instance (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_instance_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionRequestSeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionRequestSeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_next_instance (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_next_instance_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_next_instance (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_next_instance_i (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_divisionRequestDataReaderImpl::release_loan (
    ::Calculator_divisionRequestSeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_divisionRequestDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_divisionRequest* const ptr
        = static_cast< ::Calculator_divisionRequest* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_divisionRequest );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::return_loan (
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::get_key_value (
    ::Calculator_divisionRequest & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_divisionRequestDataReaderImpl::lookup_instance (
    const ::Calculator_divisionRequest & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_divisionRequestDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_divisionRequest* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionRequestSeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_divisionRequestDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_divisionRequest*>(data));
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_divisionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionRequestSeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_divisionRequest(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_divisionRequestDataReaderImpl::store_synthetic_data(const Calculator_divisionRequest& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_divisionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_divisionRequest*>(data_allocator_->malloc(sizeof(Calculator_divisionRequest))),
      Calculator_divisionRequest(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_divisionRequestDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_divisionRequest* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_divisionRequest*>(data_allocator_->malloc(sizeof(Calculator_divisionRequest))),
      Calculator_divisionRequest);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_divisionRequestDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_divisionRequest* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_divisionRequest *>(
                            data_allocator_->malloc(sizeof(::Calculator_divisionRequest))),
                           ::Calculator_divisionRequest);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_divisionRequest>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_divisionRequestDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_divisionRequest data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_divisionRequest>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_divisionRequestDataReaderImpl::store_instance_data(
    ::Calculator_divisionRequest *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_divisionRequest );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionRequest );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_divisionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_divisionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_divisionRequestDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_divisionRequest failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_divisionRequestDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_divisionRequestDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_divisionRequest failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionRequest );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionRequest );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_divisionRequest );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_divisionRequest );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_divisionRequest );
  }
}

void
Calculator_divisionRequestDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_divisionRequestDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_divisionRequestSeq& received_data =
    *static_cast< ::Calculator_divisionRequestSeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_divisionRequestDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_divisionRequestSeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_divisionRequestSeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionRequestDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionRequestDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_divisionRequestDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_divisionRequestDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_divisionRequestDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_divisionRequest> : MetaStruct {
  typedef Calculator_divisionRequest T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_divisionRequest& typed = *static_cast<const Calculator_divisionRequest*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<RequestHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "x") == 0) {
      return typed.x;
    }
    if (std::strcmp(field, "y") == 0) {
      return typed.y;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionRequest)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<RequestHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "x") == 0) {
      return make_field_cmp(&T::x, next);
    }
    if (std::strcmp(field, "y") == 0) {
      return make_field_cmp(&T::y, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionRequest)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "x", "y", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "x") == 0) {
      return &static_cast<const T*>(stru)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return &static_cast<const T*>(stru)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionRequest)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const RequestHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "x") == 0) {
      static_cast<T*>(lhs)->x = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "y") == 0) {
      static_cast<T*>(lhs)->y = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionRequest)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "x") == 0) {
      return static_cast<const T*>(lhs)->x == static_cast<const T*>(rhs)->x;
    }
    if (std::strcmp(field, "y") == 0) {
      return static_cast<const T*>(lhs)->y == static_cast<const T*>(rhs)->y;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionRequest)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_divisionRequest>()
{
  static MetaStructImpl<Calculator_divisionRequest> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_divisionRequest */


/* Begin STRUCT: Calculator_divisionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_divisionReply& stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
  gen_find_size(stru.header, size, padding);
  if ((size + padding) % 4) {
    padding += 4 - ((size + padding) % 4);
  }
  size += gen_max_marshaled_size(stru.division_ret);
}

bool operator<<(Serializer& strm, const Calculator_divisionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm << stru.header)
    && (strm << stru.division_ret);
}

bool operator>>(Serializer& strm, Calculator_divisionReply& stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return (strm >> stru.header)
    && (strm >> stru.division_ret);
}

bool gen_is_bounded_size(const Calculator_divisionReply&)
{
  return false;
}

size_t gen_max_marshaled_size(const Calculator_divisionReply& stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

bool gen_is_bounded_size(KeyOnly<const Calculator_divisionReply>)
{
  return true;
}

size_t gen_max_marshaled_size(KeyOnly<const Calculator_divisionReply> stru, bool align)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(align);
  return 0;
}

void gen_find_size(KeyOnly<const Calculator_divisionReply> stru, size_t& size, size_t& padding)
{
  ACE_UNUSED_ARG(stru);
  ACE_UNUSED_ARG(size);
  ACE_UNUSED_ARG(padding);
}

bool operator<<(Serializer& strm, KeyOnly<const Calculator_divisionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

bool operator>>(Serializer& strm, KeyOnly<Calculator_divisionReply> stru)
{
  ACE_UNUSED_ARG(strm);
  ACE_UNUSED_ARG(stru);
  return true;
}

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_divisionReply&)
{
  return false;
}

}  }

Calculator_divisionReplyTypeSupportImpl::Calculator_divisionReplyTypeSupportImpl ()
{
}

Calculator_divisionReplyTypeSupportImpl::~Calculator_divisionReplyTypeSupportImpl ()
{
}

::DDS::ReturnCode_t
Calculator_divisionReplyTypeSupportImpl::register_type (
    ::DDS::DomainParticipant_ptr participant,
    const char * type_name)
{
  if (type_name == 0 || type_name[0] == '\0')
     this->type_name_ = this->get_type_name();
  else
     this->type_name_ = CORBA::string_dup (type_name);

  return
    ::OpenDDS::DCPS::Registered_Data_Types->register_type(
        participant,
        this->type_name_.in (),
        this);
}


char *
Calculator_divisionReplyTypeSupportImpl::get_type_name ()
{
  if (this->type_name_.in () == 0)
    return CORBA::string_dup (this->_interface_repository_id());
  else
    return CORBA::string_dup (this->type_name_.in ());
}


::DDS::DataWriter_ptr
Calculator_divisionReplyTypeSupportImpl::create_datawriter ()
{
  Calculator_divisionReplyDataWriterImpl* writer_impl;
  ACE_NEW_RETURN(writer_impl,
                 Calculator_divisionReplyDataWriterImpl(),
                 ::DDS::DataWriter::_nil());

  return writer_impl;
}

::DDS::DataReader_ptr
Calculator_divisionReplyTypeSupportImpl::create_datareader ()
{
  Calculator_divisionReplyDataReaderImpl* reader_impl = 0;
  ACE_NEW_RETURN(reader_impl,
                 Calculator_divisionReplyDataReaderImpl(),
                 ::DDS::DataReader::_nil());

  return reader_impl;
}

#ifndef OPENDDS_NO_MULTI_TOPIC
::DDS::DataReader_ptr
Calculator_divisionReplyTypeSupportImpl::create_multitopic_datareader()
{
  return new OpenDDS::DCPS::MultiTopicDataReader_T<Calculator_divisionReply,
    Calculator_divisionReplyDataReaderImpl>;
}
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

const OpenDDS::DCPS::MetaStruct&
Calculator_divisionReplyTypeSupportImpl::getMetaStructForType()
{
  return OpenDDS::DCPS::getMetaStruct<Calculator_divisionReply>();
}

#endif

bool
Calculator_divisionReplyTypeSupportImpl::has_dcps_key()
{
  return OpenDDS::DCPS::gen_has_key(Calculator_divisionReply());
}


Calculator_divisionReplyDataWriterImpl::Calculator_divisionReplyDataWriterImpl ()
  : marshaled_size_ (0)
  , key_marshaled_size_ (0)
  , db_lock_pool_(0)
  , data_allocator_ (0)
  , mb_allocator_ (0)
  , db_allocator_ (0)
{
}

Calculator_divisionReplyDataWriterImpl::~Calculator_divisionReplyDataWriterImpl ()
{
  delete data_allocator_;
  delete mb_allocator_;
  delete db_allocator_;
  delete db_lock_pool_;
}

::DDS::InstanceHandle_t
Calculator_divisionReplyDataWriterImpl::register_instance (
    const ::Calculator_divisionReply & instance)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return register_instance_w_timestamp (instance, timestamp);
}

::DDS::InstanceHandle_t
Calculator_divisionReplyDataWriterImpl::register_instance_w_timestamp (
    const ::Calculator_divisionReply & instance,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    registered_handle);

  ::DDS::ReturnCode_t const ret
    = this->get_or_create_instance_handle(registered_handle,
                                          instance,
                                          timestamp);
  if (ret != ::DDS::RETCODE_OK)
  {
    ACE_ERROR ((LM_ERROR,
                ACE_TEXT("(%P|%t) ")
                ACE_TEXT("Calculator_divisionReplyDataWriterImpl::")
                ACE_TEXT("register_instance_w_timestamp, ")
                ACE_TEXT("register failed error=%d.\n"),
                ret));
  }

  return registered_handle;
}


::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::unregister_instance (
    const ::Calculator_divisionReply & instance,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());

  return unregister_instance_w_timestamp (instance,
                                          handle,
                                          timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::unregister_instance_w_timestamp (
    const ::Calculator_divisionReply & instance,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & timestamp)
{
  ::DDS::InstanceHandle_t const registered_handle =
      this->lookup_instance(instance);

  if (registered_handle == ::DDS::HANDLE_NIL)
  {
    // This case could be the instance is not registered yet or
    // already unregistered.
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_divisionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_instance_w_timestamp, ")
                        ACE_TEXT("The instance is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
  }
  else if (handle != ::DDS::HANDLE_NIL && handle != registered_handle)
  {
    ACE_ERROR_RETURN ((LM_ERROR,
                        ACE_TEXT("(%P|%t) ")
                        ACE_TEXT("Calculator_divisionReplyDataWriterImpl::")
                        ACE_TEXT("unregister_w_timestamp, ")
                        ACE_TEXT("The given handle=%X is different from ")
                        ACE_TEXT("registered handle=%X.\n"),
                        handle, registered_handle),
                        ::DDS::RETCODE_ERROR);
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  // DataWriterImpl::unregister_instance_i will call back to inform the
  // Calculator_divisionReplyDataWriter.
  // That the instance handle is removed from there and hence
  // Calculator_divisionReplyDataWriter can remove the instance here.
  return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(handle, timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::write (
    const ::Calculator_divisionReply & instance_data,
    ::DDS::InstanceHandle_t handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return write_w_timestamp (instance_data,
                            handle,
                            source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::write_w_timestamp (
    const ::Calculator_divisionReply & instance_data,
    ::DDS::InstanceHandle_t handle,
    const ::DDS::Time_t & source_timestamp)
{
  //  A lock is obtained on entering this method to serialize access to
  //  the contained data storage and interfaces.  This lock protects the
  //  marshaled data buffers as well as the instance data containers.

  //  This operation assumes the provided handle is valid. The handle
  //  provided will not be verified.

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  if (handle == ::DDS::HANDLE_NIL)
  {
    ::DDS::InstanceHandle_t registered_handle = ::DDS::HANDLE_NIL;
    ::DDS::ReturnCode_t ret
      = this->get_or_create_instance_handle(registered_handle,
                                            instance_data,
                                            source_timestamp);
    if (ret != ::DDS::RETCODE_OK)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_divisionReplyDataWriterImpl::write, ")
                         ACE_TEXT("register failed err=%d.\n"),
                         ret),
                        ret);
    }

    handle = registered_handle;
  }

  // list of reader RepoIds that should not get data
  OpenDDS::DCPS::GUIDSeq_var filter_out;
#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (TheServiceParticipant->publisher_content_filter()) {
    for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
         end = reader_info_.end(); iter != end; ++iter) {
      const ReaderInfo& ri = iter->second;
      if (!ri.eval_.is_nil()) {
        if (!filter_out.ptr()) {
          filter_out = new OpenDDS::DCPS::GUIDSeq;
        }
        if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
          push_back(filter_out.inout(), iter->first);
        }
      }
    }
  }
#endif

  ACE_Message_Block* const marshalled =
    dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING);

  return OpenDDS::DCPS::DataWriterImpl::write(marshalled, handle,
                                              source_timestamp,
                                              filter_out._retn());
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::dispose (
    const ::Calculator_divisionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle)
{
  ::DDS::Time_t const source_timestamp =
    ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
  return dispose_w_timestamp (instance_data,
                              instance_handle,
                              source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::dispose_w_timestamp (
    const ::Calculator_divisionReply & instance_data,
    ::DDS::InstanceHandle_t instance_handle,
    const ::DDS::Time_t & source_timestamp)
{
  if(instance_handle == ::DDS::HANDLE_NIL)
  {
    instance_handle = this->lookup_instance(instance_data);
    if (instance_handle == ::DDS::HANDLE_NIL)
    {
      ACE_ERROR_RETURN ((LM_ERROR,
                         ACE_TEXT("(%P|%t) ")
                         ACE_TEXT("Calculator_divisionReplyDataWriterImpl::dispose, ")
                         ACE_TEXT("The instance sample is not registered.\n")),
                        ::DDS::RETCODE_ERROR);
    }
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
                                                source_timestamp);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::get_key_value (
    ::Calculator_divisionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_divisionReplyDataWriterImpl::lookup_instance (
    const ::Calculator_divisionReply & instance_data)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    get_lock (),
                    ::DDS::RETCODE_ERROR);

  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}


void
Calculator_divisionReplyDataWriterImpl::init (
      ::DDS::Topic_ptr                       topic,
      OpenDDS::DCPS::TopicImpl*              topic_servant,
      const ::DDS::DataWriterQos &           qos,
      ::DDS::DataWriterListener_ptr          a_listener,
      const ::DDS::StatusMask &              mask,
      OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
      OpenDDS::DCPS::PublisherImpl*          publisher_servant,
      ::DDS::DataWriter_ptr                  dw_objref
    )
{
  OpenDDS::DCPS::DataWriterImpl::init (topic,
                                       topic_servant,
                                       qos,
                                       a_listener,
                                       mask,
                                       participant_servant,
                                       publisher_servant,
                                       dw_objref);

  ::Calculator_divisionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size(data)) {
    marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(data, true);
    // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
  OpenDDS::DCPS::KeyOnly<const ::Calculator_divisionReply > ko(data);
  if (OpenDDS::DCPS::gen_is_bounded_size(ko)) {
    key_marshaled_size_ = 8 + OpenDDS::DCPS::gen_max_marshaled_size(ko, true);
    // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
  } else {
    key_marshaled_size_ = 0; // should use gen_find_size when marshaling
  }
}


::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::enable_specific ()
{
  ::Calculator_divisionReply data;
  if (OpenDDS::DCPS::gen_is_bounded_size (data))
  {
    data_allocator_ = new DataAllocator (n_chunks_, marshaled_size_);
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-data")
                 ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
                 ACE_TEXT("with %d chunks\n"),
                 data_allocator_,
                 n_chunks_));
  }
  else
  {
    if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionReplyDataWriterImpl::enable_specific")
                 ACE_TEXT(" is unbounded data - allocate from heap\n")));
  }

  mb_allocator_ =
   new ::OpenDDS::DCPS::MessageBlockAllocator (
     n_chunks_ * association_chunk_multiplier_);
  db_allocator_ = new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_);

  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    {
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-mb ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 mb_allocator_,
                 n_chunks_ * association_chunk_multiplier_));
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionReplyDataWriterImpl::")
                 ACE_TEXT("enable_specific-db ")
                 ACE_TEXT("Cached_Allocator_With_Overflow ")
                 ACE_TEXT("%x with %d chunks\n"),
                 db_allocator_,
                 n_chunks_));
    }

  db_lock_pool_ = new DataBlockLockPool(n_chunks_);

  return ::DDS::RETCODE_OK;
}

// Note: The Calculator_divisionReplyDataWriter gives ownership of the marshalled data
//       to the WriteDataContainer.
ACE_Message_Block*
Calculator_divisionReplyDataWriterImpl::dds_marshal(
  const ::Calculator_divisionReply& instance_data,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();

  ACE_Message_Block* mb;
  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    // Don't use the cached allocator for the registered sample message
    // block.

    OpenDDS::DCPS::KeyOnly<const ::Calculator_divisionReply > ko_instance_data(instance_data);
    size_t effective_size = 0, padding = 0;
    if (key_marshaled_size_) {
      effective_size = key_marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(ko_instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_RETURN(mb, ACE_Message_Block(effective_size), 0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << ko_instance_data;

  } else { // OpenDDS::DCPS::FULL_MARSHALING
    size_t effective_size = 0, padding = 0;
    if (marshaled_size_) {
      effective_size = marshaled_size_;
    } else {
      if (cdr) {
        effective_size = 4; // CDR encapsulation
      }
      OpenDDS::DCPS::gen_find_size(instance_data, effective_size, padding);
    }
    if (cdr) {
      effective_size += padding;
    }
    ACE_NEW_MALLOC_RETURN(mb,
                          static_cast<ACE_Message_Block*>(
                              mb_allocator_->malloc(
                              sizeof(ACE_Message_Block))),
                          ACE_Message_Block(
                              effective_size,
                              ACE_Message_Block::MB_DATA,
                              0, //cont
                              0, //data
                              data_allocator_, //allocator_strategy
                              db_lock_pool_->get_lock(), //data block locking_strategy
                              ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                              ACE_Time_Value::zero,
                              ACE_Time_Value::max_time,
                              db_allocator_,
                              mb_allocator_),
                           0);
    OpenDDS::DCPS::Serializer serializer(mb, swap, cdr
      ? OpenDDS::DCPS::Serializer::ALIGN_CDR
      : OpenDDS::DCPS::Serializer::ALIGN_NONE);
    if (cdr) {
      serializer << ACE_OutputCDR::from_octet(0);
      serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
      serializer << ACE_CDR::UShort(0);
    }
    serializer << instance_data;
  }

  return mb;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataWriterImpl::get_or_create_instance_handle(
  ::DDS::InstanceHandle_t& handle,
  const ::Calculator_divisionReply& instance_data,
  const ::DDS::Time_t & source_timestamp)
{
  handle = ::DDS::HANDLE_NIL;
  InstanceMap::const_iterator it = instance_map_.find(instance_data);

  bool needs_creation = true;
  bool needs_registration = true;

  if (it != instance_map_.end())
  {
    needs_creation = false;

    handle = it->second;
    OpenDDS::DCPS::PublicationInstance* instance = get_handle_instance(handle);

    if (instance->unregistered_ == false)
    {
      needs_registration = false;
    }
    // else: The instance is unregistered and now register again.
  }

  if (needs_registration)
  {
    // don't use fast allocator for registration.
    ACE_Message_Block* const marshalled =
      this->dds_marshal(instance_data,
                        OpenDDS::DCPS::KEY_ONLY_MARSHALING);

    // tell DataWriterLocal and Publisher about the instance.
    ::DDS::ReturnCode_t ret = register_instance_i(handle, marshalled, source_timestamp);
    // note: the WriteDataContainer/PublicationInstance maintains ownership
    // of the marshalled sample.

    if (ret != ::DDS::RETCODE_OK)
    {
      marshalled->release ();
      handle = ::DDS::HANDLE_NIL;
      return ret;
    }

    if (needs_creation)
    {
      std::pair<InstanceMap::iterator, bool> pair =
        instance_map_.insert(InstanceMap::value_type(instance_data, handle));

      if (pair.second == false)
      {
        handle = ::DDS::HANDLE_NIL;
        ACE_ERROR_RETURN ((LM_ERROR,
                           ACE_TEXT("(%P|%t) ")
                           ACE_TEXT("Calculator_divisionReplyDataWriterImpl::")
                           ACE_TEXT("get_or_create_instance_handle, ")
                           ACE_TEXT("insert Calculator_divisionReply failed. \n")),
                          ::DDS::RETCODE_ERROR);
      }
    } // end of if (needs_creation)
  } // end of if (needs_registration)

  return ::DDS::RETCODE_OK;
}


void
Calculator_divisionReplyDataWriterImpl::unregistered(
  ::DDS::InstanceHandle_t /* instance_handle */)
{
  // Previously this method removed the instance from the instance_map_.
  // The instance handle will not be removed from the
  // map so the instance for re-registration after unregistered
  // will use the old handle.
}

// Implementation skeleton constructor
Calculator_divisionReplyDataReaderImpl::Calculator_divisionReplyDataReaderImpl ()
  : data_allocator_ (0)
{
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::enable_specific ()
{
  data_allocator_ = new DataAllocator(get_n_chunks ());
  if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionReplyDataReaderImpl::")
               ACE_TEXT("enable_specific-data")
               ACE_TEXT(" Cached_Allocator_With_Overflow ")
               ACE_TEXT("%x with %d chunks\n"),
               data_allocator_,
               this->get_n_chunks ()));

  return ::DDS::RETCODE_OK;
}

Calculator_divisionReplyDataReaderImpl::~Calculator_divisionReplyDataReaderImpl ()
{
  for (InstanceMap::iterator it = instance_map_.begin();
       it != instance_map_.end(); ++it)
  {
    OpenDDS::DCPS::SubscriptionInstance* ptr =
      get_handle_instance(it->second);
    this->purge_data(ptr);
  }

  delete data_allocator_;
  //X SHH release the data samples in the instance_map_.
}


::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::delete_contained_entities ()
{
  return this->delete_contained_entities();
}


::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionReplySeq >
    results(this, received_data, info_seq, max_samples,
            this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
            a_condition,
#endif
            ::OpenDDS::DCPS::DDS_OPERATION_READ);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif
    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
          )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();

  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_i(received_data, info_seq, max_samples, sample_states,
                view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
    && ! this->coherent_) {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  bool group_coherent_ordered
    = this->subqos_.presentation.access_scope == ::DDS::GROUP_PRESENTATION_QOS
      && this->subqos_.presentation.coherent_access
      && this->subqos_.presentation.ordered_access;

  if (group_coherent_ordered && this->coherent_) {
    max_samples = 1;
  }
#endif

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  if (! group_coherent_ordered) {
#endif

    for (InstanceMap::iterator it = instance_map_.begin(),
          the_end = instance_map_.end(); it != the_end; ++it)
    {
      ::DDS::InstanceHandle_t handle = it->second;

      OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(handle);

      if ((inst->instance_state_.view_state() & view_states) &&
          (inst->instance_state_.instance_state() & instance_states))
      {
        size_t i(0);
        for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
            item != 0; item = item->next_data_sample_)
        {
          if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
              && !item->coherent_change_
#endif
             )
          {
            results.insert_sample(item, inst, ++i);
          }
        }
      }
    }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
  }
  else {
    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
  }
#endif

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_w_condition (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return read_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition));
#else
                0);
#endif
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_w_condition (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & sample_info,
    ::CORBA::Long max_samples,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_w_condition", received_data, sample_info, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  return take_i(received_data, sample_info, max_samples,
                a_condition->get_sample_state_mask(),
                a_condition->get_view_state_mask(),
                a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition)
#else
                0
#endif
                );
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_next_sample (
    ::Calculator_divisionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{

  bool found_data = false;

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {
      for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
           item != 0;
           item = item->next_data_sample_)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_) continue;
#endif

        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_divisionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;


          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      this->sample_info(sample_info, ptr->rcvd_samples_.tail_);

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_next_sample (
    ::Calculator_divisionReply & received_data,
    ::DDS::SampleInfo & sample_info)
{
  bool found_data = false;


  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    ::DDS::InstanceHandle_t handle = it->second;
    OpenDDS::DCPS::SubscriptionInstance* ptr = get_handle_instance(handle);

    bool mrg = false; //most_recent_generation

    OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    if ((ptr->instance_state_.view_state() & ::DDS::ANY_VIEW_STATE) &&
        (ptr->instance_state_.instance_state() & ::DDS::ANY_INSTANCE_STATE))
    {

      OpenDDS::DCPS::ReceivedDataElement *next;
      tail = 0;
      OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
      while (item)
      {
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        if (item->coherent_change_)
        {
            item = item->next_data_sample_;
            continue;
        }
#endif
        if (item->sample_state_ & ::DDS::NOT_READ_SAMPLE_STATE)
        {
          if (item->registered_data_ != 0)
          {
            received_data =
              *static_cast< ::Calculator_divisionReply *> (item->registered_data_);
          }
          ptr->instance_state_.sample_info(sample_info, item);

          item->sample_state_ = ::DDS::READ_SAMPLE_STATE;

          if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);

          if (item == ptr->rcvd_samples_.tail_)
          {
            tail = ptr->rcvd_samples_.tail_;
            item = item->next_data_sample_;
          }
          else
          {
            next = item->next_data_sample_;

            ptr->rcvd_samples_.remove(item);
            dec_ref_data_element(item);

            item = next;
          }

          found_data = true;
        }
        if (found_data)
        {
          break;
        }
      }
    }

    if (found_data)
    {
      if (mrg) ptr->instance_state_.accessed();

      //
      // Get the sample_ranks, generation_ranks, and
      // absolute_generation_ranks for this info_seq
      //
      if (tail)
      {
        this->sample_info(sample_info, tail);

        ptr->rcvd_samples_.remove(tail);
        dec_ref_data_element(tail);
      }
      else
      {
        this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
      }

      break;
    }
  }
  post_read_or_take();
  return found_data ? ::DDS::RETCODE_OK : ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_instance (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return read_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_instance_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_READ);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);
  if (inst == 0) return ::DDS::RETCODE_BAD_PARAMETER;

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_instance (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);
  return take_instance_i(received_data, info_seq, max_samples, a_handle,
                         sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_instance_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::Calculator_divisionReplySeq::PrivateMemberAccess received_data_p(received_data);

  ::OpenDDS::DCPS::RakeResults< ::Calculator_divisionReplySeq >
     results(this, received_data, info_seq, max_samples,
             this->subqos_.presentation,
#ifndef OPENDDS_NO_QUERY_CONDITION
             a_condition,
#endif
             ::OpenDDS::DCPS::DDS_OPERATION_TAKE);

  OpenDDS::DCPS::SubscriptionInstance* inst = get_handle_instance(a_handle);

  if ((inst->instance_state_.view_state() & view_states) &&
      (inst->instance_state_.instance_state() & instance_states))
  {
    size_t i(0);
    for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
         item; item = item->next_data_sample_)
    {
      if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
          && !item->coherent_change_
#endif
         )
      {
        results.insert_sample(item, inst, ++i);
      }
    }
  }

  results.copy_to_user();

  ::DDS::ReturnCode_t ret = ::DDS::RETCODE_NO_DATA;
  if (received_data.length())
  {
    ret = ::DDS::RETCODE_OK;
    if (received_data.maximum() == 0) //using ZeroCopy
    {
      received_data_p.set_loaner(this);
    }
  }

  post_read_or_take();
  return ret;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_next_instance (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_next_instance_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin ();
         it != the_end;
         ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      read_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      post_read_or_take();
      return status;
    }
  }

  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_next_instance (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance", received_data, info_seq, max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              sample_states, view_states, instance_states, 0);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_next_instance_i (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::SampleStateMask sample_states,
    ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
    ::DDS::QueryCondition_ptr a_condition)
#else
    int /*ignored*/)
#endif
{
 ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator it;
  InstanceMap::iterator const the_end = instance_map_.end ();

  if (a_handle == ::DDS::HANDLE_NIL)
  {
    it = instance_map_.begin ();
  }
  else
  {
    for (it = instance_map_.begin (); it != the_end; ++it)
    {
      if (a_handle == it->second)
      {
        ++it;
        break;
      }
    }
  }

  for (; it != the_end; ++it)
  {
    handle = it->second;
    ::DDS::ReturnCode_t const status =
      take_instance_i(received_data, info_seq, max_samples, handle,
                      sample_states, view_states, instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
                      a_condition);
#else
                      0);
#endif
    if (status != ::DDS::RETCODE_NO_DATA)
    {
      total_samples();  // see if we are empty
      post_read_or_take();
      return status;
    }
  }
  post_read_or_take();
  return ::DDS::RETCODE_NO_DATA;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_next_instance_w_condition (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("read_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::take_next_instance_w_condition (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples,
    ::DDS::InstanceHandle_t a_handle,
    ::DDS::ReadCondition_ptr a_condition)
{
  ::DDS::ReturnCode_t const precond =
    check_inputs("take_next_instance_w_condition", received_data, info_seq,
                 max_samples);
  if (::DDS::RETCODE_OK != precond)
  {
    return precond;
  }

  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  if (!has_readcondition(a_condition))
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

#ifndef OPENDDS_NO_QUERY_CONDITION
  ::DDS::QueryCondition_ptr query_condition =
    dynamic_cast< ::DDS::QueryCondition_ptr >(a_condition);
#endif

  return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
                              a_condition->get_sample_state_mask(),
                              a_condition->get_view_state_mask(),
                              a_condition->get_instance_state_mask(),
#ifndef OPENDDS_NO_QUERY_CONDITION
                              query_condition
#else
                              0
#endif
                              );
}

void
Calculator_divisionReplyDataReaderImpl::release_loan (
    ::Calculator_divisionReplySeq & received_data
  )
{
  received_data.length(0);
}


void
Calculator_divisionReplyDataReaderImpl::dec_ref_data_element(
  ::OpenDDS::DCPS::ReceivedDataElement* item
  )
{
  using ::OpenDDS::DCPS::ReceivedDataElement;

  if (0 == item->dec_ref())
  {
    if (item->registered_data_ != 0)
    {
      ::Calculator_divisionReply* const ptr
        = static_cast< ::Calculator_divisionReply* >(item->registered_data_);
      ACE_DES_FREE (ptr,
                    data_allocator_->free,
                    Calculator_divisionReply );
    }

    ACE_DES_FREE (item,
                  rd_allocator_->free,
                  ReceivedDataElement);
  }
}


::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::return_loan (
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq)
{
  // Some incomplete tests to see that the data and info are from the
  // same read.
  if (received_data.length() != info_seq.length())
  {
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.release())
  {
    // nothing to do because this is not zero-copy data
    return ::DDS::RETCODE_OK;
  }
  else
  {
    info_seq.length(0);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::get_key_value (
    ::Calculator_divisionReply & key_holder,
    ::DDS::InstanceHandle_t handle)
{
  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
                    guard,
                    this->sample_lock_,
                    ::DDS::RETCODE_ERROR);

  InstanceMap::iterator const the_end = instance_map_.end ();
  for (InstanceMap::iterator it = instance_map_.begin ();
       it != the_end;
       ++it)
  {
    if (it->second == handle)
    {
      key_holder = it->first;
      return ::DDS::RETCODE_OK;
    }
  }

  return ::DDS::RETCODE_ERROR;
}


::DDS::InstanceHandle_t
Calculator_divisionReplyDataReaderImpl::lookup_instance (
    const ::Calculator_divisionReply & instance_data)
{
  InstanceMap::const_iterator const it = instance_map_.find(instance_data);

  if (it == instance_map_.end())
  {
    return ::DDS::HANDLE_NIL;
  }
  else
  {
    return it->second;
  }
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
bool
Calculator_divisionReplyDataReaderImpl::contains_sample_filtered(::DDS::SampleStateMask sample_states,
  ::DDS::ViewStateMask view_states, ::DDS::InstanceStateMask instance_states,
  const OpenDDS::DCPS::FilterEvaluator& evaluator, const ::DDS::StringSeq& params)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);

  for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
       end = instances_.end(); iter != end; ++iter) {
    SubscriptionInstance& inst = *iter->second;

    if ((inst.instance_state_.view_state() & view_states) &&
        (inst.instance_state_.instance_state() & instance_states)) {
      for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
           item = item->next_data_sample_) {
        if (item->sample_state_ & sample_states
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
            && !item->coherent_change_
#endif
           ) {
          if (evaluator.eval(*static_cast< ::Calculator_divisionReply* >(item->registered_data_), params)) {
            return true;
          }
        }
      }
    }
  }

  return false;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_generic(
  OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionReplySeq data;
  ::DDS::ReturnCode_t rc = read_i(data, gen.info_, ::DDS::LENGTH_UNLIMITED,
    sample_states, view_states, instance_states, 0);
  gen.samples_.reserve(data.length());
  for (CORBA::ULong i = 0; i < data.length(); ++i) {
    gen.samples_.push_back(&data[i]);
  }
  return rc;
}

::DDS::InstanceHandle_t
Calculator_divisionReplyDataReaderImpl::lookup_instance_generic(const void* data)
{
  return lookup_instance(*static_cast<const Calculator_divisionReply*>(data));
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_divisionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::read_next_instance_generic(void*& data,
  ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
  ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
  ::DDS::InstanceStateMask instance_states)
{
  Calculator_divisionReplySeq dataseq;
  ::DDS::SampleInfoSeq infoseq;
  ::DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
    ::DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
    instance_states, 0);
  if (rc == ::DDS::RETCODE_NO_DATA) return rc;
  const CORBA::ULong last = dataseq.length() - 1;
  data = new Calculator_divisionReply(dataseq[last]);
  info = infoseq[last];
  return rc;
}

#endif // OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE

::DDS::InstanceHandle_t
Calculator_divisionReplyDataReaderImpl::store_synthetic_data(const Calculator_divisionReply& sample,
  ::DDS::ViewStateKind view)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
                   ::DDS::HANDLE_NIL);

#ifndef OPENDDS_NO_MULTI_TOPIC
  ::DDS::TopicDescription_var descr = get_topicdescription();
  if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    if (!mt->filter(sample)) {
      return ::DDS::HANDLE_NIL;
    }
  }
#endif

  get_subscriber_servant()->data_received(this);

  ::DDS::InstanceHandle_t inst = lookup_instance(sample);
  bool filtered;
  SubscriptionInstance* instance = 0;

  // Call store_instance_data() once or twice, depending on if we need to
  // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
  // owns the memory for the sample and it must come from the correct allocator.
  for (int i = 0; i < 2; ++i) {
    if (i == 0 && inst != ::DDS::HANDLE_NIL) continue;

    DataSampleHeader header;
    header.message_id_ = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    bool just_registered;
    Calculator_divisionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_divisionReply*>(data_allocator_->malloc(sizeof(Calculator_divisionReply))),
      Calculator_divisionReply(sample));
    store_instance_data(data, header, instance, just_registered, filtered);
    if (instance) inst = instance->instance_handle_;
  }

  if (!filtered) {
    if (view == ::DDS::NOT_NEW_VIEW_STATE) {
      instance->instance_state_.accessed();
    }
    notify_read_conditions();
  }
  return inst;
}

void
Calculator_divisionReplyDataReaderImpl::set_instance_state(::DDS::InstanceHandle_t instance,
  ::DDS::InstanceStateKind state)
{
  using namespace OpenDDS::DCPS;
  ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);

  SubscriptionInstance* si = get_handle_instance(instance);
  if (si && state != ::DDS::ALIVE_INSTANCE_STATE) {
    DataSampleHeader header;
    header.message_id_ = (state == ::DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
      ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    bool just_registered, filtered;
    Calculator_divisionReply* data;
    ACE_NEW_MALLOC_NORETURN(data,
      static_cast< Calculator_divisionReply*>(data_allocator_->malloc(sizeof(Calculator_divisionReply))),
      Calculator_divisionReply);
    get_key_value(*data, instance);
    store_instance_data(data, header, si, just_registered, filtered);
    notify_read_conditions();
  }
}

void
Calculator_divisionReplyDataReaderImpl::dds_demarshal(
  const OpenDDS::DCPS::ReceivedDataSample& sample,
  OpenDDS::DCPS::SubscriptionInstance*& instance,
  bool& just_registered,
  bool& filtered,
  OpenDDS::DCPS::MarshalingType marshaling_type)
{
  ::Calculator_divisionReply* data;

  ACE_NEW_MALLOC_NORETURN(data,
                          static_cast< ::Calculator_divisionReply *>(
                            data_allocator_->malloc(sizeof(::Calculator_divisionReply))),
                           ::Calculator_divisionReply);

  const bool cdr = sample.header_.cdr_encapsulation_;

  OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_divisionReply>(*data);
  } else {
    ser >> *data;
  }

#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
  if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
    using OpenDDS::DCPS::ContentFilteredTopicImpl;
    if (ContentFilteredTopicImpl* cft =
        dynamic_cast<ContentFilteredTopicImpl*>(content_filtered_topic_.in())) {
      if (sample.header_.message_id_ == OpenDDS::DCPS::SAMPLE_DATA
          && !cft->filter(*data)) {
        filtered = true;
        return;
      }
    }
  }
#endif

  store_instance_data(data, sample.header_, instance, just_registered, filtered);
}


void
Calculator_divisionReplyDataReaderImpl::lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                        OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  ::Calculator_divisionReply data;

  const bool cdr = sample.header_.cdr_encapsulation_;

  ::OpenDDS::DCPS::Serializer ser(
    sample.sample_,
    sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
    cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);

  if (cdr) {
    ACE_CDR::ULong header;
    ser >> header;
  }

  if (sample.header_.key_fields_only_) {
    ser >> ::OpenDDS::DCPS::KeyOnly< ::Calculator_divisionReply>(data);
  } else {
    ser >> data;
  }

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);
  InstanceMap::const_iterator const it = instance_map_.find(data);
  if (it != instance_map_.end()) {
    handle = it->second;
  }

  if (handle == ::DDS::HANDLE_NIL) {
    instance = 0;
  } else {
    instance = get_handle_instance(handle);
  }
}


void
Calculator_divisionReplyDataReaderImpl::store_instance_data(
    ::Calculator_divisionReply *instance_data,
    const OpenDDS::DCPS::DataSampleHeader& header,
    OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
    bool & just_registered,
    bool & filtered)
{
  bool is_dispose_msg = header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE;
  bool is_unregister_msg = header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE;

  ::DDS::InstanceHandle_t handle(::DDS::HANDLE_NIL);

  //!!! caller should already have the sample_lock_
  //We will unlock it before calling into listeners

  InstanceMap::const_iterator const it = instance_map_.find(*instance_data);

  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
  {
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_divisionReply );
    instance_data = 0;
    return;
  }


  if (it == instance_map_.end())
  {
    if ((this->qos_.resource_limits.max_instances != ::DDS::LENGTH_UNLIMITED) &&
       ((::CORBA::Long) instances_.size() >= this->qos_.resource_limits.max_instances))
    {

        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_INSTANCES_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionReply );

        return;
    }

    // first find the instance mapin the participant instance map.
    // if the instance map for the type is not registered, then
    // create the instance map.
    // if the instance map for the type exists, then find the
    // handle of the instance. If the instance is not registered
    //
#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    InstanceMap* inst = 0;
    bool new_handle = true;
    if (this->is_exclusive_ownership_) {
      if (this->owner_manager_->instance_lock_acquire () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_divisionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("acquire instance_lock failed. \n")));
        return;
      }

      inst = (InstanceMap*)(
        this->owner_manager_->get_instance_map(this->topic_servant_->type_name(), this));
      if (inst != 0) {
        InstanceMap::const_iterator const iter = inst->find(*instance_data);
        if (iter != inst->end ()) {
          handle = iter->second;
          new_handle = false;
        }
      }
    }
#endif

    just_registered = true;
    OpenDDS::DCPS::SubscriptionInstance* instance = 0;
    ::DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(instance_data);
    handle = handle == ::DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    ACE_NEW (instance,
             OpenDDS::DCPS::SubscriptionInstance(this,
                                                 this->qos_,
                                                 this->sample_lock_,
                                                 handle));

    instance->instance_handle_ = handle;
    int ret = OpenDDS::DCPS::bind(instances_, handle, instance);

    if (ret != 0)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_divisionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert handle failed. \n")));
      return;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_) {
      if (inst == 0) {
        inst = new InstanceMap ();
        this->owner_manager_->set_instance_map(
          this->topic_servant_->type_name(), reinterpret_cast <void* > (inst), this);
      }

      if (new_handle) {
        std::pair<InstanceMap::iterator, bool> bpair =
          inst->insert(InstanceMap::value_type(*instance_data,
                                handle));
        if (bpair.second == false)
        {
          ACE_ERROR ((LM_ERROR,
                      ACE_TEXT("(%P|%t) ")
                      ACE_TEXT("Calculator_divisionReplyDataReaderImpl::")
                      ACE_TEXT("store_instance_data, ")
                      ACE_TEXT("insert to participant scope ::Calculator_divisionReply failed. \n")));
          return;
        }
      }

      if (this->owner_manager_->instance_lock_release () != 0) {
        ACE_ERROR ((LM_ERROR,
                    ACE_TEXT("(%P|%t) ")
                    ACE_TEXT("Calculator_divisionReplyDataReaderImpl::")
                    ACE_TEXT("store_instance_data, ")
                    ACE_TEXT("release instance_lock failed. \n")));
        return;
      }
    }
#endif

    std::pair<InstanceMap::iterator, bool> bpair =
      instance_map_.insert(InstanceMap::value_type(*instance_data,
                               handle));
    if (bpair.second == false)
    {
      ACE_ERROR ((LM_ERROR,
                  ACE_TEXT("(%P|%t) ")
                  ACE_TEXT("Calculator_divisionReplyDataReaderImpl::")
                  ACE_TEXT("store_instance_data, ")
                  ACE_TEXT("insert ::Calculator_divisionReply failed. \n")));
      return;
    }
  }
  else
  {
    just_registered = false;
    handle = it->second;
  }

  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
  {
    instance_ptr = get_handle_instance(handle);

    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
    {
      // Check instance based QoS policy filters
      // (i.e. OWNERSHIP, TIME_BASED_FILTER)
      filtered = this->filter_instance(instance_ptr,header.publication_id_);

      if (filtered)
      {
        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionReply );
        return;
      }
    }

    if ((this->qos_.resource_limits.max_samples_per_instance !=
          ::DDS::LENGTH_UNLIMITED) &&
       (instance_ptr->rcvd_samples_.size_ >=
        this->qos_.resource_limits.max_samples_per_instance))
    {

        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

        if  (! is_dispose_msg  && ! is_unregister_msg
          && instance_ptr->rcvd_samples_.head_->sample_state_
          == ::DDS::NOT_READ_SAMPLE_STATE)
        {
        // for now the implemented QoS means that if the head sample
        // is NOT_READ then none are read.
        // TBD - in future we will reads may not read in order so
        //       just looking at the head will not be enough.
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

        set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

        sample_rejected_status_.last_reason =
          ::DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
        ++sample_rejected_status_.total_count;
        ++sample_rejected_status_.total_count_change;
        sample_rejected_status_.last_instance_handle = handle;

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_rejected(dr.in (),
                                       sample_rejected_status_);
        }  // do we want to do something if listener is nil???
        notify_status_condition();

        ACE_DES_FREE (instance_data,
                      data_allocator_->free,
                      Calculator_divisionReply );

        return;
       }
       else if (! is_dispose_msg  && ! is_unregister_msg)
       {
         // Discard the oldest previously-read sample
         OpenDDS::DCPS::ReceivedDataElement *item =
           instance_ptr->rcvd_samples_.head_;
         instance_ptr->rcvd_samples_.remove(item);
         dec_ref_data_element(item);
      }
    }
    else if (this->qos_.resource_limits.max_samples != ::DDS::LENGTH_UNLIMITED)
    {
      CORBA::Long total_samples = 0;
      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
           iter != instances_.end();
           ++iter) {
        OpenDDS::DCPS::SubscriptionInstance *ptr = iter->second;

        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
      }

      if(total_samples >= this->qos_.resource_limits.max_samples)
      {
        // According to spec 1.2, Samples that contain no data do not
        // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        // so do not remove the oldest sample when unregister/dispose
        // message arrives.

         if  (! is_dispose_msg  && ! is_unregister_msg
            && instance_ptr->rcvd_samples_.head_->sample_state_
            == ::DDS::NOT_READ_SAMPLE_STATE)
         {
           // for now the implemented QoS means that if the head sample
           // is NOT_READ then none are read.
           // TBD - in future we will reads may not read in order so
           //       just looking at the head will not be enough.
           ::DDS::DataReaderListener_var listener
               = listener_for (::DDS::SAMPLE_REJECTED_STATUS);

           set_status_changed_flag (::DDS::SAMPLE_REJECTED_STATUS, true);

           sample_rejected_status_.last_reason =
              ::DDS::REJECTED_BY_SAMPLES_LIMIT;
           ++sample_rejected_status_.total_count;
           ++sample_rejected_status_.total_count_change;
           sample_rejected_status_.last_instance_handle = handle;
           ::DDS::DataReader_var dr = get_dr_obj_ref();
           if (!CORBA::is_nil(listener.in()))
           {
             ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

             listener->on_sample_rejected(dr.in (),
                                          sample_rejected_status_);
           }  // do we want to do something if listener is nil???
           notify_status_condition();

           ACE_DES_FREE (instance_data,
                         data_allocator_->free,
                         Calculator_divisionReply );

           return;
         }
         else if (! is_dispose_msg  && ! is_unregister_msg)
         {
           // Discard the oldest previously-read sample
           OpenDDS::DCPS::ReceivedDataElement *item =
             instance_ptr->rcvd_samples_.head_;
           instance_ptr->rcvd_samples_.remove(item);
           dec_ref_data_element(item);
        }
      }
    }

    if (is_dispose_msg || is_unregister_msg)
    {
      ACE_DES_FREE (instance_data,
                    data_allocator_->free,
                    Calculator_divisionReply );
      instance_data = 0;
    }

    bool event_notify = true;
    if (is_dispose_msg)
    {
      event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_) ;
    }
    else if (is_unregister_msg)
    {
      event_notify = instance_ptr->instance_state_.unregister_was_received(header.publication_id_) ;
    }
    else
    {
      instance_ptr->instance_state_.data_was_received(header.publication_id_) ;
    }

#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    if (this->is_exclusive_ownership_ && is_unregister_msg) {
      this->owner_manager_->unregister_reader (this->topic_servant_->type_name(),this);
    }
#endif

    if (! event_notify)
    {
       return;
    }

    OpenDDS::DCPS::ReceivedDataElement *ptr;
    ACE_NEW_MALLOC (ptr,
                    static_cast<OpenDDS::DCPS::ReceivedDataElement *> (
                        rd_allocator_->malloc (
                            sizeof (OpenDDS::DCPS::ReceivedDataElement))),
                    OpenDDS::DCPS::ReceivedDataElement(header,
                                                       instance_data));

    ptr->disposed_generation_count_ =
        instance_ptr->instance_state_.disposed_generation_count();
    ptr->no_writers_generation_count_ =
        instance_ptr->instance_state_.no_writers_generation_count();

    instance_ptr->last_sequence_ = header.sequence_;

    instance_ptr->rcvd_strategy_->add(ptr);

    if (! is_dispose_msg  && ! is_unregister_msg
        && instance_ptr->rcvd_samples_.size_ > get_depth())
    {
      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
        instance_ptr->rcvd_samples_.head_;

      instance_ptr->rcvd_samples_.remove(head_ptr);

      if (head_ptr->sample_state_ == ::DDS::NOT_READ_SAMPLE_STATE)
      {
        ::DDS::DataReaderListener_var listener
            = listener_for (::DDS::SAMPLE_LOST_STATUS);

        ++sample_lost_status_.total_count;
        ++sample_lost_status_.total_count_change;

        set_status_changed_flag(::DDS::SAMPLE_LOST_STATUS, true);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_sample_lost(dr.in (), sample_lost_status_);
        }

        notify_status_condition();
      }

      dec_ref_data_element(head_ptr);
    }

#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    if (! ptr->coherent_change_) {
#endif
      OpenDDS::DCPS::SubscriberImpl* sub = get_subscriber_servant ();

      sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, true);
      set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, true);

      ::DDS::SubscriberListener_var sub_listener =
          sub->listener_for(::DDS::DATA_ON_READERS_STATUS);
      if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
      {
        ACE_GUARD (Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

        sub_listener->on_data_on_readers(get_subscriber()) ;
        sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
      }
      else
      {
        sub->notify_status_condition();

        ::DDS::DataReaderListener_var listener =
          listener_for (::DDS::DATA_AVAILABLE_STATUS);

        ::DDS::DataReader_var dr = get_dr_obj_ref();
        if (!CORBA::is_nil(listener.in()))
        {
          ACE_GUARD(Reverse_Lock_t, unlock_guard, reverse_sample_lock_);

          listener->on_data_available(dr.in ());
          set_status_changed_flag(::DDS::DATA_AVAILABLE_STATUS, false);
          sub->set_status_changed_flag(::DDS::DATA_ON_READERS_STATUS, false);
        }
        else
        {
          notify_status_condition();
        }
      }
#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    }
#endif
  }
  else
  {
    instance_ptr = this->get_handle_instance (handle);
    instance_ptr->instance_state_.lively(header.publication_id_);
    ACE_DES_FREE (instance_data,
                  data_allocator_->free,
                  Calculator_divisionReply );
  }
}

void
Calculator_divisionReplyDataReaderImpl::dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this dispose message does not contain any valid data.
  // What it needs here is the key value to identify the instance to dispose.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the dispose event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

void
Calculator_divisionReplyDataReaderImpl::unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                                   OpenDDS::DCPS::SubscriptionInstance*& instance)
{
  //!!! caller should already have the sample_lock_

  // The data sample in this unregister message does not contain any valid data.
  // What it needs here is the key value to identify the instance to unregister.
  // The demarshal push this "sample" to received sample list so the user
  // can be notified the unregister event.
  bool just_registered = false;
  bool filtered = false;
  OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
  if (sample.header_.key_fields_only_) {
    marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
  }
  this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::auto_return_loan(void* seq)
{
  ::Calculator_divisionReplySeq& received_data =
    *static_cast< ::Calculator_divisionReplySeq*> (seq);

  if (!received_data.release())
  {
    // this->release_loan(received_data);
    received_data.length(0);
  }
  return ::DDS::RETCODE_OK;
}

::DDS::ReturnCode_t
Calculator_divisionReplyDataReaderImpl::check_inputs (
    const char* method_name,
    ::Calculator_divisionReplySeq & received_data,
    ::DDS::SampleInfoSeq & info_seq,
    ::CORBA::Long max_samples
  )
{
  ::Calculator_divisionReplySeq::PrivateMemberAccess received_data_p (received_data);

  // ---- start of preconditions common to read and take -----
  // SPEC ref v1.2 7.1.2.5.3.8 #1
  // NOTE: We can't check maximum() or release() here since those are
  //       implementation details of the sequences.  In general, the
  //       info_seq will have release() == true and maximum() == 0.
  //       If we're in zero-copy mode, the received_data will have
  //       release() == false and maximum() == 0.  If it's not
  //       zero-copy then received_data will have release == true()
  //       and maximum() == anything.
  if (received_data.length() != info_seq.length())
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
               ACE_TEXT("sequences do not match.\n"),
               method_name ));
    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  //SPEC ref v1.2 7.1.2.5.3.8 #4
  if ((received_data.maximum() > 0) && (received_data.release() == false))
  {
    ACE_DEBUG((LM_DEBUG,
               ACE_TEXT("(%P|%t) Calculator_divisionReplyDataReaderImpl::%C ")
               ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
               ACE_TEXT("maximum %d and owns %d\n"),
               method_name,
               received_data.maximum(),
               received_data.release() ));

    return ::DDS::RETCODE_PRECONDITION_NOT_MET;
  }

  if (received_data.maximum() == 0)
  {
    // not in SPEC but needed.
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      max_samples =
        static_cast< ::CORBA::Long> (received_data_p.max_slots());
    }
  }
  else
  {
    if (max_samples == ::DDS::LENGTH_UNLIMITED)
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5a
      max_samples = received_data.maximum();
    }
    else if (
      max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
    {
      //SPEC ref v1.2 7.1.2.5.3.8 #5c
      ACE_DEBUG((LM_DEBUG,
                 ACE_TEXT("(%P|%t) Calculator_divisionReplyDataReaderImpl::%C ")
                 ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
                 method_name,
                 max_samples,
                 received_data.maximum()));
      return ::DDS::RETCODE_PRECONDITION_NOT_MET;
    }
    //else
    //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
  }

  // The spec does not say what to do in this case but it appears to be a good thing.
  // Note: max_slots is the greater of the sequence's maximum and init_size.
  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
  {
    max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
  }
  //---- end of preconditions common to read and take -----

  return ::DDS::RETCODE_OK;
}

void
Calculator_divisionReplyDataReaderImpl::purge_data(
    OpenDDS::DCPS::SubscriptionInstance* instance)
{
  instance->instance_state_.cancel_release();

  while (instance->rcvd_samples_.size_ > 0)
  {
    OpenDDS::DCPS::ReceivedDataElement* head =
      instance->rcvd_samples_.remove_head();
    dec_ref_data_element(head);
  }

  delete instance;
}

void
Calculator_divisionReplyDataReaderImpl::release_instance_i (::DDS::InstanceHandle_t handle)
{
  InstanceMap::iterator const the_end = instance_map_.end ();
  InstanceMap::iterator it = instance_map_.begin ();
  while (it != the_end)
  {
    if (it->second == handle)
    {
      InstanceMap::iterator curIt = it;
      ++ it;
      instance_map_.erase (curIt);
    }
    else
      ++ it;
  }
}

void
Calculator_divisionReplyDataReaderImpl::delete_instance_map (void* map)
{
  InstanceMap* instances = reinterpret_cast <InstanceMap* > (map);
  delete instances;
}


#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
struct MetaStructImpl<Calculator_divisionReply> : MetaStruct {
  typedef Calculator_divisionReply T;

  void* allocate() const { return new T; }

  void deallocate(void* stru) const { delete static_cast<T*>(stru); }

  size_t numDcpsKeys() const { return 0; }

  Value getValue(const void* stru, const char* field) const
  {
    const Calculator_divisionReply& typed = *static_cast<const Calculator_divisionReply*>(stru);
    if (std::strncmp(field, "header.", 7) == 0) {
      return getMetaStruct<ReplyHeader>().getValue(&typed.header, field + 7);
    }
    if (std::strcmp(field, "division_ret") == 0) {
      return typed.division_ret;
    }
    ACE_UNUSED_ARG(typed);
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionReply)");
  }

  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
  {
    ACE_UNUSED_ARG(next);
    if (std::strncmp(field, "header.", 7) == 0) {
      return make_struct_cmp(&T::header, getMetaStruct<ReplyHeader>().create_qc_comparator(field + 7, 0), next);
    }
    if (std::strcmp(field, "division_ret") == 0) {
      return make_field_cmp(&T::division_ret, next);
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionReply)");
  }

  const char** getFieldNames() const
  {
    static const char* names[] = {"header", "division_ret", 0};
    return names;
  }

  const void* getRawField(const void* stru, const char* field) const
  {
    if (std::strcmp(field, "header") == 0) {
      return &static_cast<const T*>(stru)->header;
    }
    if (std::strcmp(field, "division_ret") == 0) {
      return &static_cast<const T*>(stru)->division_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionReply)");
  }

  void assign(void* lhs, const char* field, const void* rhs,
    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    ACE_UNUSED_ARG(rhsFieldSpec);
    ACE_UNUSED_ARG(rhsMeta);
    if (std::strcmp(field, "header") == 0) {
      static_cast<T*>(lhs)->header = *static_cast<const ReplyHeader*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    if (std::strcmp(field, "division_ret") == 0) {
      static_cast<T*>(lhs)->division_ret = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
      return;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionReply)");
  }

  bool compare(const void* lhs, const void* rhs, const char* field) const
  {
    ACE_UNUSED_ARG(lhs);
    ACE_UNUSED_ARG(field);
    ACE_UNUSED_ARG(rhs);
    if (std::strcmp(field, "division_ret") == 0) {
      return static_cast<const T*>(lhs)->division_ret == static_cast<const T*>(rhs)->division_ret;
    }
    throw std::runtime_error("Field " + std::string(field) + " not found or its type is not supported (in Struct Calculator_divisionReply)");
  }
};

template<>
const MetaStruct& getMetaStruct<Calculator_divisionReply>()
{
  static MetaStructImpl<Calculator_divisionReply> msi;
  return msi;
}

}  }

#endif

/* End STRUCT: Calculator_divisionReply */
