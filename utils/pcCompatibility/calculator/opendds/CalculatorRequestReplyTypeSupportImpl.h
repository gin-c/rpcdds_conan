/* -*- C++ -*- */
/* Generated by opendds_idl.exe version 3.3 (ACE version 5.6a_p13) running on input file CalculatorRequestReply.idl*/
#ifndef OPENDDS_IDL_GENERATED_CALCULATORREQUESTREPLYTYPESUPPORTIMPL_H_VSLOUM
#define OPENDDS_IDL_GENERATED_CALCULATORREQUESTREPLYTYPESUPPORTIMPL_H_VSLOUM
#include "dds/DCPS/Definitions.h"
#include "CalculatorRequestReplyC.h"
#include "CalculatorC.h"
#include "CalculatorRequestReplyTypeSupportC.h"
#include "MessageHeaderC.h"
#include "dds/DCPS/DataBlockLockPool.h"
#include "dds/DCPS/DataReaderImpl.h"
#include "dds/DCPS/DataWriterImpl.h"
#include "dds/DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/SubscriptionInstance.h"
#include "dds/DCPS/TypeSupportImpl.h"


/* Begin STRUCT: Calculator_additionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_additionRequest& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_additionRequest& stru);

bool operator>>(Serializer& strm, Calculator_additionRequest& stru);

bool gen_is_bounded_size(const Calculator_additionRequest&);

size_t gen_max_marshaled_size(const Calculator_additionRequest& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_additionRequest>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_additionRequest> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_additionRequest> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_additionRequest> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_additionRequest> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_additionRequest&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_additionRequest_KeyLessThan {
  bool operator()(const Calculator_additionRequest& v1, const Calculator_additionRequest& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_additionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_additionRequestTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionRequestTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_additionRequestTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_additionRequestTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_additionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_additionRequestDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionRequestDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_additionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_additionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_additionRequestDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_additionRequestDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_additionRequest & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_additionRequest & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_additionRequest & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_additionRequest & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_additionRequest & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_additionRequest & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_additionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_additionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_additionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_additionRequest & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_additionRequest& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_additionRequest& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_additionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_additionRequestDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionRequestDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_additionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_additionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_additionRequest, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_additionRequestDataReader Interface;

  //Constructor
  Calculator_additionRequestDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_additionRequestDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_additionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_additionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_additionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_additionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_additionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_additionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_additionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_additionRequest & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_additionRequestSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_additionRequest& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_additionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_additionRequest *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_additionRequestSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
const MetaStruct& getMetaStruct<Calculator_additionRequest>();
}  }

#endif

/* End STRUCT: Calculator_additionRequest */


/* Begin STRUCT: Calculator_additionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_additionReply& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_additionReply& stru);

bool operator>>(Serializer& strm, Calculator_additionReply& stru);

bool gen_is_bounded_size(const Calculator_additionReply&);

size_t gen_max_marshaled_size(const Calculator_additionReply& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_additionReply>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_additionReply> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_additionReply> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_additionReply> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_additionReply> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_additionReply&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_additionReply_KeyLessThan {
  bool operator()(const Calculator_additionReply& v1, const Calculator_additionReply& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_additionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_additionReplyTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionReplyTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_additionReplyTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_additionReplyTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_additionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_additionReplyDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionReplyDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_additionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_additionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_additionReplyDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_additionReplyDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_additionReply & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_additionReply & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_additionReply & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_additionReply & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_additionReply & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_additionReply & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_additionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_additionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_additionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_additionReply & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_additionReply& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_additionReply& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_additionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_additionReplyDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_additionReplyDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_additionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_additionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_additionReply, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_additionReplyDataReader Interface;

  //Constructor
  Calculator_additionReplyDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_additionReplyDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_additionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_additionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_additionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_additionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_additionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_additionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_additionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_additionReply & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_additionReplySeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_additionReply& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_additionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_additionReply *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_additionReplySeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_additionReply>();
}  }

#endif

/* End STRUCT: Calculator_additionReply */


/* Begin STRUCT: Calculator_substractionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_substractionRequest& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_substractionRequest& stru);

bool operator>>(Serializer& strm, Calculator_substractionRequest& stru);

bool gen_is_bounded_size(const Calculator_substractionRequest&);

size_t gen_max_marshaled_size(const Calculator_substractionRequest& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_substractionRequest>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_substractionRequest> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_substractionRequest> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_substractionRequest> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_substractionRequest> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_substractionRequest&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_substractionRequest_KeyLessThan {
  bool operator()(const Calculator_substractionRequest& v1, const Calculator_substractionRequest& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_substractionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_substractionRequestTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionRequestTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_substractionRequestTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_substractionRequestTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_substractionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_substractionRequestDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionRequestDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_substractionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_substractionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_substractionRequestDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_substractionRequestDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_substractionRequest & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_substractionRequest & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_substractionRequest & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_substractionRequest & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_substractionRequest & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_substractionRequest & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_substractionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_substractionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_substractionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_substractionRequest & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_substractionRequest& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_substractionRequest& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_substractionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_substractionRequestDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionRequestDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_substractionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_substractionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_substractionRequest, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_substractionRequestDataReader Interface;

  //Constructor
  Calculator_substractionRequestDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_substractionRequestDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_substractionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_substractionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_substractionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_substractionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_substractionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_substractionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_substractionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_substractionRequest & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_substractionRequestSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_substractionRequest& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_substractionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_substractionRequest *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_substractionRequestSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_substractionRequest>();
}  }

#endif

/* End STRUCT: Calculator_substractionRequest */


/* Begin STRUCT: Calculator_substractionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_substractionReply& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_substractionReply& stru);

bool operator>>(Serializer& strm, Calculator_substractionReply& stru);

bool gen_is_bounded_size(const Calculator_substractionReply&);

size_t gen_max_marshaled_size(const Calculator_substractionReply& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_substractionReply>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_substractionReply> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_substractionReply> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_substractionReply> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_substractionReply> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_substractionReply&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_substractionReply_KeyLessThan {
  bool operator()(const Calculator_substractionReply& v1, const Calculator_substractionReply& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_substractionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_substractionReplyTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionReplyTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_substractionReplyTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_substractionReplyTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_substractionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_substractionReplyDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionReplyDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_substractionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_substractionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_substractionReplyDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_substractionReplyDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_substractionReply & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_substractionReply & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_substractionReply & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_substractionReply & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_substractionReply & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_substractionReply & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_substractionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_substractionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_substractionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_substractionReply & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_substractionReply& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_substractionReply& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_substractionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_substractionReplyDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_substractionReplyDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_substractionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_substractionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_substractionReply, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_substractionReplyDataReader Interface;

  //Constructor
  Calculator_substractionReplyDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_substractionReplyDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_substractionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_substractionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_substractionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_substractionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_substractionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_substractionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_substractionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_substractionReply & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_substractionReplySeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_substractionReply& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_substractionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_substractionReply *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_substractionReplySeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_substractionReply>();
}  }

#endif

/* End STRUCT: Calculator_substractionReply */


/* Begin STRUCT: Calculator_multiplicationRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_multiplicationRequest& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_multiplicationRequest& stru);

bool operator>>(Serializer& strm, Calculator_multiplicationRequest& stru);

bool gen_is_bounded_size(const Calculator_multiplicationRequest&);

size_t gen_max_marshaled_size(const Calculator_multiplicationRequest& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_multiplicationRequest>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_multiplicationRequest> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_multiplicationRequest> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_multiplicationRequest> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_multiplicationRequest> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_multiplicationRequest&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_multiplicationRequest_KeyLessThan {
  bool operator()(const Calculator_multiplicationRequest& v1, const Calculator_multiplicationRequest& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_multiplicationRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_multiplicationRequestTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationRequestTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_multiplicationRequestTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_multiplicationRequestTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_multiplicationRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_multiplicationRequestDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationRequestDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_multiplicationRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_multiplicationRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_multiplicationRequestDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_multiplicationRequestDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_multiplicationRequest & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_multiplicationRequest & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_multiplicationRequest & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_multiplicationRequest & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_multiplicationRequest & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_multiplicationRequest & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_multiplicationRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_multiplicationRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_multiplicationRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_multiplicationRequest & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_multiplicationRequest& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_multiplicationRequest& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_multiplicationRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_multiplicationRequestDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationRequestDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_multiplicationRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_multiplicationRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_multiplicationRequest, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_multiplicationRequestDataReader Interface;

  //Constructor
  Calculator_multiplicationRequestDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_multiplicationRequestDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_multiplicationRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_multiplicationRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_multiplicationRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_multiplicationRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_multiplicationRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_multiplicationRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_multiplicationRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_multiplicationRequest & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_multiplicationRequestSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_multiplicationRequest& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_multiplicationRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_multiplicationRequest *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_multiplicationRequestSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_multiplicationRequest>();
}  }

#endif

/* End STRUCT: Calculator_multiplicationRequest */


/* Begin STRUCT: Calculator_multiplicationReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_multiplicationReply& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_multiplicationReply& stru);

bool operator>>(Serializer& strm, Calculator_multiplicationReply& stru);

bool gen_is_bounded_size(const Calculator_multiplicationReply&);

size_t gen_max_marshaled_size(const Calculator_multiplicationReply& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_multiplicationReply>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_multiplicationReply> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_multiplicationReply> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_multiplicationReply> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_multiplicationReply> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_multiplicationReply&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_multiplicationReply_KeyLessThan {
  bool operator()(const Calculator_multiplicationReply& v1, const Calculator_multiplicationReply& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_multiplicationReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_multiplicationReplyTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationReplyTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_multiplicationReplyTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_multiplicationReplyTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_multiplicationReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_multiplicationReplyDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationReplyDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_multiplicationReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_multiplicationReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_multiplicationReplyDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_multiplicationReplyDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_multiplicationReply & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_multiplicationReply & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_multiplicationReply & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_multiplicationReply & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_multiplicationReply & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_multiplicationReply & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_multiplicationReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_multiplicationReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_multiplicationReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_multiplicationReply & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_multiplicationReply& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_multiplicationReply& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_multiplicationReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_multiplicationReplyDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_multiplicationReplyDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_multiplicationReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_multiplicationReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_multiplicationReply, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_multiplicationReplyDataReader Interface;

  //Constructor
  Calculator_multiplicationReplyDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_multiplicationReplyDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_multiplicationReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_multiplicationReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_multiplicationReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_multiplicationReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_multiplicationReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_multiplicationReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_multiplicationReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_multiplicationReply & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_multiplicationReplySeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_multiplicationReply& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_multiplicationReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_multiplicationReply *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_multiplicationReplySeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_multiplicationReply>();
}  }

#endif

/* End STRUCT: Calculator_multiplicationReply */


/* Begin STRUCT: Calculator_divisionRequest */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_divisionRequest& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_divisionRequest& stru);

bool operator>>(Serializer& strm, Calculator_divisionRequest& stru);

bool gen_is_bounded_size(const Calculator_divisionRequest&);

size_t gen_max_marshaled_size(const Calculator_divisionRequest& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_divisionRequest>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_divisionRequest> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_divisionRequest> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_divisionRequest> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_divisionRequest> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_divisionRequest&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_divisionRequest_KeyLessThan {
  bool operator()(const Calculator_divisionRequest& v1, const Calculator_divisionRequest& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_divisionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_divisionRequestTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionRequestTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_divisionRequestTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_divisionRequestTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_divisionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_divisionRequestDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionRequestDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_divisionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_divisionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_divisionRequestDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_divisionRequestDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_divisionRequest & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_divisionRequest & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_divisionRequest & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_divisionRequest & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_divisionRequest & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_divisionRequest & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_divisionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_divisionRequest & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_divisionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_divisionRequest & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_divisionRequest& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_divisionRequest& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_divisionRequest data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_divisionRequestDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionRequestDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_divisionRequest, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_divisionRequest_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_divisionRequest, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_divisionRequestDataReader Interface;

  //Constructor
  Calculator_divisionRequestDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_divisionRequestDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_divisionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_divisionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_divisionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_divisionRequest & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_divisionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_divisionRequestSeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_divisionRequest & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_divisionRequest & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_divisionRequestSeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_divisionRequest& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_divisionRequestSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_divisionRequest *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_divisionRequestSeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_divisionRequest>();
}  }

#endif

/* End STRUCT: Calculator_divisionRequest */


/* Begin STRUCT: Calculator_divisionReply */

namespace OpenDDS { namespace DCPS {

void gen_find_size(const Calculator_divisionReply& stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, const Calculator_divisionReply& stru);

bool operator>>(Serializer& strm, Calculator_divisionReply& stru);

bool gen_is_bounded_size(const Calculator_divisionReply&);

size_t gen_max_marshaled_size(const Calculator_divisionReply& stru, bool align);

bool gen_is_bounded_size(KeyOnly<const Calculator_divisionReply>);

size_t gen_max_marshaled_size(KeyOnly<const Calculator_divisionReply> stru, bool align);

void gen_find_size(KeyOnly<const Calculator_divisionReply> stru, size_t& size, size_t& padding);

bool operator<<(Serializer& strm, KeyOnly<const Calculator_divisionReply> stru);

bool operator>>(Serializer& strm, KeyOnly<Calculator_divisionReply> stru);

}  }

namespace OpenDDS { namespace DCPS {

bool gen_has_key(const Calculator_divisionReply&);

}  }

namespace OpenDDSGenerated {
// This structure supports use of std::map with a key
// defined by one or more #pragma DCPS_DATA_KEY lines.
struct  Calculator_divisionReply_KeyLessThan {
  bool operator()(const Calculator_divisionReply& v1, const Calculator_divisionReply& v2) const
  {
#ifndef OPENDDS_GCC33
    using ::operator<; // TAO::String_Manager's operator< is in global NS
#endif
    ACE_UNUSED_ARG(v1);
    ACE_UNUSED_ARG(v2);
    // with no DCPS_DATA_KEYs, return false
    // to allow use of map with just one entry
    return false;
  }
};
}
/** Servant for TypeSuport interface of Calculator_divisionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_divisionReplyTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionReplyTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:

  //Constructor
  Calculator_divisionReplyTypeSupportImpl ();

  //Destructor
  virtual ~Calculator_divisionReplyTypeSupportImpl ();

  virtual
  ::DDS::ReturnCode_t register_type (::DDS::DomainParticipant_ptr participant,
                                     const char * type_name);

  virtual char * get_type_name ();

  virtual ::DDS::DataWriter_ptr create_datawriter ();

  virtual ::DDS::DataReader_ptr create_datareader ();

#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif

  virtual bool has_dcps_key();

private:
  CORBA::String_var type_name_;
};

/** Servant for DataWriter interface of the Calculator_divisionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  Calculator_divisionReplyDataWriterImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionReplyDataWriter>,
    public virtual OpenDDS::DCPS::DataWriterImpl
{
public:

  typedef std::map<Calculator_divisionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_divisionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  Calculator_divisionReplyDataWriterImpl (void);

  //Destructor
  virtual ~Calculator_divisionReplyDataWriterImpl (void);

  virtual ::DDS::InstanceHandle_t register_instance (
      const ::Calculator_divisionReply & instance);

  virtual ::DDS::InstanceHandle_t register_instance_w_timestamp (
      const ::Calculator_divisionReply & instance,
      const ::DDS::Time_t & timestamp);

  virtual ::DDS::ReturnCode_t unregister_instance (
      const ::Calculator_divisionReply & instance,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::ReturnCode_t unregister_instance_w_timestamp (
      const ::Calculator_divisionReply & instance,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & timestamp);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write (
      const ::Calculator_divisionReply & instance_data,
      ::DDS::InstanceHandle_t handle);

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual ::DDS::ReturnCode_t write_w_timestamp (
      const ::Calculator_divisionReply & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t dispose (
      const ::Calculator_divisionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle);

  virtual ::DDS::ReturnCode_t dispose_w_timestamp (
      const ::Calculator_divisionReply & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_divisionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_divisionReply & instance_data);

  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        OpenDDS::DCPS::TopicImpl*              topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        const ::DDS::StatusMask &              mask,
        OpenDDS::DCPS::DomainParticipantImpl*  participant_servant,
        OpenDDS::DCPS::PublisherImpl*          publisher_servant,
        ::DDS::DataWriter_ptr                  dw_objref
      );

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  };

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @param marshaling_type Enumerated type specifying whether to marshal
   *        just the keys or the entire message.
   * @return returns the serialized data.
   */
  ACE_Message_Block* dds_marshal(
    const ::Calculator_divisionReply& instance_data,
    OpenDDS::DCPS::MarshalingType marshaling_type);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    ::DDS::InstanceHandle_t& handle,
    const ::Calculator_divisionReply& instance_data,
    const ::DDS::Time_t & source_timestamp);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   size_t       key_marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::OpenDDS::DCPS::MessageBlockAllocator* mb_allocator_;
   ::OpenDDS::DCPS::DataBlockAllocator*    db_allocator_;
};

/** Servant for DataReader interface of Calculator_divisionReply data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  Calculator_divisionReplyDataReaderImpl
  : public virtual OpenDDS::DCPS::LocalObject<Calculator_divisionReplyDataReader>,
    public virtual OpenDDS::DCPS::DataReaderImpl
{
public:

  typedef std::map<Calculator_divisionReply, ::DDS::InstanceHandle_t,
      OpenDDSGenerated::Calculator_divisionReply_KeyLessThan> InstanceMap;
  typedef ::OpenDDS::DCPS::Cached_Allocator_With_Overflow<Calculator_divisionReply, ACE_Null_Mutex>  DataAllocator;
  typedef Calculator_divisionReplyDataReader Interface;

  //Constructor
  Calculator_divisionReplyDataReaderImpl (void);

  //Destructor
  virtual ~Calculator_divisionReplyDataReaderImpl (void);

  virtual ::DDS::ReturnCode_t delete_contained_entities ();

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific ();

  virtual ::DDS::ReturnCode_t read (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_w_condition (
      ::Calculator_divisionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_w_condition (
      ::Calculator_divisionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t read_next_sample (
      ::Calculator_divisionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t take_next_sample (
      ::Calculator_divisionReply & received_data,
      ::DDS::SampleInfo & sample_info);

  virtual ::DDS::ReturnCode_t read_instance (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_instance (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t take_next_instance (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states);

  virtual ::DDS::ReturnCode_t read_next_instance_w_condition (
      ::Calculator_divisionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t take_next_instance_w_condition (
      ::Calculator_divisionReplySeq & data_values,
      ::DDS::SampleInfoSeq & sample_infos,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t previous_handle,
      ::DDS::ReadCondition_ptr a_condition);

  virtual ::DDS::ReturnCode_t return_loan (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq);

  virtual ::DDS::ReturnCode_t get_key_value (
      ::Calculator_divisionReply & key_holder,
      ::DDS::InstanceHandle_t handle);

  virtual ::DDS::InstanceHandle_t lookup_instance (
      const ::Calculator_divisionReply & instance_data);

  virtual ::DDS::ReturnCode_t auto_return_loan(void* seq);

  void release_loan (::Calculator_divisionReplySeq & received_data);

  void dec_ref_data_element(::OpenDDS::DCPS::ReceivedDataElement* r);

  virtual void delete_instance_map (void* map);

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  bool contains_sample_filtered(::DDS::SampleStateMask sample_states,
                                ::DDS::ViewStateMask view_states,
                                ::DDS::InstanceStateMask instance_states,
                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
                                const ::DDS::StringSeq& params);

  ::DDS::ReturnCode_t read_generic(
    OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::InstanceHandle_t lookup_instance_generic(const void* data);

  ::DDS::ReturnCode_t read_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

  ::DDS::ReturnCode_t read_next_instance_generic(void*& data,
    ::DDS::SampleInfo& info, ::DDS::InstanceHandle_t previous_instance,
    ::DDS::SampleStateMask sample_states, ::DDS::ViewStateMask view_states,
    ::DDS::InstanceStateMask instance_states);

#endif

  ::DDS::InstanceHandle_t store_synthetic_data(const Calculator_divisionReply& sample,
                                             ::DDS::ViewStateKind view);

  void set_instance_state(::DDS::InstanceHandle_t instance,
                          ::DDS::InstanceStateKind state);

  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance);

 protected:

    virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
                               OpenDDS::DCPS::SubscriptionInstance*& instance,
                               bool & just_registered,
                               bool & filtered,
                               OpenDDS::DCPS::MarshalingType marshaling_type);

    virtual void dispose(const OpenDDS::DCPS::ReceivedDataSample& sample,
                         OpenDDS::DCPS::SubscriptionInstance*& instance);

    virtual void unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
                            OpenDDS::DCPS::SubscriptionInstance*& instance);

    //virtual OpenDDS::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

    virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance* instance);

    virtual void release_instance_i (::DDS::InstanceHandle_t handle);

  private:

    ::DDS::ReturnCode_t read_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_instance_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_instance_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t read_next_instance_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    ::DDS::ReturnCode_t take_next_instance_i (
      ::Calculator_divisionReplySeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states,
#ifndef OPENDDS_NO_QUERY_CONDITION
      ::DDS::QueryCondition_ptr a_condition);
#else
      int ignored);
#endif

    void store_instance_data(
         ::Calculator_divisionReply *instance_data,
         const OpenDDS::DCPS::DataSampleHeader& header,
         OpenDDS::DCPS::SubscriptionInstance*& instance_ptr,
         bool & just_registered,
         bool & filtered
         );

    /// common input read* & take* input processing and precondition checks
    ::DDS::ReturnCode_t check_inputs (
        const char* method_name,
        ::Calculator_divisionReplySeq & received_data,
        ::DDS::SampleInfoSeq & info_seq,
        ::CORBA::Long max_samples
        );

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<Calculator_divisionReply>();
}  }

#endif

/* End STRUCT: Calculator_divisionReply */
#endif /* OPENDDS_IDL_GENERATED_CALCULATORREQUESTREPLYTYPESUPPORTIMPL_H_VSLOUM */
