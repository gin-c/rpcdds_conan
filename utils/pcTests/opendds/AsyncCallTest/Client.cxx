/*************************************************************************
 * Copyright (c) 2012 eProsima. All rights reserved.
 *
 * This copy of RPCDDS is licensed to you under the terms described in the
 * RPCDDS_LICENSE file included in this distribution.
 *
 *************************************************************************
 * 
 * @file Client.cxx
 * This source file shows a simple example of how to create a proxy for interface AsyncCallTest.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "AsyncCallTestProxy.h"
#include "AsyncCallTestRequestReplyTypeSupportImpl.h"
#include "exceptions/Exceptions.h"

class GetLongHandler : public AsyncCallTest_getLongCallbackHandler
{
    public:

        GetLongHandler() : m_state(0){}

        void getLong(/*inout*/ CORBA::Long lo2, /*out*/ CORBA::Long lo3, /*out*/ CORBA::Long getLong_ret)
        {
            if(lo3 != 2 ||
                    getLong_ret != 1 ||
                    lo2 != 3)
            {
                printf("TEST FAILED<getLong>: Wrong values\n");
                m_state = 2;
                return;
            }

            m_state = 1;
        }

        void on_exception(const eProsima::RPCDDS::Exception &ex)
        {
            printf("TEST FAILED<on_exception>: %s\n", ex.what());
            m_state = 2;
        }

        int getState() const
        {
            return m_state;
        }

    private:

        int m_state;
};

class GetBooleanHandler : public AsyncCallTest_getBooleanCallbackHandler
{
    public:
        GetBooleanHandler() : m_state(0){}

        void getBoolean(/*inout*/ CORBA::Boolean bo2, /*out*/ CORBA::Boolean bo3, /*out*/ CORBA::Boolean getBoolean_ret)
        {
            if(bo3 != false ||
                    getBoolean_ret != true ||
                    bo2 != true)
            {
                printf("TEST FAILED<getBoolean>: Wrong values\n");
                m_state = 2;
                return;
            }

            m_state = 1;
        }

        void on_exception(const eProsima::RPCDDS::Exception &ex)
        {
            printf("TEST FAILED<on_exception>: %s\n", ex.what());
            m_state = 2;
        }

        int getState() const
        {
            return m_state;
        }

    private:

        int m_state;
};

class GetStringHandler : public AsyncCallTest_getStringCallbackHandler
{
    public:

        GetStringHandler() : m_state(0){}

        void getString(/*inout*/ char* s2, /*out*/ char* s3, /*out*/ char* getString_ret)
        {
            if(strcmp(s3, "PRUEBA2") != 0 ||
                    strcmp(getString_ret, "PRUEBA") != 0 ||
                    strcmp(s2, "PRUEBAPRUEBA2") != 0)
            {
                printf("TEST FAILED<getString>: Wrong values\n");
                m_state = 2;
                return;
            }       

            m_state = 1;
        }
   
        void on_exception(const eProsima::RPCDDS::Exception &ex)
        {
            printf("TEST FAILED<on_exception>: %s\n", ex.what());
            m_state = 2;
        }

        int getState() const
        {
            return m_state;
        }

    private:

        int m_state;
};

class DuplicateHandler : public AsyncCallTest_duplicateCallbackHandler
{
    public:
        DuplicateHandler() : m_state(0){}

        void duplicate(/*out*/ const Structure& duplicate_ret)
        {
            if(duplicate_ret.dato != 10 ||
                    strcmp(duplicate_ret.message, "HOLA") != 0)
            {
                printf("TEST FAILED<duplicate>: Wrong values\n");
                m_state = 2;
                return;
            }

            m_state = 1;
        }
   
        void on_exception(const eProsima::RPCDDS::Exception &ex)
        {
            printf("TEST FAILED<on_exception>: %s\n", ex.what());
            m_state = 2;
        }

        int getState() const
        {
            return m_state;
        }

    private:

        int m_state;
};

int main(int argc, char **argv)
{
    AsyncCallTestProxy *proxy = NULL;
    
    // Creation of the proxy for interface "AsyncCallTest".
    try
    {
        proxy = new AsyncCallTestProxy("AsyncCallTestService", 0, 30000L);
    }
    catch(eProsima::RPCDDS::InitializeException &ex)
    {
        std::cout << ex.what() << std::endl;
        return -1;
    }

    // Create and initialize parameters.
    CORBA::Long  lo1 = 1;
    CORBA::Long  lo2 = 2;
    GetLongHandler getLong_handler;

    // Call to remote procedure "getLong".
    try
    {
        proxy->getLong_async(getLong_handler, lo1, lo2);

        while(getLong_handler.getState() == 0)
        {
#if defined(RTI_WIN32)
            Sleep(1000);
#elif defined(RTI_LINUX)
            sleep(1);
#endif
        }

        if(getLong_handler.getState() == 2)
            _exit(-1);
    }
    catch(eProsima::RPCDDS::Exception &ex)
    {
        printf("TEST FAILED<getLong_async>: %s\n", ex.what());
        _exit(-1);
    }

    CORBA::Boolean  bo1 = true;       
    CORBA::Boolean  bo2 = false;       
    GetBooleanHandler getBoolean_handler;

    try
    {
        proxy->getBoolean_async(getBoolean_handler, bo1, bo2);

        while(getBoolean_handler.getState() == 0)
        {
#if defined(RTI_WIN32)
            Sleep(1000);
#elif defined(RTI_LINUX)
            sleep(1);
#endif
        }

        if(getBoolean_handler.getState() == 2)
            _exit(-1);
    }
    catch(eProsima::RPCDDS::Exception &ex)
    {
        printf("TEST FAILED<getBoolean_async>: %s\n", ex.what());
        _exit(-1);
    }

    char*  s1  = strdup("PRUEBA");       
    char*  s2  = strdup("PRUEBA2");       
    GetStringHandler getString_handler;

    try
    {
        proxy->getString_async(getString_handler, s1, s2);

        while(getString_handler.getState() == 0)
        {
#if defined(RTI_WIN32)
            Sleep(1000);
#elif defined(RTI_LINUX)
            sleep(1);
#endif
        }

        if(getString_handler.getState() == 2)
            _exit(-1);
    }
    catch(eProsima::RPCDDS::Exception &ex)
    {
        printf("TEST FAILED<getString_async>: %s\n", ex.what());
        _exit(-1);
    }

    if(s1 != NULL) free(s1);    
    if(s2 != NULL) free(s2);    

    Structure ev;
    DuplicateHandler duplicate_handler;

    ev.dato = 10;
    ev.message = strdup("HOLA");

    try
    {
        proxy->duplicate_async(duplicate_handler, ev);

        while(duplicate_handler.getState() == 0)
        {
#if defined(RTI_WIN32)
            Sleep(1000);
#elif defined(RTI_LINUX)
            sleep(1);
#endif
        }

        if(duplicate_handler.getState() == 2)
            _exit(-1);
    }
    catch(eProsima::RPCDDS::Exception &ex)
    {
        printf("TEST FAILED<duplicate_async>: %s\n", ex.what());
        _exit(-1);
    }

	// Test the close of the proxy with pending asynchrnous tasks.
    CORBA::Long  clo1 = 1;       
    CORBA::Long  clo2 = 2;       
    GetLongHandler cgetLong_handler;
    CORBA::Boolean  cbo1 = true;       
    CORBA::Boolean  cbo2 = false;       
    GetBooleanHandler cgetBoolean_handler;
	char*  cs1  = strdup("PRUEBA");       
    char*  cs2  = strdup("PRUEBA2");       
    GetStringHandler cgetString_handler;  
    Structure cev;
    DuplicateHandler cduplicate_handler;

    cev.dato = 10;
    cev.message = strdup("HOLA");

    try
    {
        proxy->getLong_async(cgetLong_handler, clo1, clo2);
		proxy->getBoolean_async(cgetBoolean_handler, cbo1, cbo2);
		proxy->getString_async(cgetString_handler, cs1, cs2);
		proxy->duplicate_async(cduplicate_handler, cev);
    }
    catch(eProsima::RPCDDS::Exception &ex)
    {
        printf("TEST FAILED<closing>: %s\n", ex.what());
        _exit(-1);
    }

    if(cs1 != NULL) free(cs1);    
    if(cs2 != NULL) free(cs2);  

    printf("TEST SUCCESFULLY\n");
    
    delete(proxy);
   
    _exit(0);
    return 0;
}
