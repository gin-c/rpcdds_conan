/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastrpc_LICENSE file included in this fastrpc distribution.
 *
 *************************************************************************
 * 
 * @file LatencyClientExample.cxx
 * This source file shows a simple example of how to create a proxy for an interface.
 *
 * This file was generated by the tool fastrpcgen.
 */

#include "LatencyProxy.h"
#include "Latency.h"
#include "LatencyCDRProtocol.h"
#include "fastrpc/transports/TCPProxyTransport.h"
#include "fastrpc/exceptions/Exceptions.h"

#include <iostream>
#include <chrono>
#include <sstream>

using namespace eprosima::rpc;
using namespace ::exception;
using namespace ::transport;
using namespace ::protocol::fastcdr;
using namespace std;

void printResultTile()
{
	printf("Samples   ,     Bytes,  Time(us)\n");
	printf("----------,----------,----------\n");
}

void printResult(int samples,int bytes,double res )
{
	printf("%10d,%10d,%10.3f\n",samples, bytes,res);
}

int main(int argc, char **argv)
{
    LatencyProtocol *protocol = NULL;
    TCPProxyTransport *transport = NULL;
    LatencyProxy *proxy = NULL;

	int samples = 10000;
	int bytes = 0;
	string ip = "127.0.0.1";

	if(argc <= 4)
	{

		if(argc > 1) {
			std::istringstream iss1( argv[1] );
			if (!(iss1 >> samples))
			{
				cout << "Problem reading samples number, using default (10000) "<< endl;
				samples = 10000;
			}
		}

		if(argc > 2) {
			std::istringstream iss2( argv[2] );
			if (!(iss2 >> bytes))
			{
				cout << "Problem reading bytes number, using default (1024) "<< endl;
				bytes = 0;
			}
		}

		if(argc > 3) {
			ip = argv[3];
		}
	}
	else
	{
		cout << "usage: " << argv[0] << " [samples] [bytes] [server IP]"<<endl;
		return 0;
	}

	// Para calcular el tiempo
	typedef std::chrono::high_resolution_clock Clock;
	typedef std::chrono::microseconds microseconds;

	Clock::time_point m_t1;
	Clock::time_point m_t2;

	m_t1 = Clock::now();
	for(int i=0;i<1000;i++)
		m_t2 = Clock::now();
	double m_overhead = std::chrono::duration_cast<microseconds>(m_t2 - m_t1).count()/1001;
	//
    
    // Creation of the proxy for interface "Latency".
    try
    {
        protocol = new LatencyProtocol();
        transport = new TCPProxyTransport(ip + ":8080");
        proxy = new LatencyProxy(*transport, *protocol);
    }
    catch(InitializeException &ex)
    {
        std::cout << ex.what() << std::endl;
        return -1;
    }

	printResultTile();
    
	if(bytes == 0) {
		int bytessizes[] = {16,32,64,128,256,512,1024,2048,4096,8192};
		std::vector<int> v_bytes (bytessizes, bytessizes + sizeof(bytessizes) / sizeof(uint32_t) );
		for(std::vector<int>::iterator it = v_bytes.begin();it!=v_bytes.end();++it) {

			cadena payload = "";
			for(int i = 0; i < *it; ++i) {
				payload += "A";
			}


			m_t1 = Clock::now();
			int isam = 0;
			for(isam = 0; isam<samples; ++isam) {
			    // Call to remote procedure "latency".
			    try {
				proxy->latency(payload);
			    } catch(SystemException &ex) {
				std::cout << ex.what() << std::endl;
			    }
			}

			m_t2 = Clock::now();

			double result = -1;
			if(isam == samples) {
				result = (std::chrono::duration_cast<microseconds>(m_t2 - m_t1).count() - m_overhead) / samples;
			}
			printResult(samples, *it, result);
		}
	} else {

		cadena payload = "";
		for(int i = 0; i < bytes; ++i) {
			payload += "A";
		}

		m_t1 = Clock::now();
		int isam = 0;
		for(isam = 0; isam<samples; ++isam) {
		    // Call to remote procedure "latency".
		    try {
			proxy->latency(payload);
			} catch(SystemException &ex) {
			std::cout << ex.what() << std::endl;
		    }
		}
		m_t2 = Clock::now();

		double result = -1;
		if(isam == samples) {
			result = (std::chrono::duration_cast<microseconds>(m_t2 - m_t1).count() - m_overhead) / samples;
		}
		printResult(samples, bytes, result);
	}
         
    delete proxy;
    delete transport;
    delete protocol;
   
    return 0;
}


