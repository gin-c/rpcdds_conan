/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastrpc_LICENSE file included in this fastrpc distribution.
 *
 *************************************************************************
 * 
 * @file LatencyCDRProtocol.cxx
 * This source file contains the definition of the protocol used to create CDR messages.
 *
 * This file was generated by the tool fastrpcgen.
 */

#include "LatencyCDRProtocol.h"
#include "fastrpc/transports/ProxyTransport.h"
#include "fastrpc/transports/ServerTransport.h"
#include "fastrpc/exceptions/Exceptions.h"
#include "fastrpc/utils/Messages.h"

using namespace eprosima::rpc;
using namespace ::protocol::fastcdr;
using namespace ::transport;
using namespace ::exception;

LatencyProtocol::LatencyProtocol() : ::protocol::LatencyProtocol(),
    serializeBuffer(), scdr(serializeBuffer)
{
}

LatencyProtocol::~LatencyProtocol()
{
}

bool LatencyProtocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "RAW") == 0)
    {
    
        if(transport.getBehaviour() == SERVER_BEHAVIOUR)
        {
            // If this is a server transport, we set its callback
            eprosima::rpc::transport::ServerTransport &serverTransport = dynamic_cast<eprosima::rpc::transport::ServerTransport&>(transport);
            serverTransport.setCallback(&LatencyProtocol::worker);
        }
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

bool LatencyProtocol::activateInterface(const char* interfaceName)
{  
    return true;
}

size_t LatencyProtocol::worker(Protocol& protocol, void *&buffer, size_t &bufferLength, size_t &bufferSize, eprosima::rpc::transport::Endpoint *endpoint) 
{
    LatencyProtocol &_protocol = dynamic_cast<LatencyProtocol&>(protocol);
    size_t cdrLength = 0;
    
    if(bufferLength > 0 && endpoint != NULL)
    {
        if(((int32_t*&)buffer)[0] == 0x46434452)
        {
            cdrLength = ((uint32_t*&)buffer)[1] + 8;

            if(bufferLength < cdrLength)
            {
                if(bufferSize < cdrLength)
                {
                    buffer = realloc(buffer, cdrLength);
                    bufferSize = cdrLength;
                }

                size_t dataToRead = cdrLength - bufferLength;
                ServerTransport &serverTransport = dynamic_cast<ServerTransport&>(_protocol.getTransport());
                int retCode = serverTransport.receive(&((char*&)buffer)[bufferLength], bufferSize, dataToRead, endpoint);

                if(retCode >= 0)
                {
                    bufferLength += dataToRead;

                    if(bufferLength < cdrLength)
                    {
                        // TODO error
                        printf("ERROR No se ha leido todos los datos necesarios\n");
                        return 0;
                    }
                }
                else
                {
                    // TODO error
                    printf("ERROR Fallo leyendo\n");
                    return 0;
                }
            }

            eprosima::fastcdr::FastBuffer cdrBuffer((char*)buffer, bufferLength);
            eprosima::fastcdr::FastCdr dcdr(cdrBuffer);

            dcdr.jump(8);
            int32_t code = -2;
            dcdr.deserialize(code);

            if(code == 0)
            {
                std::string interface_name, operation_name;
                dcdr.deserialize(interface_name);
                dcdr.deserialize(operation_name);

                    if(interface_name.compare("Latency") == 0)
                    {
                        if(_protocol._Latency_impl != NULL)
                        {
                                if(operation_name.compare("latency") == 0)
                                {
                                    cadena  param = "";
                                    cadena  latency_ret = "";


                                    dcdr >> param;


                                    try
                                    {
                                        latency_ret = _protocol._Latency_impl->latency(param);
                                        
                                        eprosima::fastcdr::FastBuffer scdrBuffer;
                                        eprosima::fastcdr::FastCdr scdr(scdrBuffer);
                                        scdr.jump(8);
                                        scdr.serialize((int32_t)1);
                                        scdr.serialize("Latency");
                                        scdr.serialize("latency");

                                        
                                            if(latency_ret.length() <= 8192)
                                            scdr << latency_ret;
                                            else
                                                throw eprosima::rpc::exception::BadParamException(std::string("latency_ret field exceeds the maximum length"));
                                            
                                        
                                        char *buffer = scdrBuffer.getBuffer();
                                        ((int32_t*)buffer)[0] = 0x46434452;
                                        ((uint32_t*)buffer)[1] = (uint32_t)scdr.getSerializedDataLength() - 8;

                                        dynamic_cast<ServerTransport&>(_protocol.getTransport()).sendReply(buffer, scdr.getSerializedDataLength(), endpoint);
                                    }
                                    catch(const ServerInternalException &ex)
                                    {
                                        eprosima::fastcdr::FastBuffer scdrBuffer;
                                        eprosima::fastcdr::FastCdr scdr(scdrBuffer);
                                        scdr.jump(8);
                                        scdr.serialize((int32_t)-1);
                                        scdr.serialize(ex.what());

                                        char *buffer = scdrBuffer.getBuffer();
                                        ((int32_t*)buffer)[0] = 0x46434452;
                                        ((uint32_t*)buffer)[1] = (uint32_t)scdr.getSerializedDataLength() - 8;

                                        dynamic_cast<ServerTransport&>(_protocol.getTransport()).sendReply(buffer, scdr.getSerializedDataLength(), endpoint);
                                    }




                                }

                        }
                        else
                        {
                            // TODO Send system exception to client.
                        }
                    }

            }
            else
            {
                printf("ERROR: CDR message is not a request\n");
            }

            return cdrLength;
        }
        else
        {
            // TODO Print error.
        }
    }
    else
    {
        //TODO Print error.
    }

    return 0;
}


cadena LatencyProtocol::Latency_latency(/*in*/ const cadena& param)
{
    const char* const interface_name = "Latency";
    const char* const operation_name = "latency";
    // TODO In DDS the initialization is not necessary. But in CDR it is, for example a union with a char* (string) needs to be initialized to NULL.
    cadena  latency_ret = "";
    
    eprosima::rpc::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpc::transport::ProxyTransport&>(getTransport());
    
    scdr.jump(8);
    scdr.serialize((int32_t)0);
    scdr.serialize(interface_name);
    scdr.serialize(operation_name);
        if(param.length() <= 8192)
        scdr << param;
        else
            throw eprosima::rpc::exception::BadParamException(std::string("param field exceeds the maximum length"));
        
    
    char *buffer = serializeBuffer.getBuffer();
    ((int32_t*)buffer)[0] = 0x46434452;
    ((uint32_t*)buffer)[1] = (uint32_t)scdr.getSerializedDataLength() - 8;
    
    if(proxyTransport.connect())
    {
        // TODO Check if there is a problem.
        if(proxyTransport.send(buffer, scdr.getSerializedDataLength()))
        {
            scdr.reset();
            
            // TODO Cambiar
            size_t responseBufferSize = 8192, responseBufferUse = 0;
            char *response = (char*)calloc(responseBufferSize, sizeof(char));
            int retCode = proxyTransport.receive(response, responseBufferSize, responseBufferUse);
            
            if(retCode >= 0 && responseBufferUse >= 8)
            {
                if(((int32_t*)response)[0] == 0x46434452)
                {
                    size_t cdrLength = ((uint32_t*)response)[1] + 8;
                    
                    if(responseBufferUse < cdrLength)
                    {   
                        // A buffer more big is needed.             
                        if(responseBufferSize < cdrLength)
                        {
                            response = (char*)realloc(response, cdrLength);
                            responseBufferSize = cdrLength;
                        }
                        
                        size_t dataToRead = cdrLength - responseBufferUse;
                        retCode = proxyTransport.receive(&response[responseBufferUse], responseBufferSize, dataToRead);
                        responseBufferUse += dataToRead;
                    }
                    
                    if(retCode >= 0 && responseBufferUse >= cdrLength)
                    {
                        eprosima::fastcdr::FastBuffer cdrBuffer(response, responseBufferUse);
                        eprosima::fastcdr::FastCdr dcdr(cdrBuffer);
                        
                        dcdr.jump(8);
                        int32_t code = -2;
                        dcdr.deserialize(code);

                        if(code == 1)
                        {
                            std::string interface_name_r, operation_name_r;
                            dcdr.deserialize(interface_name_r);
                            dcdr.deserialize(operation_name_r);
                            
                            if(interface_name_r.compare(interface_name) == 0 &&
                                operation_name_r.compare(operation_name) == 0)
                            {
                                                                dcdr >> latency_ret;
                                                                
                            }
                            else
                            {
                                // TODO Return error
                                printf("ERROR: Bad reply, reply to other operation\n");
                            }
                        }
                        else if(code == -1)
                        {
                            std::string errormsg;
                            dcdr.deserialize(errormsg);
                            free(response);
                            throw ServerInternalException(errormsg);
                        }
                        else
                        {
                            printf("ERROR: CDR message is not a reply or error message\n");
                        }
                    }
                    else
                    {
                        // TODO error
                        printf("Error receiving the whole cdr message\n");
                    }
                }
                else
                {
                    // TODO Return error.
                    printf("ERROR: not received a cdr message\n");
                }
            }
            else
            {
                // TODO print error.
                printf("Error receiving the cdr message\n");
            }
            
            free(response);
        }
        else
        {
            scdr.reset();
            throw ClientInternalException("Error in client side");
        }
	if(!proxyTransport.connect())
	{
		//printf("NEW: Error disconnecting socket\n");
	} else {
		//printf("NEW: Disconnection successful\n");
	}
    }
    else
    {
        scdr.reset();
        throw ServerNotFoundException("Cannot connect to the server");
    }
    
    return latency_ret;
}
