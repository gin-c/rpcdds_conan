/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file LatencyAsyncSupport.cxx
 * This source file contains functionality to use asynchronous calls for all interfaces.
 *
 * This file was generated by the tool rpcddsgen.
 */

//TODO Remove when only one VS project will be generated
#if defined(_WIN32) && defined(NDDS_USER_DLL_EXPORT)
class __declspec(dllimport) DDSDomainEntity;
class __declspec(dllimport) DDSEntity;
#endif
#include "LatencyDDSAsyncSupport.h"
#include "rpcdds/exceptions/ServerInternalException.h"
#include "rpcdds/exceptions/ClientInternalException.h"
#include "rpcdds/utils/Messages.h"
#include "LatencyRequestReplyPlugin.h"

#include "LatencyExtension.h"

using namespace eprosima::rpc;
using namespace ::exception;



Latency_latencyTask::Latency_latencyTask(Latency_latencyCallbackHandler &obj) :
    DDSAsyncTask(), m_obj(obj)
{
    Latency_Reply_initialize(&m_reply);
}

Latency_latencyTask::~Latency_latencyTask()
{
    Latency_Reply_finalize(&m_reply);
}

Latency_latencyCallbackHandler& Latency_latencyTask::getObject()
{
    return m_obj;
}

void* Latency_latencyTask::getReplyInstance()
{
    return &m_reply;
}

void Latency_latencyTask::execute()
{  
    st return_;
    ReturnMessage retcode = eprosima::rpc::OK;
    
    switch (m_reply.reply._u.latency._d)
    {
        case 0:
            return_ = m_reply.reply._u.latency._u.out_.return_;
		    getObject().latency(return_);
            break;
        case 1:
            retcode = (eprosima::rpc::ReturnMessage)m_reply.reply._u.latency._u.sysx_;
            if(retcode == eprosima::rpc::SERVER_INTERNAL_ERROR)
                getObject().on_exception(ServerInternalException(""));
            break;
        default:
            getObject().on_exception(ClientInternalException("Error extracting information from server"));
    }
}

void Latency_latencyTask::on_exception(const SystemException &ex)
{
    getObject().on_exception(ex);
}



