/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file LatencyTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "LatencyTopics.h"

#include "fastcdr/Cdr.h"
#include "rpcdds/exceptions/BadParamException.h"




Latency_latency_In::Latency_latency_In()
: m_param(){
}

Latency_latency_In::~Latency_latency_In()
{
}

Latency_latency_In::Latency_latency_In(const Latency_latency_In &x)
: m_param(x.m_param){
}

Latency_latency_In::Latency_latency_In(Latency_latency_In &&x)
: m_param(std::move(x.m_param)){
}

Latency_latency_In& Latency_latency_In::operator=(const Latency_latency_In &x)
{
    m_param = x.m_param;;
    
    return *this;
}

Latency_latency_In& Latency_latency_In::operator=(Latency_latency_In &&x)
{
    m_param = x.m_param;;
    
    return *this;
}

size_t Latency_latency_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 2048; ++a)
    {
        current_alignment += element::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t Latency_latency_In::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    // TODO

    return current_align;
}

void Latency_latency_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    if(m_param.size() <= 2048)
    scdr << m_param;
    else
        throw eprosima::rpc::exception::BadParamException(std::string("param field exceeds the maximum length"));
}

void Latency_latency_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_param;
}


Latency_latency_Out::Latency_latency_Out()
: m_return_(){
}

Latency_latency_Out::~Latency_latency_Out()
{
}

Latency_latency_Out::Latency_latency_Out(const Latency_latency_Out &x)
: m_return_(x.m_return_){
}

Latency_latency_Out::Latency_latency_Out(Latency_latency_Out &&x)
: m_return_(std::move(x.m_return_)){
}

Latency_latency_Out& Latency_latency_Out::operator=(const Latency_latency_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

Latency_latency_Out& Latency_latency_Out::operator=(Latency_latency_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t Latency_latency_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 2048; ++a)
    {
        current_alignment += element::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t Latency_latency_Out::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header

    //// TODO

    return current_align;
}

void Latency_latency_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    if(m_return_.size() <= 2048)
    scdr << m_return_;
    else
        throw eprosima::rpc::exception::BadParamException(std::string("return_ field exceeds the maximum length"));
}

void Latency_latency_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

Latency_latency_Result::Latency_latency_Result() : m__d(2)
{
}

Latency_latency_Result::~Latency_latency_Result()
{
}

Latency_latency_Result::Latency_latency_Result(const Latency_latency_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
            m_out_ = x.m_out_;
            break;
        case 1:
            m_sysx_ = x.m_sysx_;
            break;

    }
}

Latency_latency_Result::Latency_latency_Result(Latency_latency_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
            m_out_ = std::move(x.m_out_);
            break;
        case 1:
            m_sysx_ = x.m_sysx_;
            break;

    }
}

Latency_latency_Result& Latency_latency_Result::operator=(const Latency_latency_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
            m_out_ = x.m_out_;
            break;
        case 1:
            m_sysx_ = x.m_sysx_;
            break;

    }
    
    return *this;
}

Latency_latency_Result& Latency_latency_Result::operator=(Latency_latency_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
            m_out_ = std::move(x.m_out_);
            break;
        case 1:
            m_sysx_ = x.m_sysx_;
            break;

    }
    
    return *this;
}

void Latency_latency_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Latency_latency_Result::_d() const
{
    return m__d;
}

int32_t& Latency_latency_Result::_d()
{
    return m__d;
}

void Latency_latency_Result::unknown_exception(eprosima::rpc::protocol::dds::UnknownException _unknown_exception)
{
    m_unknown_exception = _unknown_exception;
    m__d = 2;
}

eprosima::rpc::protocol::dds::UnknownException Latency_latency_Result::unknown_exception() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknown_exception;
}

eprosima::rpc::protocol::dds::UnknownException& Latency_latency_Result::unknown_exception()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknown_exception;
}

void Latency_latency_Result::out_(const Latency_latency_Out &_out_)
{
    m_out_ = _out_;
    m__d = 0;
}

void Latency_latency_Result::out_(Latency_latency_Out &&_out_)
{
    m_out_ = std::move(_out_);
    m__d = 0;
}

const Latency_latency_Out& Latency_latency_Result::out_() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_out_;
}

Latency_latency_Out& Latency_latency_Result::out_()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_out_;
}

void Latency_latency_Result::sysx_(eprosima::rpc::ReturnMessage _sysx_)
{
    m_sysx_ = _sysx_;
    m__d = 1;
}

eprosima::rpc::ReturnMessage Latency_latency_Result::sysx_() const
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sysx_;
}

eprosima::rpc::ReturnMessage& Latency_latency_Result::sysx_()
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sysx_;
}


size_t Latency_latency_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // sysx_ attribute. The unknown_exception is minor.
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    reset_alignment = current_alignment;
    reset_alignment += Latency_latency_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t Latency_latency_Result::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void Latency_latency_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case 0:
            scdr << m_out_;
            break;
        case 1:
            scdr << (int32_t)m_sysx_;
            break;


        default:
            scdr << m_unknown_exception;
            break;
    }
}

void Latency_latency_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case 0:
            dcdr >> m_out_;
            break;
        case 1:
            dcdr >> (int32_t&)m_sysx_;
            break;


        default:
            dcdr >> m_unknown_exception;
            break;
    }
}


Latency_Call::Latency_Call() : m__d(0)
{
}

Latency_Call::~Latency_Call()
{
}

Latency_Call::Latency_Call(const Latency_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = x.m_latency;
                    break;
                
    }
}

Latency_Call::Latency_Call(Latency_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
}

Latency_Call& Latency_Call::operator=(const Latency_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = x.m_latency;
                    break;
                
    }
    
    return *this;
}

Latency_Call& Latency_Call::operator=(Latency_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
    
    return *this;
}

void Latency_Call::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Latency_Call::_d() const
{
    return m__d;
}

int32_t& Latency_Call::_d()
{
    return m__d;
}

void Latency_Call::unknown_operation(eprosima::rpc::protocol::dds::UnknownOperation _unknown_operation)
{
    m_unknown_operation = _unknown_operation;
    m__d = 0;
}

eprosima::rpc::protocol::dds::UnknownOperation Latency_Call::unknown_operation() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknown_operation;
}

eprosima::rpc::protocol::dds::UnknownOperation& Latency_Call::unknown_operation()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknown_operation;
}

void Latency_Call::latency(const Latency_latency_In &_latency)
{
    m_latency = _latency;
    m__d = (int32_t)0x9E800F53;
}

void Latency_Call::latency(Latency_latency_In &&_latency)
{
    m_latency = std::move(_latency);
    m__d = (int32_t)0x9E800F53;
}

const Latency_latency_In& Latency_Call::latency() const
{
    if(m__d != (int32_t)0x9E800F53)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}

Latency_latency_In& Latency_Call::latency()
{
    if(m__d != (int32_t)0x9E800F53)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}


size_t Latency_Call::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += Latency_latency_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

size_t Latency_Call::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void Latency_Call::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    scdr << m_latency;
                    break;
                
        default:
            scdr << m_unknown_operation;
            break;
    }
}

void Latency_Call::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    dcdr >> m_latency;
                    break;
                
        default:
            dcdr >> m_unknown_operation;
            break;
    }
}

Latency_Request::Latency_Request()
{
}

Latency_Request::~Latency_Request()
{
}

Latency_Request::Latency_Request(const Latency_Request &x)
: m_header(x.m_header), m_request(x.m_request)
{
}

Latency_Request::Latency_Request(Latency_Request &&x)
: m_header(std::move(x.m_header)), m_request(std::move(x.m_request))
{
}

Latency_Request& Latency_Request::operator=(const Latency_Request &x)
{
    m_header = x.m_header;
    m_request = x.m_request;
    
    return *this;
}

Latency_Request& Latency_Request::operator=(Latency_Request &&x)
{
    m_header = std::move(x.m_header);
    m_request = std::move(x.m_request);
    
    return *this;
}

size_t Latency_Request::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment +=  eprosima::rpc::protocol::dds::RequestHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Latency_Call::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t Latency_Request::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and request

    return current_align;
}

void Latency_Request::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_request;
}

void Latency_Request::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_request;
}

Latency_Return::Latency_Return() : m__d(0)
{
}

Latency_Return::~Latency_Return()
{
}

Latency_Return::Latency_Return(const Latency_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = x.m_latency;
                    break;
                
    }
}

Latency_Return::Latency_Return(Latency_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
}

Latency_Return& Latency_Return::operator=(const Latency_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = x.m_latency;
                    break;
                
    }
    
    return *this;
}

Latency_Return& Latency_Return::operator=(Latency_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
    
    return *this;
}

void Latency_Return::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Latency_Return::_d() const
{
    return m__d;
}

int32_t& Latency_Return::_d()
{
    return m__d;
}

void Latency_Return::unknown_operation(eprosima::rpc::protocol::dds::UnknownOperation _unknown_operation)
{
    m_unknown_operation = _unknown_operation;
    m__d = 0;
}

eprosima::rpc::protocol::dds::UnknownOperation Latency_Return::unknown_operation() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknown_operation;
}

eprosima::rpc::protocol::dds::UnknownOperation& Latency_Return::unknown_operation()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknown_operation;
}

void Latency_Return::latency(const Latency_latency_Result &_latency)
{
    m_latency = _latency;
    m__d = (int32_t)0x9E800F53;
}

void Latency_Return::latency(Latency_latency_Result &&_latency)
{
    m_latency = std::move(_latency);
    m__d = (int32_t)0x9E800F53;
}

const Latency_latency_Result& Latency_Return::latency() const
{
    if(m__d != (int32_t)0x9E800F53)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}

Latency_latency_Result& Latency_Return::latency()
{
    if(m__d != (int32_t)0x9E800F53)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}


size_t Latency_Return::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += Latency_latency_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

size_t Latency_Return::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void Latency_Return::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    scdr << m_latency;
                    break;
                
        default:
            scdr << m_unknown_operation;
            break;
    }
}

void Latency_Return::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x9E800F53:
                    dcdr >> m_latency;
                    break;
                
        default:
            dcdr >>  m_unknown_operation;
            break;
    }
}

Latency_Reply::Latency_Reply()
{
}

Latency_Reply::~Latency_Reply()
{
}

Latency_Reply::Latency_Reply(const Latency_Reply &x)
: m_header(x.m_header), m_reply(x.m_reply)
{
}

Latency_Reply::Latency_Reply(Latency_Reply &&x)
: m_header(std::move(x.m_header)), m_reply(std::move(x.m_reply))
{
}

Latency_Reply& Latency_Reply::operator=(const Latency_Reply &x)
{
    m_header = x.m_header;
    m_reply = x.m_reply;
    
    return *this;
}

Latency_Reply& Latency_Reply::operator=(Latency_Reply &&x)
{
    m_header = std::move(x.m_header);
    m_reply = std::move(x.m_reply);
    
    return *this;
}

size_t Latency_Reply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    current_alignment +=  eprosima::rpc::protocol::dds::ReplyHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Latency_Return::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t Latency_Reply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and unio

    return current_align;
}

void Latency_Reply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_reply;
}

void Latency_Reply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_reply;
}
