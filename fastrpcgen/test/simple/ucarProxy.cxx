/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file ucarProxy.cxx
 * This source file contains the definition of the proxy for all interfaces.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "ucarProxy.h"
#include <rpcdds/transports/ProxyTransport.h>
#include "ucarProtocol.h"









UCarProxy::UCarProxy(eprosima::rpc::strategy::ServerStrategy &strategy, eprosima::rpc::transport::ProxyTransport &transport,
    eprosima::rpc::protocol::ucarProtocol &protocol, UCarProxyImpl &servant) :
    Proxy(strategy, transport, protocol), _impl(servant)
{
    protocol.activateInterface("UCar");
    protocol.linkUCarNotifyImpl(servant);
}

UCarProxy::~UCarProxy()
{
}
 
bool UCarProxy::sendTouchEvent(/*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendTouchEvent(action, width, height, count, trackID, x, y);
    return return_;
}
void UCarProxy::sendTouchEvent_async(UCar_sendTouchEventCallbackHandler &obj, /*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendTouchEvent_async(obj, action, width, height, count, trackID, x, y);
}

bool UCarProxy::sendMicRecordData(/*in*/ int32_t i, /*in*/ const ShortArray& shorts, /*in*/ int32_t l)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendMicRecordData(i, shorts, l);
    return return_;
}
void UCarProxy::sendMicRecordData_async(UCar_sendMicRecordDataCallbackHandler &obj, /*in*/ int32_t i, /*in*/ const ShortArray& shorts, /*in*/ int32_t l)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendMicRecordData_async(obj, i, shorts, l);
}

bool UCarProxy::sendKeyEvent(/*in*/ int32_t keyEventActionType, /*in*/ int32_t keyCodeType, /*in*/ int32_t i)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendKeyEvent(keyEventActionType, keyCodeType, i);
    return return_;
}
void UCarProxy::sendKeyEvent_async(UCar_sendKeyEventCallbackHandler &obj, /*in*/ int32_t keyEventActionType, /*in*/ int32_t keyCodeType, /*in*/ int32_t i)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendKeyEvent_async(obj, keyEventActionType, keyCodeType, i);
}

bool UCarProxy::sendGotoForeground()
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendGotoForeground();
    return return_;
}
void UCarProxy::sendGotoForeground_async(UCar_sendGotoForegroundCallbackHandler &obj)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendGotoForeground_async(obj);
}

bool UCarProxy::sendGotoBackground()
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendGotoBackground();
    return return_;
}
void UCarProxy::sendGotoBackground_async(UCar_sendGotoBackgroundCallbackHandler &obj)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendGotoBackground_async(obj);
}

bool UCarProxy::sendVRCMD(/*in*/ int32_t vrcmdType, /*in*/ const std::string& s)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendVRCMD(vrcmdType, s);
    return return_;
}
void UCarProxy::sendVRCMD_async(UCar_sendVRCMDCallbackHandler &obj, /*in*/ int32_t vrcmdType, /*in*/ const std::string& s)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_sendVRCMD_async(obj, vrcmdType, s);
}

bool UCarProxy::notifyIsCallHungUp()
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_notifyIsCallHungUp();
    return return_;
}
void UCarProxy::notifyIsCallHungUp_async(UCar_notifyIsCallHungUpCallbackHandler &obj)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_notifyIsCallHungUp_async(obj);
}

bool UCarProxy::notifySwitchDayOrNight(/*in*/ int32_t dayNightMode)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_notifySwitchDayOrNight(dayNightMode);
    return return_;
}
void UCarProxy::notifySwitchDayOrNight_async(UCar_notifySwitchDayOrNightCallbackHandler &obj, /*in*/ int32_t dayNightMode)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_notifySwitchDayOrNight_async(obj, dayNightMode);
}

bool UCarProxy::awakenVoiceAssistant(/*in*/ const ByteArray& bytes, /*in*/ const AudioFormat& audioFormat)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_awakenVoiceAssistant(bytes, audioFormat);
    return return_;
}
void UCarProxy::awakenVoiceAssistant_async(UCar_awakenVoiceAssistantCallbackHandler &obj, /*in*/ const ByteArray& bytes, /*in*/ const AudioFormat& audioFormat)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_awakenVoiceAssistant_async(obj, bytes, audioFormat);
}

bool UCarProxy::presetVendorCustomFields(/*in*/ const ByteArray& bytes)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_presetVendorCustomFields(bytes);
    return return_;
}
void UCarProxy::presetVendorCustomFields_async(UCar_presetVendorCustomFieldsCallbackHandler &obj, /*in*/ const ByteArray& bytes)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_presetVendorCustomFields_async(obj, bytes);
}

bool UCarProxy::presetConnectMode(/*in*/ int32_t connectMode)
{
    bool return_ =
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_presetConnectMode(connectMode);
    return return_;
}
void UCarProxy::presetConnectMode_async(UCar_presetConnectModeCallbackHandler &obj, /*in*/ int32_t connectMode)
{
    dynamic_cast<eprosima::rpc::protocol::ucarProtocol&>(getProtocol()).UCar_presetConnectMode_async(obj, connectMode);
}

































