/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file ucarTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "ucarTopics.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
#include <rpcdds/exceptions/BadParamException.h>































UCar_sendTouchEvent_In::UCar_sendTouchEvent_In()
: m_action(0), m_width(0), m_height(0), m_count(0), m_trackID(), m_x(), m_y(){
}

UCar_sendTouchEvent_In::~UCar_sendTouchEvent_In()
{
}

UCar_sendTouchEvent_In::UCar_sendTouchEvent_In(const UCar_sendTouchEvent_In &x)
: m_action(x.m_action), m_width(x.m_width), m_height(x.m_height), m_count(x.m_count), m_trackID(x.m_trackID), m_x(x.m_x), m_y(x.m_y){
}

UCar_sendTouchEvent_In::UCar_sendTouchEvent_In(UCar_sendTouchEvent_In &&x)
: m_action(std::move(x.m_action)), m_width(std::move(x.m_width)), m_height(std::move(x.m_height)), m_count(std::move(x.m_count)), m_trackID(std::move(x.m_trackID)), m_x(std::move(x.m_x)), m_y(std::move(x.m_y)){
}

UCar_sendTouchEvent_In& UCar_sendTouchEvent_In::operator=(const UCar_sendTouchEvent_In &x)
{
    m_action = x.m_action;;
    m_width = x.m_width;;
    m_height = x.m_height;;
    m_count = x.m_count;;
    m_trackID = x.m_trackID;;
    m_x = x.m_x;;
    m_y = x.m_y;;
    
    return *this;
}

UCar_sendTouchEvent_In& UCar_sendTouchEvent_In::operator=(UCar_sendTouchEvent_In &&x)
{
    m_action = x.m_action;;
    m_width = x.m_width;;
    m_height = x.m_height;;
    m_count = x.m_count;;
    m_trackID = x.m_trackID;;
    m_x = x.m_x;;
    m_y = x.m_y;;
    
    return *this;
}

size_t UCar_sendTouchEvent_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);




    return current_alignment - initial_alignment;
}

size_t UCar_sendTouchEvent_In::getCdrSerializedSize(const UCar_sendTouchEvent_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.trackID().size() > 0)
    {
        current_alignment += (data.trackID().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.x().size() > 0)
    {
        current_alignment += (data.x().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.y().size() > 0)
    {
        current_alignment += (data.y().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void UCar_sendTouchEvent_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_action;
    scdr << m_width;
    scdr << m_height;
    scdr << m_count;
    scdr << m_trackID;
    scdr << m_x;
    scdr << m_y;
}

void UCar_sendTouchEvent_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_action;
    dcdr >> m_width;
    dcdr >> m_height;
    dcdr >> m_count;
    dcdr >> m_trackID;
    dcdr >> m_x;
    dcdr >> m_y;
}

UCar_sendTouchEvent_Out::UCar_sendTouchEvent_Out()
: m_return_(false){
}

UCar_sendTouchEvent_Out::~UCar_sendTouchEvent_Out()
{
}

UCar_sendTouchEvent_Out::UCar_sendTouchEvent_Out(const UCar_sendTouchEvent_Out &x)
: m_return_(x.m_return_){
}

UCar_sendTouchEvent_Out::UCar_sendTouchEvent_Out(UCar_sendTouchEvent_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendTouchEvent_Out& UCar_sendTouchEvent_Out::operator=(const UCar_sendTouchEvent_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendTouchEvent_Out& UCar_sendTouchEvent_Out::operator=(UCar_sendTouchEvent_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendTouchEvent_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendTouchEvent_Out::getCdrSerializedSize(const UCar_sendTouchEvent_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendTouchEvent_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendTouchEvent_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendTouchEvent_Result::UCar_sendTouchEvent_Result() : m__d(2)
{
}

UCar_sendTouchEvent_Result::~UCar_sendTouchEvent_Result()
{
}

UCar_sendTouchEvent_Result::UCar_sendTouchEvent_Result(const UCar_sendTouchEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendTouchEvent_Result::UCar_sendTouchEvent_Result(UCar_sendTouchEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendTouchEvent_Result& UCar_sendTouchEvent_Result::operator=(const UCar_sendTouchEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendTouchEvent_Result& UCar_sendTouchEvent_Result::operator=(UCar_sendTouchEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendTouchEvent_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendTouchEvent_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendTouchEvent_Result::_d()
{
    return m__d;
}

void UCar_sendTouchEvent_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendTouchEvent_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendTouchEvent_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendTouchEvent_Result::result(const UCar_sendTouchEvent_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendTouchEvent_Result::result(UCar_sendTouchEvent_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendTouchEvent_Out& UCar_sendTouchEvent_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendTouchEvent_Out& UCar_sendTouchEvent_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendTouchEvent_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendTouchEvent_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendTouchEvent_Result::getCdrSerializedSize(const UCar_sendTouchEvent_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendTouchEvent_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendTouchEvent_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendTouchEvent_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_sendMicRecordData_In::UCar_sendMicRecordData_In()
: m_i(0), m_shorts(), m_l(0){
}

UCar_sendMicRecordData_In::~UCar_sendMicRecordData_In()
{
}

UCar_sendMicRecordData_In::UCar_sendMicRecordData_In(const UCar_sendMicRecordData_In &x)
: m_i(x.m_i), m_shorts(x.m_shorts), m_l(x.m_l){
}

UCar_sendMicRecordData_In::UCar_sendMicRecordData_In(UCar_sendMicRecordData_In &&x)
: m_i(std::move(x.m_i)), m_shorts(std::move(x.m_shorts)), m_l(std::move(x.m_l)){
}

UCar_sendMicRecordData_In& UCar_sendMicRecordData_In::operator=(const UCar_sendMicRecordData_In &x)
{
    m_i = x.m_i;;
    m_shorts = x.m_shorts;;
    m_l = x.m_l;;
    
    return *this;
}

UCar_sendMicRecordData_In& UCar_sendMicRecordData_In::operator=(UCar_sendMicRecordData_In &&x)
{
    m_i = x.m_i;;
    m_shorts = x.m_shorts;;
    m_l = x.m_l;;
    
    return *this;
}

size_t UCar_sendMicRecordData_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t UCar_sendMicRecordData_In::getCdrSerializedSize(const UCar_sendMicRecordData_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.shorts().size() > 0)
    {
        current_alignment += (data.shorts().size() * 2) + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void UCar_sendMicRecordData_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_i;
    scdr << m_shorts;
    scdr << m_l;
}

void UCar_sendMicRecordData_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_i;
    dcdr >> m_shorts;
    dcdr >> m_l;
}

UCar_sendMicRecordData_Out::UCar_sendMicRecordData_Out()
: m_return_(false){
}

UCar_sendMicRecordData_Out::~UCar_sendMicRecordData_Out()
{
}

UCar_sendMicRecordData_Out::UCar_sendMicRecordData_Out(const UCar_sendMicRecordData_Out &x)
: m_return_(x.m_return_){
}

UCar_sendMicRecordData_Out::UCar_sendMicRecordData_Out(UCar_sendMicRecordData_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendMicRecordData_Out& UCar_sendMicRecordData_Out::operator=(const UCar_sendMicRecordData_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendMicRecordData_Out& UCar_sendMicRecordData_Out::operator=(UCar_sendMicRecordData_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendMicRecordData_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendMicRecordData_Out::getCdrSerializedSize(const UCar_sendMicRecordData_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendMicRecordData_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendMicRecordData_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendMicRecordData_Result::UCar_sendMicRecordData_Result() : m__d(2)
{
}

UCar_sendMicRecordData_Result::~UCar_sendMicRecordData_Result()
{
}

UCar_sendMicRecordData_Result::UCar_sendMicRecordData_Result(const UCar_sendMicRecordData_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendMicRecordData_Result::UCar_sendMicRecordData_Result(UCar_sendMicRecordData_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendMicRecordData_Result& UCar_sendMicRecordData_Result::operator=(const UCar_sendMicRecordData_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendMicRecordData_Result& UCar_sendMicRecordData_Result::operator=(UCar_sendMicRecordData_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendMicRecordData_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendMicRecordData_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendMicRecordData_Result::_d()
{
    return m__d;
}

void UCar_sendMicRecordData_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendMicRecordData_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendMicRecordData_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendMicRecordData_Result::result(const UCar_sendMicRecordData_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendMicRecordData_Result::result(UCar_sendMicRecordData_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendMicRecordData_Out& UCar_sendMicRecordData_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendMicRecordData_Out& UCar_sendMicRecordData_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendMicRecordData_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendMicRecordData_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendMicRecordData_Result::getCdrSerializedSize(const UCar_sendMicRecordData_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendMicRecordData_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendMicRecordData_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendMicRecordData_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_sendKeyEvent_In::UCar_sendKeyEvent_In()
: m_keyEventActionType(0), m_keyCodeType(0), m_i(0){
}

UCar_sendKeyEvent_In::~UCar_sendKeyEvent_In()
{
}

UCar_sendKeyEvent_In::UCar_sendKeyEvent_In(const UCar_sendKeyEvent_In &x)
: m_keyEventActionType(x.m_keyEventActionType), m_keyCodeType(x.m_keyCodeType), m_i(x.m_i){
}

UCar_sendKeyEvent_In::UCar_sendKeyEvent_In(UCar_sendKeyEvent_In &&x)
: m_keyEventActionType(std::move(x.m_keyEventActionType)), m_keyCodeType(std::move(x.m_keyCodeType)), m_i(std::move(x.m_i)){
}

UCar_sendKeyEvent_In& UCar_sendKeyEvent_In::operator=(const UCar_sendKeyEvent_In &x)
{
    m_keyEventActionType = x.m_keyEventActionType;;
    m_keyCodeType = x.m_keyCodeType;;
    m_i = x.m_i;;
    
    return *this;
}

UCar_sendKeyEvent_In& UCar_sendKeyEvent_In::operator=(UCar_sendKeyEvent_In &&x)
{
    m_keyEventActionType = x.m_keyEventActionType;;
    m_keyCodeType = x.m_keyCodeType;;
    m_i = x.m_i;;
    
    return *this;
}

size_t UCar_sendKeyEvent_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t UCar_sendKeyEvent_In::getCdrSerializedSize(const UCar_sendKeyEvent_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void UCar_sendKeyEvent_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_keyEventActionType;
    scdr << m_keyCodeType;
    scdr << m_i;
}

void UCar_sendKeyEvent_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_keyEventActionType;
    dcdr >> m_keyCodeType;
    dcdr >> m_i;
}

UCar_sendKeyEvent_Out::UCar_sendKeyEvent_Out()
: m_return_(false){
}

UCar_sendKeyEvent_Out::~UCar_sendKeyEvent_Out()
{
}

UCar_sendKeyEvent_Out::UCar_sendKeyEvent_Out(const UCar_sendKeyEvent_Out &x)
: m_return_(x.m_return_){
}

UCar_sendKeyEvent_Out::UCar_sendKeyEvent_Out(UCar_sendKeyEvent_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendKeyEvent_Out& UCar_sendKeyEvent_Out::operator=(const UCar_sendKeyEvent_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendKeyEvent_Out& UCar_sendKeyEvent_Out::operator=(UCar_sendKeyEvent_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendKeyEvent_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendKeyEvent_Out::getCdrSerializedSize(const UCar_sendKeyEvent_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendKeyEvent_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendKeyEvent_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendKeyEvent_Result::UCar_sendKeyEvent_Result() : m__d(2)
{
}

UCar_sendKeyEvent_Result::~UCar_sendKeyEvent_Result()
{
}

UCar_sendKeyEvent_Result::UCar_sendKeyEvent_Result(const UCar_sendKeyEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendKeyEvent_Result::UCar_sendKeyEvent_Result(UCar_sendKeyEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendKeyEvent_Result& UCar_sendKeyEvent_Result::operator=(const UCar_sendKeyEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendKeyEvent_Result& UCar_sendKeyEvent_Result::operator=(UCar_sendKeyEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendKeyEvent_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendKeyEvent_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendKeyEvent_Result::_d()
{
    return m__d;
}

void UCar_sendKeyEvent_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendKeyEvent_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendKeyEvent_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendKeyEvent_Result::result(const UCar_sendKeyEvent_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendKeyEvent_Result::result(UCar_sendKeyEvent_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendKeyEvent_Out& UCar_sendKeyEvent_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendKeyEvent_Out& UCar_sendKeyEvent_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendKeyEvent_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendKeyEvent_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendKeyEvent_Result::getCdrSerializedSize(const UCar_sendKeyEvent_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendKeyEvent_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendKeyEvent_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendKeyEvent_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_sendGotoForeground_In::UCar_sendGotoForeground_In()
: m_dummy(0){
}

UCar_sendGotoForeground_In::~UCar_sendGotoForeground_In()
{
}

UCar_sendGotoForeground_In::UCar_sendGotoForeground_In(const UCar_sendGotoForeground_In &x)
: m_dummy(x.m_dummy){
}

UCar_sendGotoForeground_In::UCar_sendGotoForeground_In(UCar_sendGotoForeground_In &&x)
: m_dummy(x.m_dummy){
}

UCar_sendGotoForeground_In& UCar_sendGotoForeground_In::operator=(const UCar_sendGotoForeground_In &x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

UCar_sendGotoForeground_In& UCar_sendGotoForeground_In::operator=(UCar_sendGotoForeground_In &&x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

size_t UCar_sendGotoForeground_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t UCar_sendGotoForeground_In::getCdrSerializedSize(const UCar_sendGotoForeground_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void UCar_sendGotoForeground_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void UCar_sendGotoForeground_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

UCar_sendGotoForeground_Out::UCar_sendGotoForeground_Out()
: m_return_(false){
}

UCar_sendGotoForeground_Out::~UCar_sendGotoForeground_Out()
{
}

UCar_sendGotoForeground_Out::UCar_sendGotoForeground_Out(const UCar_sendGotoForeground_Out &x)
: m_return_(x.m_return_){
}

UCar_sendGotoForeground_Out::UCar_sendGotoForeground_Out(UCar_sendGotoForeground_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendGotoForeground_Out& UCar_sendGotoForeground_Out::operator=(const UCar_sendGotoForeground_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendGotoForeground_Out& UCar_sendGotoForeground_Out::operator=(UCar_sendGotoForeground_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendGotoForeground_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendGotoForeground_Out::getCdrSerializedSize(const UCar_sendGotoForeground_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendGotoForeground_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendGotoForeground_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendGotoForeground_Result::UCar_sendGotoForeground_Result() : m__d(2)
{
}

UCar_sendGotoForeground_Result::~UCar_sendGotoForeground_Result()
{
}

UCar_sendGotoForeground_Result::UCar_sendGotoForeground_Result(const UCar_sendGotoForeground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendGotoForeground_Result::UCar_sendGotoForeground_Result(UCar_sendGotoForeground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendGotoForeground_Result& UCar_sendGotoForeground_Result::operator=(const UCar_sendGotoForeground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendGotoForeground_Result& UCar_sendGotoForeground_Result::operator=(UCar_sendGotoForeground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendGotoForeground_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendGotoForeground_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendGotoForeground_Result::_d()
{
    return m__d;
}

void UCar_sendGotoForeground_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendGotoForeground_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendGotoForeground_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendGotoForeground_Result::result(const UCar_sendGotoForeground_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendGotoForeground_Result::result(UCar_sendGotoForeground_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendGotoForeground_Out& UCar_sendGotoForeground_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendGotoForeground_Out& UCar_sendGotoForeground_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendGotoForeground_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendGotoForeground_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendGotoForeground_Result::getCdrSerializedSize(const UCar_sendGotoForeground_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendGotoForeground_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendGotoForeground_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendGotoForeground_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_sendGotoBackground_In::UCar_sendGotoBackground_In()
: m_dummy(0){
}

UCar_sendGotoBackground_In::~UCar_sendGotoBackground_In()
{
}

UCar_sendGotoBackground_In::UCar_sendGotoBackground_In(const UCar_sendGotoBackground_In &x)
: m_dummy(x.m_dummy){
}

UCar_sendGotoBackground_In::UCar_sendGotoBackground_In(UCar_sendGotoBackground_In &&x)
: m_dummy(x.m_dummy){
}

UCar_sendGotoBackground_In& UCar_sendGotoBackground_In::operator=(const UCar_sendGotoBackground_In &x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

UCar_sendGotoBackground_In& UCar_sendGotoBackground_In::operator=(UCar_sendGotoBackground_In &&x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

size_t UCar_sendGotoBackground_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t UCar_sendGotoBackground_In::getCdrSerializedSize(const UCar_sendGotoBackground_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void UCar_sendGotoBackground_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void UCar_sendGotoBackground_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

UCar_sendGotoBackground_Out::UCar_sendGotoBackground_Out()
: m_return_(false){
}

UCar_sendGotoBackground_Out::~UCar_sendGotoBackground_Out()
{
}

UCar_sendGotoBackground_Out::UCar_sendGotoBackground_Out(const UCar_sendGotoBackground_Out &x)
: m_return_(x.m_return_){
}

UCar_sendGotoBackground_Out::UCar_sendGotoBackground_Out(UCar_sendGotoBackground_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendGotoBackground_Out& UCar_sendGotoBackground_Out::operator=(const UCar_sendGotoBackground_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendGotoBackground_Out& UCar_sendGotoBackground_Out::operator=(UCar_sendGotoBackground_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendGotoBackground_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendGotoBackground_Out::getCdrSerializedSize(const UCar_sendGotoBackground_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendGotoBackground_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendGotoBackground_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendGotoBackground_Result::UCar_sendGotoBackground_Result() : m__d(2)
{
}

UCar_sendGotoBackground_Result::~UCar_sendGotoBackground_Result()
{
}

UCar_sendGotoBackground_Result::UCar_sendGotoBackground_Result(const UCar_sendGotoBackground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendGotoBackground_Result::UCar_sendGotoBackground_Result(UCar_sendGotoBackground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendGotoBackground_Result& UCar_sendGotoBackground_Result::operator=(const UCar_sendGotoBackground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendGotoBackground_Result& UCar_sendGotoBackground_Result::operator=(UCar_sendGotoBackground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendGotoBackground_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendGotoBackground_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendGotoBackground_Result::_d()
{
    return m__d;
}

void UCar_sendGotoBackground_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendGotoBackground_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendGotoBackground_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendGotoBackground_Result::result(const UCar_sendGotoBackground_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendGotoBackground_Result::result(UCar_sendGotoBackground_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendGotoBackground_Out& UCar_sendGotoBackground_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendGotoBackground_Out& UCar_sendGotoBackground_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendGotoBackground_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendGotoBackground_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendGotoBackground_Result::getCdrSerializedSize(const UCar_sendGotoBackground_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendGotoBackground_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendGotoBackground_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendGotoBackground_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_sendVRCMD_In::UCar_sendVRCMD_In()
: m_vrcmdType(0), m_s(){
}

UCar_sendVRCMD_In::~UCar_sendVRCMD_In()
{
}

UCar_sendVRCMD_In::UCar_sendVRCMD_In(const UCar_sendVRCMD_In &x)
: m_vrcmdType(x.m_vrcmdType), m_s(x.m_s){
}

UCar_sendVRCMD_In::UCar_sendVRCMD_In(UCar_sendVRCMD_In &&x)
: m_vrcmdType(std::move(x.m_vrcmdType)), m_s(std::move(x.m_s)){
}

UCar_sendVRCMD_In& UCar_sendVRCMD_In::operator=(const UCar_sendVRCMD_In &x)
{
    m_vrcmdType = x.m_vrcmdType;;
    m_s = x.m_s;;
    
    return *this;
}

UCar_sendVRCMD_In& UCar_sendVRCMD_In::operator=(UCar_sendVRCMD_In &&x)
{
    m_vrcmdType = x.m_vrcmdType;;
    m_s = x.m_s;;
    
    return *this;
}

size_t UCar_sendVRCMD_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t UCar_sendVRCMD_In::getCdrSerializedSize(const UCar_sendVRCMD_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.s().size() + 1;


    return current_alignment - initial_alignment;
}

void UCar_sendVRCMD_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_vrcmdType;
    scdr << m_s;
}

void UCar_sendVRCMD_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_vrcmdType;
    dcdr >> m_s;
}

UCar_sendVRCMD_Out::UCar_sendVRCMD_Out()
: m_return_(false){
}

UCar_sendVRCMD_Out::~UCar_sendVRCMD_Out()
{
}

UCar_sendVRCMD_Out::UCar_sendVRCMD_Out(const UCar_sendVRCMD_Out &x)
: m_return_(x.m_return_){
}

UCar_sendVRCMD_Out::UCar_sendVRCMD_Out(UCar_sendVRCMD_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_sendVRCMD_Out& UCar_sendVRCMD_Out::operator=(const UCar_sendVRCMD_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_sendVRCMD_Out& UCar_sendVRCMD_Out::operator=(UCar_sendVRCMD_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_sendVRCMD_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_sendVRCMD_Out::getCdrSerializedSize(const UCar_sendVRCMD_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_sendVRCMD_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_sendVRCMD_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_sendVRCMD_Result::UCar_sendVRCMD_Result() : m__d(2)
{
}

UCar_sendVRCMD_Result::~UCar_sendVRCMD_Result()
{
}

UCar_sendVRCMD_Result::UCar_sendVRCMD_Result(const UCar_sendVRCMD_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_sendVRCMD_Result::UCar_sendVRCMD_Result(UCar_sendVRCMD_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_sendVRCMD_Result& UCar_sendVRCMD_Result::operator=(const UCar_sendVRCMD_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_sendVRCMD_Result& UCar_sendVRCMD_Result::operator=(UCar_sendVRCMD_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_sendVRCMD_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_sendVRCMD_Result::_d() const
{
    return m__d;
}

int32_t& UCar_sendVRCMD_Result::_d()
{
    return m__d;
}

void UCar_sendVRCMD_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_sendVRCMD_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_sendVRCMD_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_sendVRCMD_Result::result(const UCar_sendVRCMD_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_sendVRCMD_Result::result(UCar_sendVRCMD_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_sendVRCMD_Out& UCar_sendVRCMD_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_sendVRCMD_Out& UCar_sendVRCMD_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_sendVRCMD_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_sendVRCMD_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_sendVRCMD_Result::getCdrSerializedSize(const UCar_sendVRCMD_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_sendVRCMD_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_sendVRCMD_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_sendVRCMD_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_notifyIsCallHungUp_In::UCar_notifyIsCallHungUp_In()
: m_dummy(0){
}

UCar_notifyIsCallHungUp_In::~UCar_notifyIsCallHungUp_In()
{
}

UCar_notifyIsCallHungUp_In::UCar_notifyIsCallHungUp_In(const UCar_notifyIsCallHungUp_In &x)
: m_dummy(x.m_dummy){
}

UCar_notifyIsCallHungUp_In::UCar_notifyIsCallHungUp_In(UCar_notifyIsCallHungUp_In &&x)
: m_dummy(x.m_dummy){
}

UCar_notifyIsCallHungUp_In& UCar_notifyIsCallHungUp_In::operator=(const UCar_notifyIsCallHungUp_In &x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

UCar_notifyIsCallHungUp_In& UCar_notifyIsCallHungUp_In::operator=(UCar_notifyIsCallHungUp_In &&x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

size_t UCar_notifyIsCallHungUp_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t UCar_notifyIsCallHungUp_In::getCdrSerializedSize(const UCar_notifyIsCallHungUp_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void UCar_notifyIsCallHungUp_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void UCar_notifyIsCallHungUp_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

UCar_notifyIsCallHungUp_Out::UCar_notifyIsCallHungUp_Out()
: m_return_(false){
}

UCar_notifyIsCallHungUp_Out::~UCar_notifyIsCallHungUp_Out()
{
}

UCar_notifyIsCallHungUp_Out::UCar_notifyIsCallHungUp_Out(const UCar_notifyIsCallHungUp_Out &x)
: m_return_(x.m_return_){
}

UCar_notifyIsCallHungUp_Out::UCar_notifyIsCallHungUp_Out(UCar_notifyIsCallHungUp_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_notifyIsCallHungUp_Out& UCar_notifyIsCallHungUp_Out::operator=(const UCar_notifyIsCallHungUp_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_notifyIsCallHungUp_Out& UCar_notifyIsCallHungUp_Out::operator=(UCar_notifyIsCallHungUp_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_notifyIsCallHungUp_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_notifyIsCallHungUp_Out::getCdrSerializedSize(const UCar_notifyIsCallHungUp_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_notifyIsCallHungUp_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_notifyIsCallHungUp_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_notifyIsCallHungUp_Result::UCar_notifyIsCallHungUp_Result() : m__d(2)
{
}

UCar_notifyIsCallHungUp_Result::~UCar_notifyIsCallHungUp_Result()
{
}

UCar_notifyIsCallHungUp_Result::UCar_notifyIsCallHungUp_Result(const UCar_notifyIsCallHungUp_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_notifyIsCallHungUp_Result::UCar_notifyIsCallHungUp_Result(UCar_notifyIsCallHungUp_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_notifyIsCallHungUp_Result& UCar_notifyIsCallHungUp_Result::operator=(const UCar_notifyIsCallHungUp_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_notifyIsCallHungUp_Result& UCar_notifyIsCallHungUp_Result::operator=(UCar_notifyIsCallHungUp_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_notifyIsCallHungUp_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_notifyIsCallHungUp_Result::_d() const
{
    return m__d;
}

int32_t& UCar_notifyIsCallHungUp_Result::_d()
{
    return m__d;
}

void UCar_notifyIsCallHungUp_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_notifyIsCallHungUp_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_notifyIsCallHungUp_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_notifyIsCallHungUp_Result::result(const UCar_notifyIsCallHungUp_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_notifyIsCallHungUp_Result::result(UCar_notifyIsCallHungUp_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_notifyIsCallHungUp_Out& UCar_notifyIsCallHungUp_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_notifyIsCallHungUp_Out& UCar_notifyIsCallHungUp_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_notifyIsCallHungUp_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_notifyIsCallHungUp_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_notifyIsCallHungUp_Result::getCdrSerializedSize(const UCar_notifyIsCallHungUp_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_notifyIsCallHungUp_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_notifyIsCallHungUp_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_notifyIsCallHungUp_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_notifySwitchDayOrNight_In::UCar_notifySwitchDayOrNight_In()
: m_dayNightMode(0){
}

UCar_notifySwitchDayOrNight_In::~UCar_notifySwitchDayOrNight_In()
{
}

UCar_notifySwitchDayOrNight_In::UCar_notifySwitchDayOrNight_In(const UCar_notifySwitchDayOrNight_In &x)
: m_dayNightMode(x.m_dayNightMode){
}

UCar_notifySwitchDayOrNight_In::UCar_notifySwitchDayOrNight_In(UCar_notifySwitchDayOrNight_In &&x)
: m_dayNightMode(std::move(x.m_dayNightMode)){
}

UCar_notifySwitchDayOrNight_In& UCar_notifySwitchDayOrNight_In::operator=(const UCar_notifySwitchDayOrNight_In &x)
{
    m_dayNightMode = x.m_dayNightMode;;
    
    return *this;
}

UCar_notifySwitchDayOrNight_In& UCar_notifySwitchDayOrNight_In::operator=(UCar_notifySwitchDayOrNight_In &&x)
{
    m_dayNightMode = x.m_dayNightMode;;
    
    return *this;
}

size_t UCar_notifySwitchDayOrNight_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t UCar_notifySwitchDayOrNight_In::getCdrSerializedSize(const UCar_notifySwitchDayOrNight_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void UCar_notifySwitchDayOrNight_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dayNightMode;
}

void UCar_notifySwitchDayOrNight_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dayNightMode;
}

UCar_notifySwitchDayOrNight_Out::UCar_notifySwitchDayOrNight_Out()
: m_return_(false){
}

UCar_notifySwitchDayOrNight_Out::~UCar_notifySwitchDayOrNight_Out()
{
}

UCar_notifySwitchDayOrNight_Out::UCar_notifySwitchDayOrNight_Out(const UCar_notifySwitchDayOrNight_Out &x)
: m_return_(x.m_return_){
}

UCar_notifySwitchDayOrNight_Out::UCar_notifySwitchDayOrNight_Out(UCar_notifySwitchDayOrNight_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_notifySwitchDayOrNight_Out& UCar_notifySwitchDayOrNight_Out::operator=(const UCar_notifySwitchDayOrNight_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_notifySwitchDayOrNight_Out& UCar_notifySwitchDayOrNight_Out::operator=(UCar_notifySwitchDayOrNight_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_notifySwitchDayOrNight_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_notifySwitchDayOrNight_Out::getCdrSerializedSize(const UCar_notifySwitchDayOrNight_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_notifySwitchDayOrNight_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_notifySwitchDayOrNight_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_notifySwitchDayOrNight_Result::UCar_notifySwitchDayOrNight_Result() : m__d(2)
{
}

UCar_notifySwitchDayOrNight_Result::~UCar_notifySwitchDayOrNight_Result()
{
}

UCar_notifySwitchDayOrNight_Result::UCar_notifySwitchDayOrNight_Result(const UCar_notifySwitchDayOrNight_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_notifySwitchDayOrNight_Result::UCar_notifySwitchDayOrNight_Result(UCar_notifySwitchDayOrNight_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_notifySwitchDayOrNight_Result& UCar_notifySwitchDayOrNight_Result::operator=(const UCar_notifySwitchDayOrNight_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_notifySwitchDayOrNight_Result& UCar_notifySwitchDayOrNight_Result::operator=(UCar_notifySwitchDayOrNight_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_notifySwitchDayOrNight_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_notifySwitchDayOrNight_Result::_d() const
{
    return m__d;
}

int32_t& UCar_notifySwitchDayOrNight_Result::_d()
{
    return m__d;
}

void UCar_notifySwitchDayOrNight_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_notifySwitchDayOrNight_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_notifySwitchDayOrNight_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_notifySwitchDayOrNight_Result::result(const UCar_notifySwitchDayOrNight_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_notifySwitchDayOrNight_Result::result(UCar_notifySwitchDayOrNight_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_notifySwitchDayOrNight_Out& UCar_notifySwitchDayOrNight_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_notifySwitchDayOrNight_Out& UCar_notifySwitchDayOrNight_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_notifySwitchDayOrNight_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_notifySwitchDayOrNight_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_notifySwitchDayOrNight_Result::getCdrSerializedSize(const UCar_notifySwitchDayOrNight_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_notifySwitchDayOrNight_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_notifySwitchDayOrNight_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_notifySwitchDayOrNight_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_awakenVoiceAssistant_In::UCar_awakenVoiceAssistant_In()
: m_bytes(), m_audioFormat(){
}

UCar_awakenVoiceAssistant_In::~UCar_awakenVoiceAssistant_In()
{
}

UCar_awakenVoiceAssistant_In::UCar_awakenVoiceAssistant_In(const UCar_awakenVoiceAssistant_In &x)
: m_bytes(x.m_bytes), m_audioFormat(x.m_audioFormat){
}

UCar_awakenVoiceAssistant_In::UCar_awakenVoiceAssistant_In(UCar_awakenVoiceAssistant_In &&x)
: m_bytes(std::move(x.m_bytes)), m_audioFormat(std::move(x.m_audioFormat)){
}

UCar_awakenVoiceAssistant_In& UCar_awakenVoiceAssistant_In::operator=(const UCar_awakenVoiceAssistant_In &x)
{
    m_bytes = x.m_bytes;;
    m_audioFormat = x.m_audioFormat;;
    
    return *this;
}

UCar_awakenVoiceAssistant_In& UCar_awakenVoiceAssistant_In::operator=(UCar_awakenVoiceAssistant_In &&x)
{
    m_bytes = x.m_bytes;;
    m_audioFormat = x.m_audioFormat;;
    
    return *this;
}

size_t UCar_awakenVoiceAssistant_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (10240 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    current_alignment += AudioFormat::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t UCar_awakenVoiceAssistant_In::getCdrSerializedSize(const UCar_awakenVoiceAssistant_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.bytes().size() > 0)
    {
        current_alignment += (data.bytes().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    current_alignment += AudioFormat::getCdrSerializedSize(data.audioFormat(), current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_awakenVoiceAssistant_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_bytes;
    scdr << m_audioFormat;
}

void UCar_awakenVoiceAssistant_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_bytes;
    dcdr >> m_audioFormat;
}

UCar_awakenVoiceAssistant_Out::UCar_awakenVoiceAssistant_Out()
: m_return_(false){
}

UCar_awakenVoiceAssistant_Out::~UCar_awakenVoiceAssistant_Out()
{
}

UCar_awakenVoiceAssistant_Out::UCar_awakenVoiceAssistant_Out(const UCar_awakenVoiceAssistant_Out &x)
: m_return_(x.m_return_){
}

UCar_awakenVoiceAssistant_Out::UCar_awakenVoiceAssistant_Out(UCar_awakenVoiceAssistant_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_awakenVoiceAssistant_Out& UCar_awakenVoiceAssistant_Out::operator=(const UCar_awakenVoiceAssistant_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_awakenVoiceAssistant_Out& UCar_awakenVoiceAssistant_Out::operator=(UCar_awakenVoiceAssistant_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_awakenVoiceAssistant_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_awakenVoiceAssistant_Out::getCdrSerializedSize(const UCar_awakenVoiceAssistant_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_awakenVoiceAssistant_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_awakenVoiceAssistant_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_awakenVoiceAssistant_Result::UCar_awakenVoiceAssistant_Result() : m__d(2)
{
}

UCar_awakenVoiceAssistant_Result::~UCar_awakenVoiceAssistant_Result()
{
}

UCar_awakenVoiceAssistant_Result::UCar_awakenVoiceAssistant_Result(const UCar_awakenVoiceAssistant_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_awakenVoiceAssistant_Result::UCar_awakenVoiceAssistant_Result(UCar_awakenVoiceAssistant_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_awakenVoiceAssistant_Result& UCar_awakenVoiceAssistant_Result::operator=(const UCar_awakenVoiceAssistant_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_awakenVoiceAssistant_Result& UCar_awakenVoiceAssistant_Result::operator=(UCar_awakenVoiceAssistant_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_awakenVoiceAssistant_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_awakenVoiceAssistant_Result::_d() const
{
    return m__d;
}

int32_t& UCar_awakenVoiceAssistant_Result::_d()
{
    return m__d;
}

void UCar_awakenVoiceAssistant_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_awakenVoiceAssistant_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_awakenVoiceAssistant_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_awakenVoiceAssistant_Result::result(const UCar_awakenVoiceAssistant_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_awakenVoiceAssistant_Result::result(UCar_awakenVoiceAssistant_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_awakenVoiceAssistant_Out& UCar_awakenVoiceAssistant_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_awakenVoiceAssistant_Out& UCar_awakenVoiceAssistant_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_awakenVoiceAssistant_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_awakenVoiceAssistant_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_awakenVoiceAssistant_Result::getCdrSerializedSize(const UCar_awakenVoiceAssistant_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_awakenVoiceAssistant_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_awakenVoiceAssistant_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_awakenVoiceAssistant_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_presetVendorCustomFields_In::UCar_presetVendorCustomFields_In()
: m_bytes(){
}

UCar_presetVendorCustomFields_In::~UCar_presetVendorCustomFields_In()
{
}

UCar_presetVendorCustomFields_In::UCar_presetVendorCustomFields_In(const UCar_presetVendorCustomFields_In &x)
: m_bytes(x.m_bytes){
}

UCar_presetVendorCustomFields_In::UCar_presetVendorCustomFields_In(UCar_presetVendorCustomFields_In &&x)
: m_bytes(std::move(x.m_bytes)){
}

UCar_presetVendorCustomFields_In& UCar_presetVendorCustomFields_In::operator=(const UCar_presetVendorCustomFields_In &x)
{
    m_bytes = x.m_bytes;;
    
    return *this;
}

UCar_presetVendorCustomFields_In& UCar_presetVendorCustomFields_In::operator=(UCar_presetVendorCustomFields_In &&x)
{
    m_bytes = x.m_bytes;;
    
    return *this;
}

size_t UCar_presetVendorCustomFields_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (10240 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t UCar_presetVendorCustomFields_In::getCdrSerializedSize(const UCar_presetVendorCustomFields_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.bytes().size() > 0)
    {
        current_alignment += (data.bytes().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }



    return current_alignment - initial_alignment;
}

void UCar_presetVendorCustomFields_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_bytes;}

void UCar_presetVendorCustomFields_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_bytes;}

UCar_presetVendorCustomFields_Out::UCar_presetVendorCustomFields_Out()
: m_return_(false){
}

UCar_presetVendorCustomFields_Out::~UCar_presetVendorCustomFields_Out()
{
}

UCar_presetVendorCustomFields_Out::UCar_presetVendorCustomFields_Out(const UCar_presetVendorCustomFields_Out &x)
: m_return_(x.m_return_){
}

UCar_presetVendorCustomFields_Out::UCar_presetVendorCustomFields_Out(UCar_presetVendorCustomFields_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_presetVendorCustomFields_Out& UCar_presetVendorCustomFields_Out::operator=(const UCar_presetVendorCustomFields_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_presetVendorCustomFields_Out& UCar_presetVendorCustomFields_Out::operator=(UCar_presetVendorCustomFields_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_presetVendorCustomFields_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_presetVendorCustomFields_Out::getCdrSerializedSize(const UCar_presetVendorCustomFields_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_presetVendorCustomFields_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_presetVendorCustomFields_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_presetVendorCustomFields_Result::UCar_presetVendorCustomFields_Result() : m__d(2)
{
}

UCar_presetVendorCustomFields_Result::~UCar_presetVendorCustomFields_Result()
{
}

UCar_presetVendorCustomFields_Result::UCar_presetVendorCustomFields_Result(const UCar_presetVendorCustomFields_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_presetVendorCustomFields_Result::UCar_presetVendorCustomFields_Result(UCar_presetVendorCustomFields_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_presetVendorCustomFields_Result& UCar_presetVendorCustomFields_Result::operator=(const UCar_presetVendorCustomFields_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_presetVendorCustomFields_Result& UCar_presetVendorCustomFields_Result::operator=(UCar_presetVendorCustomFields_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_presetVendorCustomFields_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_presetVendorCustomFields_Result::_d() const
{
    return m__d;
}

int32_t& UCar_presetVendorCustomFields_Result::_d()
{
    return m__d;
}

void UCar_presetVendorCustomFields_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_presetVendorCustomFields_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_presetVendorCustomFields_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_presetVendorCustomFields_Result::result(const UCar_presetVendorCustomFields_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_presetVendorCustomFields_Result::result(UCar_presetVendorCustomFields_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_presetVendorCustomFields_Out& UCar_presetVendorCustomFields_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_presetVendorCustomFields_Out& UCar_presetVendorCustomFields_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_presetVendorCustomFields_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_presetVendorCustomFields_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_presetVendorCustomFields_Result::getCdrSerializedSize(const UCar_presetVendorCustomFields_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_presetVendorCustomFields_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_presetVendorCustomFields_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_presetVendorCustomFields_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

UCar_presetConnectMode_In::UCar_presetConnectMode_In()
: m_connectMode(0){
}

UCar_presetConnectMode_In::~UCar_presetConnectMode_In()
{
}

UCar_presetConnectMode_In::UCar_presetConnectMode_In(const UCar_presetConnectMode_In &x)
: m_connectMode(x.m_connectMode){
}

UCar_presetConnectMode_In::UCar_presetConnectMode_In(UCar_presetConnectMode_In &&x)
: m_connectMode(std::move(x.m_connectMode)){
}

UCar_presetConnectMode_In& UCar_presetConnectMode_In::operator=(const UCar_presetConnectMode_In &x)
{
    m_connectMode = x.m_connectMode;;
    
    return *this;
}

UCar_presetConnectMode_In& UCar_presetConnectMode_In::operator=(UCar_presetConnectMode_In &&x)
{
    m_connectMode = x.m_connectMode;;
    
    return *this;
}

size_t UCar_presetConnectMode_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t UCar_presetConnectMode_In::getCdrSerializedSize(const UCar_presetConnectMode_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void UCar_presetConnectMode_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_connectMode;
}

void UCar_presetConnectMode_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_connectMode;
}

UCar_presetConnectMode_Out::UCar_presetConnectMode_Out()
: m_return_(false){
}

UCar_presetConnectMode_Out::~UCar_presetConnectMode_Out()
{
}

UCar_presetConnectMode_Out::UCar_presetConnectMode_Out(const UCar_presetConnectMode_Out &x)
: m_return_(x.m_return_){
}

UCar_presetConnectMode_Out::UCar_presetConnectMode_Out(UCar_presetConnectMode_Out &&x)
: m_return_(std::move(x.m_return_)){
}

UCar_presetConnectMode_Out& UCar_presetConnectMode_Out::operator=(const UCar_presetConnectMode_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

UCar_presetConnectMode_Out& UCar_presetConnectMode_Out::operator=(UCar_presetConnectMode_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t UCar_presetConnectMode_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t UCar_presetConnectMode_Out::getCdrSerializedSize(const UCar_presetConnectMode_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void UCar_presetConnectMode_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void UCar_presetConnectMode_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

UCar_presetConnectMode_Result::UCar_presetConnectMode_Result() : m__d(2)
{
}

UCar_presetConnectMode_Result::~UCar_presetConnectMode_Result()
{
}

UCar_presetConnectMode_Result::UCar_presetConnectMode_Result(const UCar_presetConnectMode_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_presetConnectMode_Result::UCar_presetConnectMode_Result(UCar_presetConnectMode_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_presetConnectMode_Result& UCar_presetConnectMode_Result::operator=(const UCar_presetConnectMode_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_presetConnectMode_Result& UCar_presetConnectMode_Result::operator=(UCar_presetConnectMode_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_presetConnectMode_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_presetConnectMode_Result::_d() const
{
    return m__d;
}

int32_t& UCar_presetConnectMode_Result::_d()
{
    return m__d;
}

void UCar_presetConnectMode_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_presetConnectMode_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_presetConnectMode_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_presetConnectMode_Result::result(const UCar_presetConnectMode_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_presetConnectMode_Result::result(UCar_presetConnectMode_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_presetConnectMode_Out& UCar_presetConnectMode_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_presetConnectMode_Out& UCar_presetConnectMode_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_presetConnectMode_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_presetConnectMode_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_presetConnectMode_Result::getCdrSerializedSize(const UCar_presetConnectMode_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_presetConnectMode_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_presetConnectMode_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_presetConnectMode_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_videoInitialized_Out::UCar_videoInitialized_Out()
: m_type(0), m_videFormat(){
}

UCar_videoInitialized_Out::~UCar_videoInitialized_Out()
{
}

UCar_videoInitialized_Out::UCar_videoInitialized_Out(const UCar_videoInitialized_Out &x)
: m_type(x.m_type), m_videFormat(x.m_videFormat){
}

UCar_videoInitialized_Out::UCar_videoInitialized_Out(UCar_videoInitialized_Out &&x)
: m_type(std::move(x.m_type)), m_videFormat(std::move(x.m_videFormat)){
}

UCar_videoInitialized_Out& UCar_videoInitialized_Out::operator=(const UCar_videoInitialized_Out &x)
{
    m_type = x.m_type;;
    m_videFormat = x.m_videFormat;;

    return *this;
}

UCar_videoInitialized_Out& UCar_videoInitialized_Out::operator=(UCar_videoInitialized_Out &&x)
{
    m_type = x.m_type;;
    m_videFormat = x.m_videFormat;;

    return *this;
}

size_t UCar_videoInitialized_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += VideoFormat::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t UCar_videoInitialized_Out::getCdrSerializedSize(const UCar_videoInitialized_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += VideoFormat::getCdrSerializedSize(data.videFormat(), current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_videoInitialized_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_type;
    scdr << m_videFormat;
}

void UCar_videoInitialized_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_type;
    dcdr >> m_videFormat;
}

UCar_videoInitialized_Result::UCar_videoInitialized_Result() : m__d(2)
{
}

UCar_videoInitialized_Result::~UCar_videoInitialized_Result()
{
}

UCar_videoInitialized_Result::UCar_videoInitialized_Result(const UCar_videoInitialized_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_videoInitialized_Result::UCar_videoInitialized_Result(UCar_videoInitialized_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_videoInitialized_Result& UCar_videoInitialized_Result::operator=(const UCar_videoInitialized_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_videoInitialized_Result& UCar_videoInitialized_Result::operator=(UCar_videoInitialized_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_videoInitialized_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_videoInitialized_Result::_d() const
{
    return m__d;
}

int32_t& UCar_videoInitialized_Result::_d()
{
    return m__d;
}

void UCar_videoInitialized_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_videoInitialized_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_videoInitialized_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_videoInitialized_Result::result(const UCar_videoInitialized_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_videoInitialized_Result::result(UCar_videoInitialized_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_videoInitialized_Out& UCar_videoInitialized_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_videoInitialized_Out& UCar_videoInitialized_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_videoInitialized_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_videoInitialized_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_videoInitialized_Result::getCdrSerializedSize(const UCar_videoInitialized_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_videoInitialized_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_videoInitialized_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_videoInitialized_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_videoDataReceived_Out::UCar_videoDataReceived_Out()
: m_type(0), m_size(0), m_byte(){
}

UCar_videoDataReceived_Out::~UCar_videoDataReceived_Out()
{
}

UCar_videoDataReceived_Out::UCar_videoDataReceived_Out(const UCar_videoDataReceived_Out &x)
: m_type(x.m_type), m_size(x.m_size), m_byte(x.m_byte){
}

UCar_videoDataReceived_Out::UCar_videoDataReceived_Out(UCar_videoDataReceived_Out &&x)
: m_type(std::move(x.m_type)), m_size(std::move(x.m_size)), m_byte(std::move(x.m_byte)){
}

UCar_videoDataReceived_Out& UCar_videoDataReceived_Out::operator=(const UCar_videoDataReceived_Out &x)
{
    m_type = x.m_type;;
    m_size = x.m_size;;
    m_byte = x.m_byte;;

    return *this;
}

UCar_videoDataReceived_Out& UCar_videoDataReceived_Out::operator=(UCar_videoDataReceived_Out &&x)
{
    m_type = x.m_type;;
    m_size = x.m_size;;
    m_byte = x.m_byte;;

    return *this;
}

size_t UCar_videoDataReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (10240 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t UCar_videoDataReceived_Out::getCdrSerializedSize(const UCar_videoDataReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.byte().size() > 0)
    {
        current_alignment += (data.byte().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void UCar_videoDataReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_type;
    scdr << m_size;
    scdr << m_byte;
}

void UCar_videoDataReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_type;
    dcdr >> m_size;
    dcdr >> m_byte;
}

UCar_videoDataReceived_Result::UCar_videoDataReceived_Result() : m__d(2)
{
}

UCar_videoDataReceived_Result::~UCar_videoDataReceived_Result()
{
}

UCar_videoDataReceived_Result::UCar_videoDataReceived_Result(const UCar_videoDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_videoDataReceived_Result::UCar_videoDataReceived_Result(UCar_videoDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_videoDataReceived_Result& UCar_videoDataReceived_Result::operator=(const UCar_videoDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_videoDataReceived_Result& UCar_videoDataReceived_Result::operator=(UCar_videoDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_videoDataReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_videoDataReceived_Result::_d() const
{
    return m__d;
}

int32_t& UCar_videoDataReceived_Result::_d()
{
    return m__d;
}

void UCar_videoDataReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_videoDataReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_videoDataReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_videoDataReceived_Result::result(const UCar_videoDataReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_videoDataReceived_Result::result(UCar_videoDataReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_videoDataReceived_Out& UCar_videoDataReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_videoDataReceived_Out& UCar_videoDataReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_videoDataReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_videoDataReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_videoDataReceived_Result::getCdrSerializedSize(const UCar_videoDataReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_videoDataReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_videoDataReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_videoDataReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_requestGotoHUDesktop_Out::UCar_requestGotoHUDesktop_Out()
: m_dummy(0){
}

UCar_requestGotoHUDesktop_Out::~UCar_requestGotoHUDesktop_Out()
{
}

UCar_requestGotoHUDesktop_Out::UCar_requestGotoHUDesktop_Out(const UCar_requestGotoHUDesktop_Out &x)
: m_dummy(x.m_dummy){
}

UCar_requestGotoHUDesktop_Out::UCar_requestGotoHUDesktop_Out(UCar_requestGotoHUDesktop_Out &&x)
: m_dummy(x.m_dummy){
}

UCar_requestGotoHUDesktop_Out& UCar_requestGotoHUDesktop_Out::operator=(const UCar_requestGotoHUDesktop_Out &x)
{
    m_dummy = x.m_dummy;

    return *this;
}

UCar_requestGotoHUDesktop_Out& UCar_requestGotoHUDesktop_Out::operator=(UCar_requestGotoHUDesktop_Out &&x)
{
    m_dummy = x.m_dummy;

    return *this;
}

size_t UCar_requestGotoHUDesktop_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t UCar_requestGotoHUDesktop_Out::getCdrSerializedSize(const UCar_requestGotoHUDesktop_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void UCar_requestGotoHUDesktop_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void UCar_requestGotoHUDesktop_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

UCar_requestGotoHUDesktop_Result::UCar_requestGotoHUDesktop_Result() : m__d(2)
{
}

UCar_requestGotoHUDesktop_Result::~UCar_requestGotoHUDesktop_Result()
{
}

UCar_requestGotoHUDesktop_Result::UCar_requestGotoHUDesktop_Result(const UCar_requestGotoHUDesktop_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_requestGotoHUDesktop_Result::UCar_requestGotoHUDesktop_Result(UCar_requestGotoHUDesktop_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_requestGotoHUDesktop_Result& UCar_requestGotoHUDesktop_Result::operator=(const UCar_requestGotoHUDesktop_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_requestGotoHUDesktop_Result& UCar_requestGotoHUDesktop_Result::operator=(UCar_requestGotoHUDesktop_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_requestGotoHUDesktop_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_requestGotoHUDesktop_Result::_d() const
{
    return m__d;
}

int32_t& UCar_requestGotoHUDesktop_Result::_d()
{
    return m__d;
}

void UCar_requestGotoHUDesktop_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_requestGotoHUDesktop_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_requestGotoHUDesktop_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_requestGotoHUDesktop_Result::result(const UCar_requestGotoHUDesktop_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_requestGotoHUDesktop_Result::result(UCar_requestGotoHUDesktop_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_requestGotoHUDesktop_Out& UCar_requestGotoHUDesktop_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_requestGotoHUDesktop_Out& UCar_requestGotoHUDesktop_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_requestGotoHUDesktop_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_requestGotoHUDesktop_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_requestGotoHUDesktop_Result::getCdrSerializedSize(const UCar_requestGotoHUDesktop_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_requestGotoHUDesktop_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_requestGotoHUDesktop_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_requestGotoHUDesktop_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_audioStateChanged_Out::UCar_audioStateChanged_Out()
: m_var2(0), m_audioFormat(), m_playerState(0){
}

UCar_audioStateChanged_Out::~UCar_audioStateChanged_Out()
{
}

UCar_audioStateChanged_Out::UCar_audioStateChanged_Out(const UCar_audioStateChanged_Out &x)
: m_var2(x.m_var2), m_audioFormat(x.m_audioFormat), m_playerState(x.m_playerState){
}

UCar_audioStateChanged_Out::UCar_audioStateChanged_Out(UCar_audioStateChanged_Out &&x)
: m_var2(std::move(x.m_var2)), m_audioFormat(std::move(x.m_audioFormat)), m_playerState(std::move(x.m_playerState)){
}

UCar_audioStateChanged_Out& UCar_audioStateChanged_Out::operator=(const UCar_audioStateChanged_Out &x)
{
    m_var2 = x.m_var2;;
    m_audioFormat = x.m_audioFormat;;
    m_playerState = x.m_playerState;;

    return *this;
}

UCar_audioStateChanged_Out& UCar_audioStateChanged_Out::operator=(UCar_audioStateChanged_Out &&x)
{
    m_var2 = x.m_var2;;
    m_audioFormat = x.m_audioFormat;;
    m_playerState = x.m_playerState;;

    return *this;
}

size_t UCar_audioStateChanged_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AudioFormat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t UCar_audioStateChanged_Out::getCdrSerializedSize(const UCar_audioStateChanged_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AudioFormat::getCdrSerializedSize(data.audioFormat(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void UCar_audioStateChanged_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
    scdr << m_audioFormat;
    scdr << m_playerState;
}

void UCar_audioStateChanged_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
    dcdr >> m_audioFormat;
    dcdr >> m_playerState;
}

UCar_audioStateChanged_Result::UCar_audioStateChanged_Result() : m__d(2)
{
}

UCar_audioStateChanged_Result::~UCar_audioStateChanged_Result()
{
}

UCar_audioStateChanged_Result::UCar_audioStateChanged_Result(const UCar_audioStateChanged_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_audioStateChanged_Result::UCar_audioStateChanged_Result(UCar_audioStateChanged_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_audioStateChanged_Result& UCar_audioStateChanged_Result::operator=(const UCar_audioStateChanged_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_audioStateChanged_Result& UCar_audioStateChanged_Result::operator=(UCar_audioStateChanged_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_audioStateChanged_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_audioStateChanged_Result::_d() const
{
    return m__d;
}

int32_t& UCar_audioStateChanged_Result::_d()
{
    return m__d;
}

void UCar_audioStateChanged_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_audioStateChanged_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_audioStateChanged_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_audioStateChanged_Result::result(const UCar_audioStateChanged_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_audioStateChanged_Result::result(UCar_audioStateChanged_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_audioStateChanged_Out& UCar_audioStateChanged_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_audioStateChanged_Out& UCar_audioStateChanged_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_audioStateChanged_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_audioStateChanged_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_audioStateChanged_Result::getCdrSerializedSize(const UCar_audioStateChanged_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_audioStateChanged_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_audioStateChanged_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_audioStateChanged_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_audioDataReceived_Out::UCar_audioDataReceived_Out()
: m_var2(0), m_var3(0), m_var4(){
}

UCar_audioDataReceived_Out::~UCar_audioDataReceived_Out()
{
}

UCar_audioDataReceived_Out::UCar_audioDataReceived_Out(const UCar_audioDataReceived_Out &x)
: m_var2(x.m_var2), m_var3(x.m_var3), m_var4(x.m_var4){
}

UCar_audioDataReceived_Out::UCar_audioDataReceived_Out(UCar_audioDataReceived_Out &&x)
: m_var2(std::move(x.m_var2)), m_var3(std::move(x.m_var3)), m_var4(std::move(x.m_var4)){
}

UCar_audioDataReceived_Out& UCar_audioDataReceived_Out::operator=(const UCar_audioDataReceived_Out &x)
{
    m_var2 = x.m_var2;;
    m_var3 = x.m_var3;;
    m_var4 = x.m_var4;;

    return *this;
}

UCar_audioDataReceived_Out& UCar_audioDataReceived_Out::operator=(UCar_audioDataReceived_Out &&x)
{
    m_var2 = x.m_var2;;
    m_var3 = x.m_var3;;
    m_var4 = x.m_var4;;

    return *this;
}

size_t UCar_audioDataReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (10240 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t UCar_audioDataReceived_Out::getCdrSerializedSize(const UCar_audioDataReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.var4().size() > 0)
    {
        current_alignment += (data.var4().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void UCar_audioDataReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
    scdr << m_var3;
    scdr << m_var4;
}

void UCar_audioDataReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
    dcdr >> m_var3;
    dcdr >> m_var4;
}

UCar_audioDataReceived_Result::UCar_audioDataReceived_Result() : m__d(2)
{
}

UCar_audioDataReceived_Result::~UCar_audioDataReceived_Result()
{
}

UCar_audioDataReceived_Result::UCar_audioDataReceived_Result(const UCar_audioDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_audioDataReceived_Result::UCar_audioDataReceived_Result(UCar_audioDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_audioDataReceived_Result& UCar_audioDataReceived_Result::operator=(const UCar_audioDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_audioDataReceived_Result& UCar_audioDataReceived_Result::operator=(UCar_audioDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_audioDataReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_audioDataReceived_Result::_d() const
{
    return m__d;
}

int32_t& UCar_audioDataReceived_Result::_d()
{
    return m__d;
}

void UCar_audioDataReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_audioDataReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_audioDataReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_audioDataReceived_Result::result(const UCar_audioDataReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_audioDataReceived_Result::result(UCar_audioDataReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_audioDataReceived_Out& UCar_audioDataReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_audioDataReceived_Out& UCar_audioDataReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_audioDataReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_audioDataReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_audioDataReceived_Result::getCdrSerializedSize(const UCar_audioDataReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_audioDataReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_audioDataReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_audioDataReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_musicInfoReceived_Out::UCar_musicInfoReceived_Out()
: m_var2(){
}

UCar_musicInfoReceived_Out::~UCar_musicInfoReceived_Out()
{
}

UCar_musicInfoReceived_Out::UCar_musicInfoReceived_Out(const UCar_musicInfoReceived_Out &x)
: m_var2(x.m_var2){
}

UCar_musicInfoReceived_Out::UCar_musicInfoReceived_Out(UCar_musicInfoReceived_Out &&x)
: m_var2(std::move(x.m_var2)){
}

UCar_musicInfoReceived_Out& UCar_musicInfoReceived_Out::operator=(const UCar_musicInfoReceived_Out &x)
{
    m_var2 = x.m_var2;;

    return *this;
}

UCar_musicInfoReceived_Out& UCar_musicInfoReceived_Out::operator=(UCar_musicInfoReceived_Out &&x)
{
    m_var2 = x.m_var2;;

    return *this;
}

size_t UCar_musicInfoReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += MusicInfo::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t UCar_musicInfoReceived_Out::getCdrSerializedSize(const UCar_musicInfoReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += MusicInfo::getCdrSerializedSize(data.var2(), current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_musicInfoReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
}

void UCar_musicInfoReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
}

UCar_musicInfoReceived_Result::UCar_musicInfoReceived_Result() : m__d(2)
{
}

UCar_musicInfoReceived_Result::~UCar_musicInfoReceived_Result()
{
}

UCar_musicInfoReceived_Result::UCar_musicInfoReceived_Result(const UCar_musicInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_musicInfoReceived_Result::UCar_musicInfoReceived_Result(UCar_musicInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_musicInfoReceived_Result& UCar_musicInfoReceived_Result::operator=(const UCar_musicInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_musicInfoReceived_Result& UCar_musicInfoReceived_Result::operator=(UCar_musicInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_musicInfoReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_musicInfoReceived_Result::_d() const
{
    return m__d;
}

int32_t& UCar_musicInfoReceived_Result::_d()
{
    return m__d;
}

void UCar_musicInfoReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_musicInfoReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_musicInfoReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_musicInfoReceived_Result::result(const UCar_musicInfoReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_musicInfoReceived_Result::result(UCar_musicInfoReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_musicInfoReceived_Out& UCar_musicInfoReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_musicInfoReceived_Out& UCar_musicInfoReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_musicInfoReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_musicInfoReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_musicInfoReceived_Result::getCdrSerializedSize(const UCar_musicInfoReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_musicInfoReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_musicInfoReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_musicInfoReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_navigationInfoReceived_Out::UCar_navigationInfoReceived_Out()
: m_var2(){
}

UCar_navigationInfoReceived_Out::~UCar_navigationInfoReceived_Out()
{
}

UCar_navigationInfoReceived_Out::UCar_navigationInfoReceived_Out(const UCar_navigationInfoReceived_Out &x)
: m_var2(x.m_var2){
}

UCar_navigationInfoReceived_Out::UCar_navigationInfoReceived_Out(UCar_navigationInfoReceived_Out &&x)
: m_var2(std::move(x.m_var2)){
}

UCar_navigationInfoReceived_Out& UCar_navigationInfoReceived_Out::operator=(const UCar_navigationInfoReceived_Out &x)
{
    m_var2 = x.m_var2;;

    return *this;
}

UCar_navigationInfoReceived_Out& UCar_navigationInfoReceived_Out::operator=(UCar_navigationInfoReceived_Out &&x)
{
    m_var2 = x.m_var2;;

    return *this;
}

size_t UCar_navigationInfoReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += NavigationInfo::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t UCar_navigationInfoReceived_Out::getCdrSerializedSize(const UCar_navigationInfoReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += NavigationInfo::getCdrSerializedSize(data.var2(), current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_navigationInfoReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
}

void UCar_navigationInfoReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
}

UCar_navigationInfoReceived_Result::UCar_navigationInfoReceived_Result() : m__d(2)
{
}

UCar_navigationInfoReceived_Result::~UCar_navigationInfoReceived_Result()
{
}

UCar_navigationInfoReceived_Result::UCar_navigationInfoReceived_Result(const UCar_navigationInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_navigationInfoReceived_Result::UCar_navigationInfoReceived_Result(UCar_navigationInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_navigationInfoReceived_Result& UCar_navigationInfoReceived_Result::operator=(const UCar_navigationInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_navigationInfoReceived_Result& UCar_navigationInfoReceived_Result::operator=(UCar_navigationInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_navigationInfoReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_navigationInfoReceived_Result::_d() const
{
    return m__d;
}

int32_t& UCar_navigationInfoReceived_Result::_d()
{
    return m__d;
}

void UCar_navigationInfoReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_navigationInfoReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_navigationInfoReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_navigationInfoReceived_Result::result(const UCar_navigationInfoReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_navigationInfoReceived_Result::result(UCar_navigationInfoReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_navigationInfoReceived_Out& UCar_navigationInfoReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_navigationInfoReceived_Out& UCar_navigationInfoReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_navigationInfoReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_navigationInfoReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_navigationInfoReceived_Result::getCdrSerializedSize(const UCar_navigationInfoReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_navigationInfoReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_navigationInfoReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_navigationInfoReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_phoneStateInfoReceived_Out::UCar_phoneStateInfoReceived_Out()
: m_var2(){
}

UCar_phoneStateInfoReceived_Out::~UCar_phoneStateInfoReceived_Out()
{
}

UCar_phoneStateInfoReceived_Out::UCar_phoneStateInfoReceived_Out(const UCar_phoneStateInfoReceived_Out &x)
: m_var2(x.m_var2){
}

UCar_phoneStateInfoReceived_Out::UCar_phoneStateInfoReceived_Out(UCar_phoneStateInfoReceived_Out &&x)
: m_var2(std::move(x.m_var2)){
}

UCar_phoneStateInfoReceived_Out& UCar_phoneStateInfoReceived_Out::operator=(const UCar_phoneStateInfoReceived_Out &x)
{
    m_var2 = x.m_var2;;

    return *this;
}

UCar_phoneStateInfoReceived_Out& UCar_phoneStateInfoReceived_Out::operator=(UCar_phoneStateInfoReceived_Out &&x)
{
    m_var2 = x.m_var2;;

    return *this;
}

size_t UCar_phoneStateInfoReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += PhoneStateInfo::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t UCar_phoneStateInfoReceived_Out::getCdrSerializedSize(const UCar_phoneStateInfoReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += PhoneStateInfo::getCdrSerializedSize(data.var2(), current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_phoneStateInfoReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
}

void UCar_phoneStateInfoReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
}

UCar_phoneStateInfoReceived_Result::UCar_phoneStateInfoReceived_Result() : m__d(2)
{
}

UCar_phoneStateInfoReceived_Result::~UCar_phoneStateInfoReceived_Result()
{
}

UCar_phoneStateInfoReceived_Result::UCar_phoneStateInfoReceived_Result(const UCar_phoneStateInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_phoneStateInfoReceived_Result::UCar_phoneStateInfoReceived_Result(UCar_phoneStateInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_phoneStateInfoReceived_Result& UCar_phoneStateInfoReceived_Result::operator=(const UCar_phoneStateInfoReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_phoneStateInfoReceived_Result& UCar_phoneStateInfoReceived_Result::operator=(UCar_phoneStateInfoReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_phoneStateInfoReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_phoneStateInfoReceived_Result::_d() const
{
    return m__d;
}

int32_t& UCar_phoneStateInfoReceived_Result::_d()
{
    return m__d;
}

void UCar_phoneStateInfoReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_phoneStateInfoReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_phoneStateInfoReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_phoneStateInfoReceived_Result::result(const UCar_phoneStateInfoReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_phoneStateInfoReceived_Result::result(UCar_phoneStateInfoReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_phoneStateInfoReceived_Out& UCar_phoneStateInfoReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_phoneStateInfoReceived_Out& UCar_phoneStateInfoReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_phoneStateInfoReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_phoneStateInfoReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_phoneStateInfoReceived_Result::getCdrSerializedSize(const UCar_phoneStateInfoReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_phoneStateInfoReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_phoneStateInfoReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_phoneStateInfoReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_micRecordRequest_Out::UCar_micRecordRequest_Out()
: m_var2(), m_var3(false){
}

UCar_micRecordRequest_Out::~UCar_micRecordRequest_Out()
{
}

UCar_micRecordRequest_Out::UCar_micRecordRequest_Out(const UCar_micRecordRequest_Out &x)
: m_var2(x.m_var2), m_var3(x.m_var3){
}

UCar_micRecordRequest_Out::UCar_micRecordRequest_Out(UCar_micRecordRequest_Out &&x)
: m_var2(std::move(x.m_var2)), m_var3(std::move(x.m_var3)){
}

UCar_micRecordRequest_Out& UCar_micRecordRequest_Out::operator=(const UCar_micRecordRequest_Out &x)
{
    m_var2 = x.m_var2;;
    m_var3 = x.m_var3;;

    return *this;
}

UCar_micRecordRequest_Out& UCar_micRecordRequest_Out::operator=(UCar_micRecordRequest_Out &&x)
{
    m_var2 = x.m_var2;;
    m_var3 = x.m_var3;;

    return *this;
}

size_t UCar_micRecordRequest_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AudioFormat::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t UCar_micRecordRequest_Out::getCdrSerializedSize(const UCar_micRecordRequest_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += AudioFormat::getCdrSerializedSize(data.var2(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void UCar_micRecordRequest_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_var2;
    scdr << m_var3;
}

void UCar_micRecordRequest_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_var2;
    dcdr >> m_var3;
}

UCar_micRecordRequest_Result::UCar_micRecordRequest_Result() : m__d(2)
{
}

UCar_micRecordRequest_Result::~UCar_micRecordRequest_Result()
{
}

UCar_micRecordRequest_Result::UCar_micRecordRequest_Result(const UCar_micRecordRequest_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_micRecordRequest_Result::UCar_micRecordRequest_Result(UCar_micRecordRequest_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_micRecordRequest_Result& UCar_micRecordRequest_Result::operator=(const UCar_micRecordRequest_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_micRecordRequest_Result& UCar_micRecordRequest_Result::operator=(UCar_micRecordRequest_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_micRecordRequest_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_micRecordRequest_Result::_d() const
{
    return m__d;
}

int32_t& UCar_micRecordRequest_Result::_d()
{
    return m__d;
}

void UCar_micRecordRequest_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_micRecordRequest_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_micRecordRequest_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_micRecordRequest_Result::result(const UCar_micRecordRequest_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_micRecordRequest_Result::result(UCar_micRecordRequest_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_micRecordRequest_Out& UCar_micRecordRequest_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_micRecordRequest_Out& UCar_micRecordRequest_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_micRecordRequest_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_micRecordRequest_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_micRecordRequest_Result::getCdrSerializedSize(const UCar_micRecordRequest_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_micRecordRequest_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_micRecordRequest_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_micRecordRequest_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_userInterventionNeeded_Out::UCar_userInterventionNeeded_Out()
: m_dummy(0){
}

UCar_userInterventionNeeded_Out::~UCar_userInterventionNeeded_Out()
{
}

UCar_userInterventionNeeded_Out::UCar_userInterventionNeeded_Out(const UCar_userInterventionNeeded_Out &x)
: m_dummy(x.m_dummy){
}

UCar_userInterventionNeeded_Out::UCar_userInterventionNeeded_Out(UCar_userInterventionNeeded_Out &&x)
: m_dummy(x.m_dummy){
}

UCar_userInterventionNeeded_Out& UCar_userInterventionNeeded_Out::operator=(const UCar_userInterventionNeeded_Out &x)
{
    m_dummy = x.m_dummy;

    return *this;
}

UCar_userInterventionNeeded_Out& UCar_userInterventionNeeded_Out::operator=(UCar_userInterventionNeeded_Out &&x)
{
    m_dummy = x.m_dummy;

    return *this;
}

size_t UCar_userInterventionNeeded_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t UCar_userInterventionNeeded_Out::getCdrSerializedSize(const UCar_userInterventionNeeded_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void UCar_userInterventionNeeded_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void UCar_userInterventionNeeded_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

UCar_userInterventionNeeded_Result::UCar_userInterventionNeeded_Result() : m__d(2)
{
}

UCar_userInterventionNeeded_Result::~UCar_userInterventionNeeded_Result()
{
}

UCar_userInterventionNeeded_Result::UCar_userInterventionNeeded_Result(const UCar_userInterventionNeeded_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

UCar_userInterventionNeeded_Result::UCar_userInterventionNeeded_Result(UCar_userInterventionNeeded_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

UCar_userInterventionNeeded_Result& UCar_userInterventionNeeded_Result::operator=(const UCar_userInterventionNeeded_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

UCar_userInterventionNeeded_Result& UCar_userInterventionNeeded_Result::operator=(UCar_userInterventionNeeded_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void UCar_userInterventionNeeded_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_userInterventionNeeded_Result::_d() const
{
    return m__d;
}

int32_t& UCar_userInterventionNeeded_Result::_d()
{
    return m__d;
}

void UCar_userInterventionNeeded_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException UCar_userInterventionNeeded_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& UCar_userInterventionNeeded_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void UCar_userInterventionNeeded_Result::result(const UCar_userInterventionNeeded_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void UCar_userInterventionNeeded_Result::result(UCar_userInterventionNeeded_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const UCar_userInterventionNeeded_Out& UCar_userInterventionNeeded_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

UCar_userInterventionNeeded_Out& UCar_userInterventionNeeded_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t UCar_userInterventionNeeded_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += UCar_userInterventionNeeded_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t UCar_userInterventionNeeded_Result::getCdrSerializedSize(const UCar_userInterventionNeeded_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += UCar_userInterventionNeeded_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void UCar_userInterventionNeeded_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void UCar_userInterventionNeeded_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


UCar_Call::UCar_Call() : m__d(0)
{
}

UCar_Call::~UCar_Call()
{
}

UCar_Call::UCar_Call(const UCar_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = x.m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = x.m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = x.m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = x.m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = x.m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = x.m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = x.m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = x.m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = x.m_presetConnectMode;
                    break;
                
                
                
                
                
                
                
                
                
                
                
    }
}

UCar_Call::UCar_Call(UCar_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = std::move(x.m_sendMicRecordData);
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = std::move(x.m_sendKeyEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = std::move(x.m_sendGotoBackground);
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = std::move(x.m_sendVRCMD);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = std::move(x.m_notifyIsCallHungUp);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = std::move(x.m_notifySwitchDayOrNight);
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = std::move(x.m_awakenVoiceAssistant);
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = std::move(x.m_presetVendorCustomFields);
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = std::move(x.m_presetConnectMode);
                    break;
                
                
                
                
                
                
                
                
                
                
                
    }
}

UCar_Call& UCar_Call::operator=(const UCar_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = x.m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = x.m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = x.m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = x.m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = x.m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = x.m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = x.m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = x.m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = x.m_presetConnectMode;
                    break;
                
                
                
                
                
                
                
                
                
                
                
    }
    
    return *this;
}

UCar_Call& UCar_Call::operator=(UCar_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = std::move(x.m_sendMicRecordData);
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = std::move(x.m_sendKeyEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = std::move(x.m_sendGotoBackground);
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = std::move(x.m_sendVRCMD);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = std::move(x.m_notifyIsCallHungUp);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = std::move(x.m_notifySwitchDayOrNight);
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = std::move(x.m_awakenVoiceAssistant);
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = std::move(x.m_presetVendorCustomFields);
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = std::move(x.m_presetConnectMode);
                    break;
                
                
                
                
                
                
                
                
                
                
                
    }
    
    return *this;
}

void UCar_Call::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_Call::_d() const
{
    return m__d;
}

int32_t& UCar_Call::_d()
{
    return m__d;
}

void UCar_Call::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp)
{
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation UCar_Call::unknownOp() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation& UCar_Call::unknownOp()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

void UCar_Call::sendTouchEvent(const UCar_sendTouchEvent_In &_sendTouchEvent)
{
    m_sendTouchEvent = _sendTouchEvent;
    m__d = (int32_t)0x81D4B2D7;
}

void UCar_Call::sendTouchEvent(UCar_sendTouchEvent_In &&_sendTouchEvent)
{
    m_sendTouchEvent = std::move(_sendTouchEvent);
    m__d = (int32_t)0x81D4B2D7;
}

const UCar_sendTouchEvent_In& UCar_Call::sendTouchEvent() const
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

UCar_sendTouchEvent_In& UCar_Call::sendTouchEvent()
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}
void UCar_Call::sendMicRecordData(const UCar_sendMicRecordData_In &_sendMicRecordData)
{
    m_sendMicRecordData = _sendMicRecordData;
    m__d = (int32_t)0xD727D4CE;
}

void UCar_Call::sendMicRecordData(UCar_sendMicRecordData_In &&_sendMicRecordData)
{
    m_sendMicRecordData = std::move(_sendMicRecordData);
    m__d = (int32_t)0xD727D4CE;
}

const UCar_sendMicRecordData_In& UCar_Call::sendMicRecordData() const
{
    if(m__d != (int32_t)0xD727D4CE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendMicRecordData;
}

UCar_sendMicRecordData_In& UCar_Call::sendMicRecordData()
{
    if(m__d != (int32_t)0xD727D4CE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendMicRecordData;
}
void UCar_Call::sendKeyEvent(const UCar_sendKeyEvent_In &_sendKeyEvent)
{
    m_sendKeyEvent = _sendKeyEvent;
    m__d = (int32_t)0x44278473;
}

void UCar_Call::sendKeyEvent(UCar_sendKeyEvent_In &&_sendKeyEvent)
{
    m_sendKeyEvent = std::move(_sendKeyEvent);
    m__d = (int32_t)0x44278473;
}

const UCar_sendKeyEvent_In& UCar_Call::sendKeyEvent() const
{
    if(m__d != (int32_t)0x44278473)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendKeyEvent;
}

UCar_sendKeyEvent_In& UCar_Call::sendKeyEvent()
{
    if(m__d != (int32_t)0x44278473)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendKeyEvent;
}
void UCar_Call::sendGotoForeground(const UCar_sendGotoForeground_In &_sendGotoForeground)
{
    m_sendGotoForeground = _sendGotoForeground;
    m__d = (int32_t)0x5C709BCF;
}

void UCar_Call::sendGotoForeground(UCar_sendGotoForeground_In &&_sendGotoForeground)
{
    m_sendGotoForeground = std::move(_sendGotoForeground);
    m__d = (int32_t)0x5C709BCF;
}

const UCar_sendGotoForeground_In& UCar_Call::sendGotoForeground() const
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

UCar_sendGotoForeground_In& UCar_Call::sendGotoForeground()
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}
void UCar_Call::sendGotoBackground(const UCar_sendGotoBackground_In &_sendGotoBackground)
{
    m_sendGotoBackground = _sendGotoBackground;
    m__d = (int32_t)0x57CBA9AE;
}

void UCar_Call::sendGotoBackground(UCar_sendGotoBackground_In &&_sendGotoBackground)
{
    m_sendGotoBackground = std::move(_sendGotoBackground);
    m__d = (int32_t)0x57CBA9AE;
}

const UCar_sendGotoBackground_In& UCar_Call::sendGotoBackground() const
{
    if(m__d != (int32_t)0x57CBA9AE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoBackground;
}

UCar_sendGotoBackground_In& UCar_Call::sendGotoBackground()
{
    if(m__d != (int32_t)0x57CBA9AE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoBackground;
}
void UCar_Call::sendVRCMD(const UCar_sendVRCMD_In &_sendVRCMD)
{
    m_sendVRCMD = _sendVRCMD;
    m__d = (int32_t)0x873F597B;
}

void UCar_Call::sendVRCMD(UCar_sendVRCMD_In &&_sendVRCMD)
{
    m_sendVRCMD = std::move(_sendVRCMD);
    m__d = (int32_t)0x873F597B;
}

const UCar_sendVRCMD_In& UCar_Call::sendVRCMD() const
{
    if(m__d != (int32_t)0x873F597B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendVRCMD;
}

UCar_sendVRCMD_In& UCar_Call::sendVRCMD()
{
    if(m__d != (int32_t)0x873F597B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendVRCMD;
}
void UCar_Call::notifyIsCallHungUp(const UCar_notifyIsCallHungUp_In &_notifyIsCallHungUp)
{
    m_notifyIsCallHungUp = _notifyIsCallHungUp;
    m__d = (int32_t)0xA5D0AE3A;
}

void UCar_Call::notifyIsCallHungUp(UCar_notifyIsCallHungUp_In &&_notifyIsCallHungUp)
{
    m_notifyIsCallHungUp = std::move(_notifyIsCallHungUp);
    m__d = (int32_t)0xA5D0AE3A;
}

const UCar_notifyIsCallHungUp_In& UCar_Call::notifyIsCallHungUp() const
{
    if(m__d != (int32_t)0xA5D0AE3A)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifyIsCallHungUp;
}

UCar_notifyIsCallHungUp_In& UCar_Call::notifyIsCallHungUp()
{
    if(m__d != (int32_t)0xA5D0AE3A)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifyIsCallHungUp;
}
void UCar_Call::notifySwitchDayOrNight(const UCar_notifySwitchDayOrNight_In &_notifySwitchDayOrNight)
{
    m_notifySwitchDayOrNight = _notifySwitchDayOrNight;
    m__d = (int32_t)0x8ED99DB4;
}

void UCar_Call::notifySwitchDayOrNight(UCar_notifySwitchDayOrNight_In &&_notifySwitchDayOrNight)
{
    m_notifySwitchDayOrNight = std::move(_notifySwitchDayOrNight);
    m__d = (int32_t)0x8ED99DB4;
}

const UCar_notifySwitchDayOrNight_In& UCar_Call::notifySwitchDayOrNight() const
{
    if(m__d != (int32_t)0x8ED99DB4)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifySwitchDayOrNight;
}

UCar_notifySwitchDayOrNight_In& UCar_Call::notifySwitchDayOrNight()
{
    if(m__d != (int32_t)0x8ED99DB4)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifySwitchDayOrNight;
}
void UCar_Call::awakenVoiceAssistant(const UCar_awakenVoiceAssistant_In &_awakenVoiceAssistant)
{
    m_awakenVoiceAssistant = _awakenVoiceAssistant;
    m__d = (int32_t)0x1B523A37;
}

void UCar_Call::awakenVoiceAssistant(UCar_awakenVoiceAssistant_In &&_awakenVoiceAssistant)
{
    m_awakenVoiceAssistant = std::move(_awakenVoiceAssistant);
    m__d = (int32_t)0x1B523A37;
}

const UCar_awakenVoiceAssistant_In& UCar_Call::awakenVoiceAssistant() const
{
    if(m__d != (int32_t)0x1B523A37)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_awakenVoiceAssistant;
}

UCar_awakenVoiceAssistant_In& UCar_Call::awakenVoiceAssistant()
{
    if(m__d != (int32_t)0x1B523A37)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_awakenVoiceAssistant;
}
void UCar_Call::presetVendorCustomFields(const UCar_presetVendorCustomFields_In &_presetVendorCustomFields)
{
    m_presetVendorCustomFields = _presetVendorCustomFields;
    m__d = (int32_t)0x68A2963D;
}

void UCar_Call::presetVendorCustomFields(UCar_presetVendorCustomFields_In &&_presetVendorCustomFields)
{
    m_presetVendorCustomFields = std::move(_presetVendorCustomFields);
    m__d = (int32_t)0x68A2963D;
}

const UCar_presetVendorCustomFields_In& UCar_Call::presetVendorCustomFields() const
{
    if(m__d != (int32_t)0x68A2963D)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetVendorCustomFields;
}

UCar_presetVendorCustomFields_In& UCar_Call::presetVendorCustomFields()
{
    if(m__d != (int32_t)0x68A2963D)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetVendorCustomFields;
}
void UCar_Call::presetConnectMode(const UCar_presetConnectMode_In &_presetConnectMode)
{
    m_presetConnectMode = _presetConnectMode;
    m__d = (int32_t)0x24914CCE;
}

void UCar_Call::presetConnectMode(UCar_presetConnectMode_In &&_presetConnectMode)
{
    m_presetConnectMode = std::move(_presetConnectMode);
    m__d = (int32_t)0x24914CCE;
}

const UCar_presetConnectMode_In& UCar_Call::presetConnectMode() const
{
    if(m__d != (int32_t)0x24914CCE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetConnectMode;
}

UCar_presetConnectMode_In& UCar_Call::presetConnectMode()
{
    if(m__d != (int32_t)0x24914CCE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetConnectMode;
}











size_t UCar_Call::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknownOp attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += UCar_sendTouchEvent_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendMicRecordData_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendKeyEvent_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendGotoForeground_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendGotoBackground_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendVRCMD_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_notifyIsCallHungUp_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_notifySwitchDayOrNight_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_awakenVoiceAssistant_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_presetVendorCustomFields_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_presetConnectMode_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        
        
        
        
        
        
        
        
        
        

    return union_max_size_serialized - initial_alignment;
}

size_t UCar_Call::getCdrSerializedSize(const UCar_Call& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
                case (int32_t)0x81D4B2D7:
                    current_alignment += UCar_sendTouchEvent_In::getCdrSerializedSize(data.m_sendTouchEvent, current_alignment);
                    break;
                
                case (int32_t)0xD727D4CE:
                    current_alignment += UCar_sendMicRecordData_In::getCdrSerializedSize(data.m_sendMicRecordData, current_alignment);
                    break;
                
                case (int32_t)0x44278473:
                    current_alignment += UCar_sendKeyEvent_In::getCdrSerializedSize(data.m_sendKeyEvent, current_alignment);
                    break;
                
                case (int32_t)0x5C709BCF:
                    current_alignment += UCar_sendGotoForeground_In::getCdrSerializedSize(data.m_sendGotoForeground, current_alignment);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    current_alignment += UCar_sendGotoBackground_In::getCdrSerializedSize(data.m_sendGotoBackground, current_alignment);
                    break;
                
                case (int32_t)0x873F597B:
                    current_alignment += UCar_sendVRCMD_In::getCdrSerializedSize(data.m_sendVRCMD, current_alignment);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    current_alignment += UCar_notifyIsCallHungUp_In::getCdrSerializedSize(data.m_notifyIsCallHungUp, current_alignment);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    current_alignment += UCar_notifySwitchDayOrNight_In::getCdrSerializedSize(data.m_notifySwitchDayOrNight, current_alignment);
                    break;
                
                case (int32_t)0x1B523A37:
                    current_alignment += UCar_awakenVoiceAssistant_In::getCdrSerializedSize(data.m_awakenVoiceAssistant, current_alignment);
                    break;
                
                case (int32_t)0x68A2963D:
                    current_alignment += UCar_presetVendorCustomFields_In::getCdrSerializedSize(data.m_presetVendorCustomFields, current_alignment);
                    break;
                
                case (int32_t)0x24914CCE:
                    current_alignment += UCar_presetConnectMode_In::getCdrSerializedSize(data.m_presetConnectMode, current_alignment);
                    break;
                
                
                
                
                
                
                
                
                
                
                
    }

    return current_alignment - initial_alignment;
}

void UCar_Call::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    scdr << m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    scdr << m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    scdr << m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    scdr << m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    scdr << m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    scdr << m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    scdr << m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    scdr << m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    scdr << m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    scdr << m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    scdr << m_presetConnectMode;
                    break;
                
                
                
                
                
                
                
                
                
                
                
        default:
            scdr << m_unknownOp;
            break;
    }
}

void UCar_Call::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    dcdr >> m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    dcdr >> m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    dcdr >> m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    dcdr >> m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    dcdr >> m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    dcdr >> m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    dcdr >> m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    dcdr >> m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    dcdr >> m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    dcdr >> m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    dcdr >> m_presetConnectMode;
                    break;
                
                
                
                
                
                
                
                
                
                
                
        default:
            dcdr >> m_unknownOp;
            break;
    }
}

UCar_Request::UCar_Request()
{
}

UCar_Request::~UCar_Request()
{
}

UCar_Request::UCar_Request(const UCar_Request &x)
: m_header(x.m_header), m_data(x.m_data)
{
}

UCar_Request::UCar_Request(UCar_Request &&x)
: m_header(std::move(x.m_header)), m_data(std::move(x.m_data))
{
}

UCar_Request& UCar_Request::operator=(const UCar_Request &x)
{
    m_header = x.m_header;
    m_data = x.m_data;
    
    return *this;
}

UCar_Request& UCar_Request::operator=(UCar_Request &&x)
{
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t UCar_Request::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment +=  eprosima::rpc::protocol::dds::rpc::RequestHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += UCar_Call::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t UCar_Request::getCdrSerializedSize(const UCar_Request& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += UCar_Call::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_Request::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_data;
}

void UCar_Request::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_data;
}

UCar_Return::UCar_Return() : m__d(0)
{
}

UCar_Return::~UCar_Return()
{
}

UCar_Return::UCar_Return(const UCar_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = x.m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = x.m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = x.m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = x.m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = x.m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = x.m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = x.m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = x.m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = x.m_presetConnectMode;
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = x.m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = x.m_videoDataReceived;
                    break;
                
                case (int32_t)0xB9DBD217:
                    m_requestGotoHUDesktop = x.m_requestGotoHUDesktop;
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    m_audioStateChanged = x.m_audioStateChanged;
                    break;
                
                case (int32_t)0x1FCD31F5:
                    m_audioDataReceived = x.m_audioDataReceived;
                    break;
                
                case (int32_t)0x984FF8BF:
                    m_musicInfoReceived = x.m_musicInfoReceived;
                    break;
                
                case (int32_t)0xCADE4888:
                    m_navigationInfoReceived = x.m_navigationInfoReceived;
                    break;
                
                case (int32_t)0x2F2D8A67:
                    m_phoneStateInfoReceived = x.m_phoneStateInfoReceived;
                    break;
                
                case (int32_t)0xF58271B2:
                    m_micRecordRequest = x.m_micRecordRequest;
                    break;
                
                case (int32_t)0x2F189293:
                    m_userInterventionNeeded = x.m_userInterventionNeeded;
                    break;
                
    }
}

UCar_Return::UCar_Return(UCar_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = std::move(x.m_sendMicRecordData);
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = std::move(x.m_sendKeyEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = std::move(x.m_sendGotoBackground);
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = std::move(x.m_sendVRCMD);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = std::move(x.m_notifyIsCallHungUp);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = std::move(x.m_notifySwitchDayOrNight);
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = std::move(x.m_awakenVoiceAssistant);
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = std::move(x.m_presetVendorCustomFields);
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = std::move(x.m_presetConnectMode);
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = std::move(x.m_videoInitialized);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = std::move(x.m_videoDataReceived);
                    break;
                
                case (int32_t)0xB9DBD217:
                    m_requestGotoHUDesktop = std::move(x.m_requestGotoHUDesktop);
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    m_audioStateChanged = std::move(x.m_audioStateChanged);
                    break;
                
                case (int32_t)0x1FCD31F5:
                    m_audioDataReceived = std::move(x.m_audioDataReceived);
                    break;
                
                case (int32_t)0x984FF8BF:
                    m_musicInfoReceived = std::move(x.m_musicInfoReceived);
                    break;
                
                case (int32_t)0xCADE4888:
                    m_navigationInfoReceived = std::move(x.m_navigationInfoReceived);
                    break;
                
                case (int32_t)0x2F2D8A67:
                    m_phoneStateInfoReceived = std::move(x.m_phoneStateInfoReceived);
                    break;
                
                case (int32_t)0xF58271B2:
                    m_micRecordRequest = std::move(x.m_micRecordRequest);
                    break;
                
                case (int32_t)0x2F189293:
                    m_userInterventionNeeded = std::move(x.m_userInterventionNeeded);
                    break;
                
    }
}

UCar_Return& UCar_Return::operator=(const UCar_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = x.m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = x.m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = x.m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = x.m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = x.m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = x.m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = x.m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = x.m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = x.m_presetConnectMode;
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = x.m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = x.m_videoDataReceived;
                    break;
                
                case (int32_t)0xB9DBD217:
                    m_requestGotoHUDesktop = x.m_requestGotoHUDesktop;
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    m_audioStateChanged = x.m_audioStateChanged;
                    break;
                
                case (int32_t)0x1FCD31F5:
                    m_audioDataReceived = x.m_audioDataReceived;
                    break;
                
                case (int32_t)0x984FF8BF:
                    m_musicInfoReceived = x.m_musicInfoReceived;
                    break;
                
                case (int32_t)0xCADE4888:
                    m_navigationInfoReceived = x.m_navigationInfoReceived;
                    break;
                
                case (int32_t)0x2F2D8A67:
                    m_phoneStateInfoReceived = x.m_phoneStateInfoReceived;
                    break;
                
                case (int32_t)0xF58271B2:
                    m_micRecordRequest = x.m_micRecordRequest;
                    break;
                
                case (int32_t)0x2F189293:
                    m_userInterventionNeeded = x.m_userInterventionNeeded;
                    break;
                
    }
    
    return *this;
}

UCar_Return& UCar_Return::operator=(UCar_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0xD727D4CE:
                    m_sendMicRecordData = std::move(x.m_sendMicRecordData);
                    break;
                
                case (int32_t)0x44278473:
                    m_sendKeyEvent = std::move(x.m_sendKeyEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    m_sendGotoBackground = std::move(x.m_sendGotoBackground);
                    break;
                
                case (int32_t)0x873F597B:
                    m_sendVRCMD = std::move(x.m_sendVRCMD);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    m_notifyIsCallHungUp = std::move(x.m_notifyIsCallHungUp);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    m_notifySwitchDayOrNight = std::move(x.m_notifySwitchDayOrNight);
                    break;
                
                case (int32_t)0x1B523A37:
                    m_awakenVoiceAssistant = std::move(x.m_awakenVoiceAssistant);
                    break;
                
                case (int32_t)0x68A2963D:
                    m_presetVendorCustomFields = std::move(x.m_presetVendorCustomFields);
                    break;
                
                case (int32_t)0x24914CCE:
                    m_presetConnectMode = std::move(x.m_presetConnectMode);
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = std::move(x.m_videoInitialized);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = std::move(x.m_videoDataReceived);
                    break;
                
                case (int32_t)0xB9DBD217:
                    m_requestGotoHUDesktop = std::move(x.m_requestGotoHUDesktop);
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    m_audioStateChanged = std::move(x.m_audioStateChanged);
                    break;
                
                case (int32_t)0x1FCD31F5:
                    m_audioDataReceived = std::move(x.m_audioDataReceived);
                    break;
                
                case (int32_t)0x984FF8BF:
                    m_musicInfoReceived = std::move(x.m_musicInfoReceived);
                    break;
                
                case (int32_t)0xCADE4888:
                    m_navigationInfoReceived = std::move(x.m_navigationInfoReceived);
                    break;
                
                case (int32_t)0x2F2D8A67:
                    m_phoneStateInfoReceived = std::move(x.m_phoneStateInfoReceived);
                    break;
                
                case (int32_t)0xF58271B2:
                    m_micRecordRequest = std::move(x.m_micRecordRequest);
                    break;
                
                case (int32_t)0x2F189293:
                    m_userInterventionNeeded = std::move(x.m_userInterventionNeeded);
                    break;
                
    }
    
    return *this;
}

void UCar_Return::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t UCar_Return::_d() const
{
    return m__d;
}

int32_t& UCar_Return::_d()
{
    return m__d;
}

void UCar_Return::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp)
{
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation UCar_Return::unknownOp() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation& UCar_Return::unknownOp()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

void UCar_Return::sendTouchEvent(const UCar_sendTouchEvent_Result &_sendTouchEvent)
{
    m_sendTouchEvent = _sendTouchEvent;
    m__d = (int32_t)0x81D4B2D7;
}

void UCar_Return::sendTouchEvent(UCar_sendTouchEvent_Result &&_sendTouchEvent)
{
    m_sendTouchEvent = std::move(_sendTouchEvent);
    m__d = (int32_t)0x81D4B2D7;
}

const UCar_sendTouchEvent_Result& UCar_Return::sendTouchEvent() const
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

UCar_sendTouchEvent_Result& UCar_Return::sendTouchEvent()
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

void UCar_Return::sendMicRecordData(const UCar_sendMicRecordData_Result &_sendMicRecordData)
{
    m_sendMicRecordData = _sendMicRecordData;
    m__d = (int32_t)0xD727D4CE;
}

void UCar_Return::sendMicRecordData(UCar_sendMicRecordData_Result &&_sendMicRecordData)
{
    m_sendMicRecordData = std::move(_sendMicRecordData);
    m__d = (int32_t)0xD727D4CE;
}

const UCar_sendMicRecordData_Result& UCar_Return::sendMicRecordData() const
{
    if(m__d != (int32_t)0xD727D4CE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendMicRecordData;
}

UCar_sendMicRecordData_Result& UCar_Return::sendMicRecordData()
{
    if(m__d != (int32_t)0xD727D4CE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendMicRecordData;
}

void UCar_Return::sendKeyEvent(const UCar_sendKeyEvent_Result &_sendKeyEvent)
{
    m_sendKeyEvent = _sendKeyEvent;
    m__d = (int32_t)0x44278473;
}

void UCar_Return::sendKeyEvent(UCar_sendKeyEvent_Result &&_sendKeyEvent)
{
    m_sendKeyEvent = std::move(_sendKeyEvent);
    m__d = (int32_t)0x44278473;
}

const UCar_sendKeyEvent_Result& UCar_Return::sendKeyEvent() const
{
    if(m__d != (int32_t)0x44278473)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendKeyEvent;
}

UCar_sendKeyEvent_Result& UCar_Return::sendKeyEvent()
{
    if(m__d != (int32_t)0x44278473)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendKeyEvent;
}

void UCar_Return::sendGotoForeground(const UCar_sendGotoForeground_Result &_sendGotoForeground)
{
    m_sendGotoForeground = _sendGotoForeground;
    m__d = (int32_t)0x5C709BCF;
}

void UCar_Return::sendGotoForeground(UCar_sendGotoForeground_Result &&_sendGotoForeground)
{
    m_sendGotoForeground = std::move(_sendGotoForeground);
    m__d = (int32_t)0x5C709BCF;
}

const UCar_sendGotoForeground_Result& UCar_Return::sendGotoForeground() const
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

UCar_sendGotoForeground_Result& UCar_Return::sendGotoForeground()
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

void UCar_Return::sendGotoBackground(const UCar_sendGotoBackground_Result &_sendGotoBackground)
{
    m_sendGotoBackground = _sendGotoBackground;
    m__d = (int32_t)0x57CBA9AE;
}

void UCar_Return::sendGotoBackground(UCar_sendGotoBackground_Result &&_sendGotoBackground)
{
    m_sendGotoBackground = std::move(_sendGotoBackground);
    m__d = (int32_t)0x57CBA9AE;
}

const UCar_sendGotoBackground_Result& UCar_Return::sendGotoBackground() const
{
    if(m__d != (int32_t)0x57CBA9AE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoBackground;
}

UCar_sendGotoBackground_Result& UCar_Return::sendGotoBackground()
{
    if(m__d != (int32_t)0x57CBA9AE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoBackground;
}

void UCar_Return::sendVRCMD(const UCar_sendVRCMD_Result &_sendVRCMD)
{
    m_sendVRCMD = _sendVRCMD;
    m__d = (int32_t)0x873F597B;
}

void UCar_Return::sendVRCMD(UCar_sendVRCMD_Result &&_sendVRCMD)
{
    m_sendVRCMD = std::move(_sendVRCMD);
    m__d = (int32_t)0x873F597B;
}

const UCar_sendVRCMD_Result& UCar_Return::sendVRCMD() const
{
    if(m__d != (int32_t)0x873F597B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendVRCMD;
}

UCar_sendVRCMD_Result& UCar_Return::sendVRCMD()
{
    if(m__d != (int32_t)0x873F597B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendVRCMD;
}

void UCar_Return::notifyIsCallHungUp(const UCar_notifyIsCallHungUp_Result &_notifyIsCallHungUp)
{
    m_notifyIsCallHungUp = _notifyIsCallHungUp;
    m__d = (int32_t)0xA5D0AE3A;
}

void UCar_Return::notifyIsCallHungUp(UCar_notifyIsCallHungUp_Result &&_notifyIsCallHungUp)
{
    m_notifyIsCallHungUp = std::move(_notifyIsCallHungUp);
    m__d = (int32_t)0xA5D0AE3A;
}

const UCar_notifyIsCallHungUp_Result& UCar_Return::notifyIsCallHungUp() const
{
    if(m__d != (int32_t)0xA5D0AE3A)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifyIsCallHungUp;
}

UCar_notifyIsCallHungUp_Result& UCar_Return::notifyIsCallHungUp()
{
    if(m__d != (int32_t)0xA5D0AE3A)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifyIsCallHungUp;
}

void UCar_Return::notifySwitchDayOrNight(const UCar_notifySwitchDayOrNight_Result &_notifySwitchDayOrNight)
{
    m_notifySwitchDayOrNight = _notifySwitchDayOrNight;
    m__d = (int32_t)0x8ED99DB4;
}

void UCar_Return::notifySwitchDayOrNight(UCar_notifySwitchDayOrNight_Result &&_notifySwitchDayOrNight)
{
    m_notifySwitchDayOrNight = std::move(_notifySwitchDayOrNight);
    m__d = (int32_t)0x8ED99DB4;
}

const UCar_notifySwitchDayOrNight_Result& UCar_Return::notifySwitchDayOrNight() const
{
    if(m__d != (int32_t)0x8ED99DB4)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifySwitchDayOrNight;
}

UCar_notifySwitchDayOrNight_Result& UCar_Return::notifySwitchDayOrNight()
{
    if(m__d != (int32_t)0x8ED99DB4)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_notifySwitchDayOrNight;
}

void UCar_Return::awakenVoiceAssistant(const UCar_awakenVoiceAssistant_Result &_awakenVoiceAssistant)
{
    m_awakenVoiceAssistant = _awakenVoiceAssistant;
    m__d = (int32_t)0x1B523A37;
}

void UCar_Return::awakenVoiceAssistant(UCar_awakenVoiceAssistant_Result &&_awakenVoiceAssistant)
{
    m_awakenVoiceAssistant = std::move(_awakenVoiceAssistant);
    m__d = (int32_t)0x1B523A37;
}

const UCar_awakenVoiceAssistant_Result& UCar_Return::awakenVoiceAssistant() const
{
    if(m__d != (int32_t)0x1B523A37)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_awakenVoiceAssistant;
}

UCar_awakenVoiceAssistant_Result& UCar_Return::awakenVoiceAssistant()
{
    if(m__d != (int32_t)0x1B523A37)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_awakenVoiceAssistant;
}

void UCar_Return::presetVendorCustomFields(const UCar_presetVendorCustomFields_Result &_presetVendorCustomFields)
{
    m_presetVendorCustomFields = _presetVendorCustomFields;
    m__d = (int32_t)0x68A2963D;
}

void UCar_Return::presetVendorCustomFields(UCar_presetVendorCustomFields_Result &&_presetVendorCustomFields)
{
    m_presetVendorCustomFields = std::move(_presetVendorCustomFields);
    m__d = (int32_t)0x68A2963D;
}

const UCar_presetVendorCustomFields_Result& UCar_Return::presetVendorCustomFields() const
{
    if(m__d != (int32_t)0x68A2963D)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetVendorCustomFields;
}

UCar_presetVendorCustomFields_Result& UCar_Return::presetVendorCustomFields()
{
    if(m__d != (int32_t)0x68A2963D)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetVendorCustomFields;
}

void UCar_Return::presetConnectMode(const UCar_presetConnectMode_Result &_presetConnectMode)
{
    m_presetConnectMode = _presetConnectMode;
    m__d = (int32_t)0x24914CCE;
}

void UCar_Return::presetConnectMode(UCar_presetConnectMode_Result &&_presetConnectMode)
{
    m_presetConnectMode = std::move(_presetConnectMode);
    m__d = (int32_t)0x24914CCE;
}

const UCar_presetConnectMode_Result& UCar_Return::presetConnectMode() const
{
    if(m__d != (int32_t)0x24914CCE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetConnectMode;
}

UCar_presetConnectMode_Result& UCar_Return::presetConnectMode()
{
    if(m__d != (int32_t)0x24914CCE)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_presetConnectMode;
}

void UCar_Return::videoInitialized(const UCar_videoInitialized_Result &_videoInitialized)
{
    m_videoInitialized = _videoInitialized;
    m__d = (int32_t)0xBC612B69;
}

void UCar_Return::videoInitialized(UCar_videoInitialized_Result &&_videoInitialized)
{
    m_videoInitialized = std::move(_videoInitialized);
    m__d = (int32_t)0xBC612B69;
}

const UCar_videoInitialized_Result& UCar_Return::videoInitialized() const
{
    if(m__d != (int32_t)0xBC612B69)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoInitialized;
}

UCar_videoInitialized_Result& UCar_Return::videoInitialized()
{
    if(m__d != (int32_t)0xBC612B69)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoInitialized;
}

void UCar_Return::videoDataReceived(const UCar_videoDataReceived_Result &_videoDataReceived)
{
    m_videoDataReceived = _videoDataReceived;
    m__d = (int32_t)0x0AED1DEF;
}

void UCar_Return::videoDataReceived(UCar_videoDataReceived_Result &&_videoDataReceived)
{
    m_videoDataReceived = std::move(_videoDataReceived);
    m__d = (int32_t)0x0AED1DEF;
}

const UCar_videoDataReceived_Result& UCar_Return::videoDataReceived() const
{
    if(m__d != (int32_t)0x0AED1DEF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoDataReceived;
}

UCar_videoDataReceived_Result& UCar_Return::videoDataReceived()
{
    if(m__d != (int32_t)0x0AED1DEF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoDataReceived;
}

void UCar_Return::requestGotoHUDesktop(const UCar_requestGotoHUDesktop_Result &_requestGotoHUDesktop)
{
    m_requestGotoHUDesktop = _requestGotoHUDesktop;
    m__d = (int32_t)0xB9DBD217;
}

void UCar_Return::requestGotoHUDesktop(UCar_requestGotoHUDesktop_Result &&_requestGotoHUDesktop)
{
    m_requestGotoHUDesktop = std::move(_requestGotoHUDesktop);
    m__d = (int32_t)0xB9DBD217;
}

const UCar_requestGotoHUDesktop_Result& UCar_Return::requestGotoHUDesktop() const
{
    if(m__d != (int32_t)0xB9DBD217)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_requestGotoHUDesktop;
}

UCar_requestGotoHUDesktop_Result& UCar_Return::requestGotoHUDesktop()
{
    if(m__d != (int32_t)0xB9DBD217)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_requestGotoHUDesktop;
}

void UCar_Return::audioStateChanged(const UCar_audioStateChanged_Result &_audioStateChanged)
{
    m_audioStateChanged = _audioStateChanged;
    m__d = (int32_t)0x2ED6B8C6;
}

void UCar_Return::audioStateChanged(UCar_audioStateChanged_Result &&_audioStateChanged)
{
    m_audioStateChanged = std::move(_audioStateChanged);
    m__d = (int32_t)0x2ED6B8C6;
}

const UCar_audioStateChanged_Result& UCar_Return::audioStateChanged() const
{
    if(m__d != (int32_t)0x2ED6B8C6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_audioStateChanged;
}

UCar_audioStateChanged_Result& UCar_Return::audioStateChanged()
{
    if(m__d != (int32_t)0x2ED6B8C6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_audioStateChanged;
}

void UCar_Return::audioDataReceived(const UCar_audioDataReceived_Result &_audioDataReceived)
{
    m_audioDataReceived = _audioDataReceived;
    m__d = (int32_t)0x1FCD31F5;
}

void UCar_Return::audioDataReceived(UCar_audioDataReceived_Result &&_audioDataReceived)
{
    m_audioDataReceived = std::move(_audioDataReceived);
    m__d = (int32_t)0x1FCD31F5;
}

const UCar_audioDataReceived_Result& UCar_Return::audioDataReceived() const
{
    if(m__d != (int32_t)0x1FCD31F5)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_audioDataReceived;
}

UCar_audioDataReceived_Result& UCar_Return::audioDataReceived()
{
    if(m__d != (int32_t)0x1FCD31F5)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_audioDataReceived;
}

void UCar_Return::musicInfoReceived(const UCar_musicInfoReceived_Result &_musicInfoReceived)
{
    m_musicInfoReceived = _musicInfoReceived;
    m__d = (int32_t)0x984FF8BF;
}

void UCar_Return::musicInfoReceived(UCar_musicInfoReceived_Result &&_musicInfoReceived)
{
    m_musicInfoReceived = std::move(_musicInfoReceived);
    m__d = (int32_t)0x984FF8BF;
}

const UCar_musicInfoReceived_Result& UCar_Return::musicInfoReceived() const
{
    if(m__d != (int32_t)0x984FF8BF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_musicInfoReceived;
}

UCar_musicInfoReceived_Result& UCar_Return::musicInfoReceived()
{
    if(m__d != (int32_t)0x984FF8BF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_musicInfoReceived;
}

void UCar_Return::navigationInfoReceived(const UCar_navigationInfoReceived_Result &_navigationInfoReceived)
{
    m_navigationInfoReceived = _navigationInfoReceived;
    m__d = (int32_t)0xCADE4888;
}

void UCar_Return::navigationInfoReceived(UCar_navigationInfoReceived_Result &&_navigationInfoReceived)
{
    m_navigationInfoReceived = std::move(_navigationInfoReceived);
    m__d = (int32_t)0xCADE4888;
}

const UCar_navigationInfoReceived_Result& UCar_Return::navigationInfoReceived() const
{
    if(m__d != (int32_t)0xCADE4888)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_navigationInfoReceived;
}

UCar_navigationInfoReceived_Result& UCar_Return::navigationInfoReceived()
{
    if(m__d != (int32_t)0xCADE4888)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_navigationInfoReceived;
}

void UCar_Return::phoneStateInfoReceived(const UCar_phoneStateInfoReceived_Result &_phoneStateInfoReceived)
{
    m_phoneStateInfoReceived = _phoneStateInfoReceived;
    m__d = (int32_t)0x2F2D8A67;
}

void UCar_Return::phoneStateInfoReceived(UCar_phoneStateInfoReceived_Result &&_phoneStateInfoReceived)
{
    m_phoneStateInfoReceived = std::move(_phoneStateInfoReceived);
    m__d = (int32_t)0x2F2D8A67;
}

const UCar_phoneStateInfoReceived_Result& UCar_Return::phoneStateInfoReceived() const
{
    if(m__d != (int32_t)0x2F2D8A67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_phoneStateInfoReceived;
}

UCar_phoneStateInfoReceived_Result& UCar_Return::phoneStateInfoReceived()
{
    if(m__d != (int32_t)0x2F2D8A67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_phoneStateInfoReceived;
}

void UCar_Return::micRecordRequest(const UCar_micRecordRequest_Result &_micRecordRequest)
{
    m_micRecordRequest = _micRecordRequest;
    m__d = (int32_t)0xF58271B2;
}

void UCar_Return::micRecordRequest(UCar_micRecordRequest_Result &&_micRecordRequest)
{
    m_micRecordRequest = std::move(_micRecordRequest);
    m__d = (int32_t)0xF58271B2;
}

const UCar_micRecordRequest_Result& UCar_Return::micRecordRequest() const
{
    if(m__d != (int32_t)0xF58271B2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_micRecordRequest;
}

UCar_micRecordRequest_Result& UCar_Return::micRecordRequest()
{
    if(m__d != (int32_t)0xF58271B2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_micRecordRequest;
}

void UCar_Return::userInterventionNeeded(const UCar_userInterventionNeeded_Result &_userInterventionNeeded)
{
    m_userInterventionNeeded = _userInterventionNeeded;
    m__d = (int32_t)0x2F189293;
}

void UCar_Return::userInterventionNeeded(UCar_userInterventionNeeded_Result &&_userInterventionNeeded)
{
    m_userInterventionNeeded = std::move(_userInterventionNeeded);
    m__d = (int32_t)0x2F189293;
}

const UCar_userInterventionNeeded_Result& UCar_Return::userInterventionNeeded() const
{
    if(m__d != (int32_t)0x2F189293)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_userInterventionNeeded;
}

UCar_userInterventionNeeded_Result& UCar_Return::userInterventionNeeded()
{
    if(m__d != (int32_t)0x2F189293)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_userInterventionNeeded;
}


size_t UCar_Return::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += UCar_sendTouchEvent_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendMicRecordData_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendKeyEvent_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendGotoForeground_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendGotoBackground_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_sendVRCMD_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_notifyIsCallHungUp_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_notifySwitchDayOrNight_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_awakenVoiceAssistant_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_presetVendorCustomFields_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_presetConnectMode_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_videoInitialized_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_videoDataReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_requestGotoHUDesktop_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_audioStateChanged_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_audioDataReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_musicInfoReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_navigationInfoReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_phoneStateInfoReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_micRecordRequest_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += UCar_userInterventionNeeded_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

size_t UCar_Return::getCdrSerializedSize(const UCar_Return& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
                case (int32_t)0x81D4B2D7:
                    current_alignment += UCar_sendTouchEvent_Result::getCdrSerializedSize(data.m_sendTouchEvent, current_alignment);
                    break;
                
                case (int32_t)0xD727D4CE:
                    current_alignment += UCar_sendMicRecordData_Result::getCdrSerializedSize(data.m_sendMicRecordData, current_alignment);
                    break;
                
                case (int32_t)0x44278473:
                    current_alignment += UCar_sendKeyEvent_Result::getCdrSerializedSize(data.m_sendKeyEvent, current_alignment);
                    break;
                
                case (int32_t)0x5C709BCF:
                    current_alignment += UCar_sendGotoForeground_Result::getCdrSerializedSize(data.m_sendGotoForeground, current_alignment);
                    break;
                
                case (int32_t)0x57CBA9AE:
                    current_alignment += UCar_sendGotoBackground_Result::getCdrSerializedSize(data.m_sendGotoBackground, current_alignment);
                    break;
                
                case (int32_t)0x873F597B:
                    current_alignment += UCar_sendVRCMD_Result::getCdrSerializedSize(data.m_sendVRCMD, current_alignment);
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    current_alignment += UCar_notifyIsCallHungUp_Result::getCdrSerializedSize(data.m_notifyIsCallHungUp, current_alignment);
                    break;
                
                case (int32_t)0x8ED99DB4:
                    current_alignment += UCar_notifySwitchDayOrNight_Result::getCdrSerializedSize(data.m_notifySwitchDayOrNight, current_alignment);
                    break;
                
                case (int32_t)0x1B523A37:
                    current_alignment += UCar_awakenVoiceAssistant_Result::getCdrSerializedSize(data.m_awakenVoiceAssistant, current_alignment);
                    break;
                
                case (int32_t)0x68A2963D:
                    current_alignment += UCar_presetVendorCustomFields_Result::getCdrSerializedSize(data.m_presetVendorCustomFields, current_alignment);
                    break;
                
                case (int32_t)0x24914CCE:
                    current_alignment += UCar_presetConnectMode_Result::getCdrSerializedSize(data.m_presetConnectMode, current_alignment);
                    break;
                
                case (int32_t)0xBC612B69:
                    current_alignment += UCar_videoInitialized_Result::getCdrSerializedSize(data.m_videoInitialized, current_alignment);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    current_alignment += UCar_videoDataReceived_Result::getCdrSerializedSize(data.m_videoDataReceived, current_alignment);
                    break;
                
                case (int32_t)0xB9DBD217:
                    current_alignment += UCar_requestGotoHUDesktop_Result::getCdrSerializedSize(data.m_requestGotoHUDesktop, current_alignment);
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    current_alignment += UCar_audioStateChanged_Result::getCdrSerializedSize(data.m_audioStateChanged, current_alignment);
                    break;
                
                case (int32_t)0x1FCD31F5:
                    current_alignment += UCar_audioDataReceived_Result::getCdrSerializedSize(data.m_audioDataReceived, current_alignment);
                    break;
                
                case (int32_t)0x984FF8BF:
                    current_alignment += UCar_musicInfoReceived_Result::getCdrSerializedSize(data.m_musicInfoReceived, current_alignment);
                    break;
                
                case (int32_t)0xCADE4888:
                    current_alignment += UCar_navigationInfoReceived_Result::getCdrSerializedSize(data.m_navigationInfoReceived, current_alignment);
                    break;
                
                case (int32_t)0x2F2D8A67:
                    current_alignment += UCar_phoneStateInfoReceived_Result::getCdrSerializedSize(data.m_phoneStateInfoReceived, current_alignment);
                    break;
                
                case (int32_t)0xF58271B2:
                    current_alignment += UCar_micRecordRequest_Result::getCdrSerializedSize(data.m_micRecordRequest, current_alignment);
                    break;
                
                case (int32_t)0x2F189293:
                    current_alignment += UCar_userInterventionNeeded_Result::getCdrSerializedSize(data.m_userInterventionNeeded, current_alignment);
                    break;
                
    }

    return current_alignment - initial_alignment;
}

void UCar_Return::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    scdr << m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    scdr << m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    scdr << m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    scdr << m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    scdr << m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    scdr << m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    scdr << m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    scdr << m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    scdr << m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    scdr << m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    scdr << m_presetConnectMode;
                    break;
                
                case (int32_t)0xBC612B69:
                    scdr << m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    scdr << m_videoDataReceived;
                    break;
                
                case (int32_t)0xB9DBD217:
                    scdr << m_requestGotoHUDesktop;
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    scdr << m_audioStateChanged;
                    break;
                
                case (int32_t)0x1FCD31F5:
                    scdr << m_audioDataReceived;
                    break;
                
                case (int32_t)0x984FF8BF:
                    scdr << m_musicInfoReceived;
                    break;
                
                case (int32_t)0xCADE4888:
                    scdr << m_navigationInfoReceived;
                    break;
                
                case (int32_t)0x2F2D8A67:
                    scdr << m_phoneStateInfoReceived;
                    break;
                
                case (int32_t)0xF58271B2:
                    scdr << m_micRecordRequest;
                    break;
                
                case (int32_t)0x2F189293:
                    scdr << m_userInterventionNeeded;
                    break;
                
        default:
            scdr << m_unknownOp;
            break;
    }
}

void UCar_Return::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    dcdr >> m_sendTouchEvent;
                    break;
                
                case (int32_t)0xD727D4CE:
                    dcdr >> m_sendMicRecordData;
                    break;
                
                case (int32_t)0x44278473:
                    dcdr >> m_sendKeyEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    dcdr >> m_sendGotoForeground;
                    break;
                
                case (int32_t)0x57CBA9AE:
                    dcdr >> m_sendGotoBackground;
                    break;
                
                case (int32_t)0x873F597B:
                    dcdr >> m_sendVRCMD;
                    break;
                
                case (int32_t)0xA5D0AE3A:
                    dcdr >> m_notifyIsCallHungUp;
                    break;
                
                case (int32_t)0x8ED99DB4:
                    dcdr >> m_notifySwitchDayOrNight;
                    break;
                
                case (int32_t)0x1B523A37:
                    dcdr >> m_awakenVoiceAssistant;
                    break;
                
                case (int32_t)0x68A2963D:
                    dcdr >> m_presetVendorCustomFields;
                    break;
                
                case (int32_t)0x24914CCE:
                    dcdr >> m_presetConnectMode;
                    break;
                
                case (int32_t)0xBC612B69:
                    dcdr >> m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    dcdr >> m_videoDataReceived;
                    break;
                
                case (int32_t)0xB9DBD217:
                    dcdr >> m_requestGotoHUDesktop;
                    break;
                
                case (int32_t)0x2ED6B8C6:
                    dcdr >> m_audioStateChanged;
                    break;
                
                case (int32_t)0x1FCD31F5:
                    dcdr >> m_audioDataReceived;
                    break;
                
                case (int32_t)0x984FF8BF:
                    dcdr >> m_musicInfoReceived;
                    break;
                
                case (int32_t)0xCADE4888:
                    dcdr >> m_navigationInfoReceived;
                    break;
                
                case (int32_t)0x2F2D8A67:
                    dcdr >> m_phoneStateInfoReceived;
                    break;
                
                case (int32_t)0xF58271B2:
                    dcdr >> m_micRecordRequest;
                    break;
                
                case (int32_t)0x2F189293:
                    dcdr >> m_userInterventionNeeded;
                    break;
                
        default:
            dcdr >>  m_unknownOp;
            break;
    }
}

UCar_Reply::UCar_Reply()
{
}

UCar_Reply::~UCar_Reply()
{
}

UCar_Reply::UCar_Reply(const UCar_Reply &x)
: m_header(x.m_header), m_data(x.m_data)
{
}

UCar_Reply::UCar_Reply(UCar_Reply &&x)
: m_header(std::move(x.m_header)), m_data(std::move(x.m_data))
{
}

UCar_Reply& UCar_Reply::operator=(const UCar_Reply &x)
{
    m_header = x.m_header;
    m_data = x.m_data;
    
    return *this;
}

UCar_Reply& UCar_Reply::operator=(UCar_Reply &&x)
{
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t UCar_Reply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    current_alignment +=  eprosima::rpc::protocol::dds::rpc::ReplyHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += UCar_Return::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t UCar_Reply::getCdrSerializedSize(const UCar_Reply& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += UCar_Return::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void UCar_Reply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_data;
}

void UCar_Reply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_data;
}
