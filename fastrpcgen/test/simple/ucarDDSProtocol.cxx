/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file ucarDDSProtocol.cxx
 * This source file contains the definition of the protocol used to create DDS messages.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "ucarDDSProtocol.h"
#include <rpcdds/transports/Transport.h>
#include <rpcdds/transports/dds/RTPSProxyTransport.h>
#include <rpcdds/transports/dds/components/RTPSProxyProcedureEndpoint.h>
#include "ucarDDSAsyncSupport.h"
#include <rpcdds/transports/dds/RTPSServerTransport.h>
#include <rpcdds/transports/dds/components/RTPSServerProcedureEndpoint.h>
#include <rpcdds/exceptions/Exceptions.h>

#include <fastrtps/Domain.h>

using namespace eprosima::rpc;
using namespace ::protocol::dds;
using namespace ::transport;
using namespace ::exception;

ucarProtocol::ucarProtocol() : ::protocol::ucarProtocol(), m_ddsTransport(NULL)
, UCar_str("UCar")
, UCar_pe(NULL), UCar_se(NULL)
{
}

ucarProtocol::~ucarProtocol()
{
}

bool ucarProtocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "DDS") == 0)
    {
        m_ddsTransport = dynamic_cast<eprosima::rpc::transport::dds::RTPSTransport*>(&transport);
        
        m_ddsTransport->initialize();
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

// TODO Si falla que elimine los creados.
bool ucarProtocol::activateInterface(const char* interfaceName)
{
    std::string requesttopicName, replytopicName;

    if(m_ddsTransport != NULL)
    {
        TransportBehaviour behaviour = dynamic_cast<Transport*>(m_ddsTransport)->getBehaviour();
        
        if(strcmp(interfaceName, "UCar") == 0)
        {
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &UCar_requestPlugin);

            requesttopicName = "UCar_";
            requesttopicName += m_ddsTransport->getRemoteServiceName();
            requesttopicName += "_Request";
            
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &UCar_replyPlugin);

            replytopicName = "UCar_";
            replytopicName += m_ddsTransport->getRemoteServiceName();
            replytopicName += "_Reply";
            
            if(behaviour == ::transport::PROXY_BEHAVIOUR)
            {
                UCar_pe = dynamic_cast<eprosima::rpc::transport::dds::RTPSProxyProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(UCar_str,
                UCar_requestPlugin.getName(),
                requesttopicName.c_str(),
                UCar_replyPlugin.getName(),
                replytopicName.c_str(),
                (::transport::dds::RTPSTransport::Create_data)UCar_ReplyPlugin::create_data,
                (::transport::dds::RTPSTransport::Copy_data)UCar_ReplyPlugin::copy_data,
                (::transport::dds::RTPSTransport::Destroy_data)UCar_ReplyPlugin::delete_data,
                 ucarProtocol::UCar_proxy,
                sizeof(UCar_Reply)
                ));
            }
            if(behaviour == ::transport::SERVER_BEHAVIOUR)
            {
                UCar_se = dynamic_cast<eprosima::rpc::transport::dds::RTPSServerProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(UCar_str,
                    UCar_replyPlugin.getName(),
                    replytopicName.c_str(),
                    UCar_requestPlugin.getName(),
                    requesttopicName.c_str(),
                    (::transport::dds::RTPSTransport::Create_data)UCar_RequestPlugin::create_data,
                    (::transport::dds::RTPSTransport::Copy_data)UCar_RequestPlugin::copy_data,
                    (::transport::dds::RTPSTransport::Destroy_data)UCar_RequestPlugin::delete_data,
                    ucarProtocol::UCar_serve,
                    sizeof(UCar_Request)));
            }
        }
        
        return true;
    }
    else
    {
      // TODO Trace.
    }
    
    return false;
}









void ucarProtocol::UCar_serve(eprosima::rpc::protocol::Protocol &protocol,
    void *_data , eprosima::rpc::transport::Endpoint *endpoint)
{
    ucarProtocol &_protocol = dynamic_cast<ucarProtocol&>(protocol);
    UCar_Request &requestData = *(UCar_Request*)_data;

    switch(requestData.data()._d())
    {
                case (int32_t)0x81D4B2D7:
                {
                int32_t  action = 0;
                int32_t  width = 0;
                int32_t  height = 0;
                int32_t  count = 0;
                LongArray  trackID;
                LongArray  x;
                LongArray  y;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x81D4B2D7;


                action = requestData.data().sendTouchEvent().action();
                width = requestData.data().sendTouchEvent().width();
                height = requestData.data().sendTouchEvent().height();
                count = requestData.data().sendTouchEvent().count();
                trackID = std::move(requestData.data().sendTouchEvent().trackID()); //TODO Probar que esto funciona.
                x = std::move(requestData.data().sendTouchEvent().x()); //TODO Probar que esto funciona.
                y = std::move(requestData.data().sendTouchEvent().y()); //TODO Probar que esto funciona.

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendTouchEventHandle(action, width, height, count, trackID, x, y);

                        replyData.data().sendTouchEvent()._d() = 0;

                        replyData.data().sendTouchEvent().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0xD727D4CE:
                {
                int32_t  i = 0;
                ShortArray  shorts;
                int32_t  l = 0;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0xD727D4CE;


                i = requestData.data().sendMicRecordData().i();
                shorts = std::move(requestData.data().sendMicRecordData().shorts()); //TODO Probar que esto funciona.
                l = requestData.data().sendMicRecordData().l();

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendMicRecordDataHandle(i, shorts, l);

                        replyData.data().sendMicRecordData()._d() = 0;

                        replyData.data().sendMicRecordData().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x44278473:
                {
                int32_t  keyEventActionType = 0;
                int32_t  keyCodeType = 0;
                int32_t  i = 0;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x44278473;


                keyEventActionType = requestData.data().sendKeyEvent().keyEventActionType();
                keyCodeType = requestData.data().sendKeyEvent().keyCodeType();
                i = requestData.data().sendKeyEvent().i();

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendKeyEventHandle(keyEventActionType, keyCodeType, i);

                        replyData.data().sendKeyEvent()._d() = 0;

                        replyData.data().sendKeyEvent().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x5C709BCF:
                {
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x5C709BCF;



                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendGotoForegroundHandle();

                        replyData.data().sendGotoForeground()._d() = 0;

                        replyData.data().sendGotoForeground().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x57CBA9AE:
                {
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x57CBA9AE;



                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendGotoBackgroundHandle();

                        replyData.data().sendGotoBackground()._d() = 0;

                        replyData.data().sendGotoBackground().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x873F597B:
                {
                int32_t  vrcmdType = 0;
                std::string  s;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x873F597B;


                vrcmdType = requestData.data().sendVRCMD().vrcmdType();
                s = std::move(requestData.data().sendVRCMD().s()); //TODO Probar que esto funciona.

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->sendVRCMDHandle(vrcmdType, s);

                        replyData.data().sendVRCMD()._d() = 0;

                        replyData.data().sendVRCMD().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0xA5D0AE3A:
                {
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0xA5D0AE3A;



                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->notifyIsCallHungUpHandle();

                        replyData.data().notifyIsCallHungUp()._d() = 0;

                        replyData.data().notifyIsCallHungUp().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x8ED99DB4:
                {
                int32_t  dayNightMode = 0;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x8ED99DB4;


                dayNightMode = requestData.data().notifySwitchDayOrNight().dayNightMode();

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->notifySwitchDayOrNightHandle(dayNightMode);

                        replyData.data().notifySwitchDayOrNight()._d() = 0;

                        replyData.data().notifySwitchDayOrNight().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x1B523A37:
                {
                ByteArray  bytes;
                AudioFormat  audioFormat;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x1B523A37;


                bytes = std::move(requestData.data().awakenVoiceAssistant().bytes()); //TODO Probar que esto funciona.
                audioFormat = std::move(requestData.data().awakenVoiceAssistant().audioFormat()); //TODO Probar que esto funciona.

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->awakenVoiceAssistantHandle(bytes, audioFormat);

                        replyData.data().awakenVoiceAssistant()._d() = 0;

                        replyData.data().awakenVoiceAssistant().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x68A2963D:
                {
                ByteArray  bytes;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x68A2963D;


                bytes = std::move(requestData.data().presetVendorCustomFields().bytes()); //TODO Probar que esto funciona.

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->presetVendorCustomFieldsHandle(bytes);

                        replyData.data().presetVendorCustomFields()._d() = 0;

                        replyData.data().presetVendorCustomFields().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x24914CCE:
                {
                int32_t  connectMode = 0;
                bool  return_ = false;   
                UCar_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x24914CCE;


                connectMode = requestData.data().presetConnectMode().connectMode();

                try
                {
                    if(_protocol._UCar_s_impl != NULL)
                    {
                        return_ = _protocol._UCar_s_impl->presetConnectModeHandle(connectMode);

                        replyData.data().presetConnectMode()._d() = 0;

                        replyData.data().presetConnectMode().result().return_(return_);

                        _protocol.UCar_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.UCar_se->sendReply(&replyData);
                }



                }
                break;
                
                
                
                
                
                
                
                
                
                
                
    };        
}

void ucarProtocol::UCar_proxy(eprosima::rpc::protocol::Protocol &protocol,
    void *_data , eprosima::rpc::transport::Endpoint *endpoint)
{
    ucarProtocol &_protocol = dynamic_cast<ucarProtocol&>(protocol);
    UCar_Reply &replyData = *(UCar_Reply*)_data;

    switch(replyData.data()._d())
    {
                
                
                
                
                
                
                
                
                
                
                
                case (int32_t)0xBC612B69:
                {
                    int32_t  type = 0;
                    VideoFormat  videFormat;
                    type = replyData.data().videoInitialized().result().type();
                    videFormat = std::move(replyData.data().videoInitialized().result().videFormat()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->videoInitializedHandle(type, videFormat);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x0AED1DEF:
                {
                    int32_t  type = 0;
                    int32_t  size = 0;
                    ByteArray  byte;
                    type = replyData.data().videoDataReceived().result().type();
                    size = replyData.data().videoDataReceived().result().size();
                    byte = std::move(replyData.data().videoDataReceived().result().byte()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->videoDataReceivedHandle(type, size, byte);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0xB9DBD217:
                {
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->requestGotoHUDesktopHandle();
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x2ED6B8C6:
                {
                    int32_t  var2 = 0;
                    AudioFormat  audioFormat;
                    int32_t  playerState = 0;
                    var2 = replyData.data().audioStateChanged().result().var2();
                    audioFormat = std::move(replyData.data().audioStateChanged().result().audioFormat()); //TODO Probar que esto funciona.
                    playerState = replyData.data().audioStateChanged().result().playerState();
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->audioStateChangedHandle(var2, audioFormat, playerState);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x1FCD31F5:
                {
                    int32_t  var2 = 0;
                    int32_t  var3 = 0;
                    ByteArray  var4;
                    var2 = replyData.data().audioDataReceived().result().var2();
                    var3 = replyData.data().audioDataReceived().result().var3();
                    var4 = std::move(replyData.data().audioDataReceived().result().var4()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->audioDataReceivedHandle(var2, var3, var4);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x984FF8BF:
                {
                    MusicInfo  var2;
                    var2 = std::move(replyData.data().musicInfoReceived().result().var2()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->musicInfoReceivedHandle(var2);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0xCADE4888:
                {
                    NavigationInfo  var2;
                    var2 = std::move(replyData.data().navigationInfoReceived().result().var2()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->navigationInfoReceivedHandle(var2);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x2F2D8A67:
                {
                    PhoneStateInfo  var2;
                    var2 = std::move(replyData.data().phoneStateInfoReceived().result().var2()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->phoneStateInfoReceivedHandle(var2);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0xF58271B2:
                {
                    AudioFormat  var2;
                    bool  var3 = false;
                    var2 = std::move(replyData.data().micRecordRequest().result().var2()); //TODO Probar que esto funciona.
                    var3 = replyData.data().micRecordRequest().result().var3();
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->micRecordRequestHandle(var2, var3);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x2F189293:
                {
                    try
                    {
                        if(_protocol._UCar_p_impl != NULL)
                        {
        _protocol._UCar_p_impl->userInterventionNeededHandle();
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
    };
}

bool ucarProtocol::UCar_sendTouchEvent(/*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x81D4B2D7;

    instance.data().sendTouchEvent().action(action);
    instance.data().sendTouchEvent().width(width);
    instance.data().sendTouchEvent().height(height);
    instance.data().sendTouchEvent().count(count);
    instance.data().sendTouchEvent().trackID(trackID);
    instance.data().sendTouchEvent().x(x);
    instance.data().sendTouchEvent().y(y);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendTouchEvent()._d())
            {
                case 0:
		            return_ = retInstance.data().sendTouchEvent().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendTouchEvent_async(UCar_sendTouchEventCallbackHandler &obj, /*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendTouchEventTask *task = new UCar_sendTouchEventTask(obj);

    instance.data()._d() = 0x81D4B2D7;

    instance.data().sendTouchEvent().action(action);
    instance.data().sendTouchEvent().width(width);
    instance.data().sendTouchEvent().height(height);
    instance.data().sendTouchEvent().count(count);
    instance.data().sendTouchEvent().trackID(trackID);
    instance.data().sendTouchEvent().x(x);
    instance.data().sendTouchEvent().y(y);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_sendMicRecordData(/*in*/ int32_t i, /*in*/ const ShortArray& shorts, /*in*/ int32_t l)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0xD727D4CE;

    instance.data().sendMicRecordData().i(i);
    instance.data().sendMicRecordData().shorts(shorts);
    instance.data().sendMicRecordData().l(l);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendMicRecordData()._d())
            {
                case 0:
		            return_ = retInstance.data().sendMicRecordData().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendMicRecordData_async(UCar_sendMicRecordDataCallbackHandler &obj, /*in*/ int32_t i, /*in*/ const ShortArray& shorts, /*in*/ int32_t l)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendMicRecordDataTask *task = new UCar_sendMicRecordDataTask(obj);

    instance.data()._d() = 0xD727D4CE;

    instance.data().sendMicRecordData().i(i);
    instance.data().sendMicRecordData().shorts(shorts);
    instance.data().sendMicRecordData().l(l);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_sendKeyEvent(/*in*/ int32_t keyEventActionType, /*in*/ int32_t keyCodeType, /*in*/ int32_t i)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x44278473;

    instance.data().sendKeyEvent().keyEventActionType(keyEventActionType);
    instance.data().sendKeyEvent().keyCodeType(keyCodeType);
    instance.data().sendKeyEvent().i(i);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendKeyEvent()._d())
            {
                case 0:
		            return_ = retInstance.data().sendKeyEvent().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendKeyEvent_async(UCar_sendKeyEventCallbackHandler &obj, /*in*/ int32_t keyEventActionType, /*in*/ int32_t keyCodeType, /*in*/ int32_t i)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendKeyEventTask *task = new UCar_sendKeyEventTask(obj);

    instance.data()._d() = 0x44278473;

    instance.data().sendKeyEvent().keyEventActionType(keyEventActionType);
    instance.data().sendKeyEvent().keyCodeType(keyCodeType);
    instance.data().sendKeyEvent().i(i);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_sendGotoForeground()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x5C709BCF;


    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendGotoForeground()._d())
            {
                case 0:
		            return_ = retInstance.data().sendGotoForeground().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendGotoForeground_async(UCar_sendGotoForegroundCallbackHandler &obj)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendGotoForegroundTask *task = new UCar_sendGotoForegroundTask(obj);

    instance.data()._d() = 0x5C709BCF;


    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_sendGotoBackground()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x57CBA9AE;


    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendGotoBackground()._d())
            {
                case 0:
		            return_ = retInstance.data().sendGotoBackground().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendGotoBackground_async(UCar_sendGotoBackgroundCallbackHandler &obj)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendGotoBackgroundTask *task = new UCar_sendGotoBackgroundTask(obj);

    instance.data()._d() = 0x57CBA9AE;


    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_sendVRCMD(/*in*/ int32_t vrcmdType, /*in*/ const std::string& s)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x873F597B;

    instance.data().sendVRCMD().vrcmdType(vrcmdType);
    instance.data().sendVRCMD().s(s);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendVRCMD()._d())
            {
                case 0:
		            return_ = retInstance.data().sendVRCMD().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_sendVRCMD_async(UCar_sendVRCMDCallbackHandler &obj, /*in*/ int32_t vrcmdType, /*in*/ const std::string& s)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_sendVRCMDTask *task = new UCar_sendVRCMDTask(obj);

    instance.data()._d() = 0x873F597B;

    instance.data().sendVRCMD().vrcmdType(vrcmdType);
    instance.data().sendVRCMD().s(s);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_notifyIsCallHungUp()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0xA5D0AE3A;


    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().notifyIsCallHungUp()._d())
            {
                case 0:
		            return_ = retInstance.data().notifyIsCallHungUp().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_notifyIsCallHungUp_async(UCar_notifyIsCallHungUpCallbackHandler &obj)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_notifyIsCallHungUpTask *task = new UCar_notifyIsCallHungUpTask(obj);

    instance.data()._d() = 0xA5D0AE3A;


    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_notifySwitchDayOrNight(/*in*/ int32_t dayNightMode)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x8ED99DB4;

    instance.data().notifySwitchDayOrNight().dayNightMode(dayNightMode);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().notifySwitchDayOrNight()._d())
            {
                case 0:
		            return_ = retInstance.data().notifySwitchDayOrNight().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_notifySwitchDayOrNight_async(UCar_notifySwitchDayOrNightCallbackHandler &obj, /*in*/ int32_t dayNightMode)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_notifySwitchDayOrNightTask *task = new UCar_notifySwitchDayOrNightTask(obj);

    instance.data()._d() = 0x8ED99DB4;

    instance.data().notifySwitchDayOrNight().dayNightMode(dayNightMode);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_awakenVoiceAssistant(/*in*/ const ByteArray& bytes, /*in*/ const AudioFormat& audioFormat)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x1B523A37;

    instance.data().awakenVoiceAssistant().bytes(bytes);
    instance.data().awakenVoiceAssistant().audioFormat(audioFormat);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().awakenVoiceAssistant()._d())
            {
                case 0:
		            return_ = retInstance.data().awakenVoiceAssistant().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_awakenVoiceAssistant_async(UCar_awakenVoiceAssistantCallbackHandler &obj, /*in*/ const ByteArray& bytes, /*in*/ const AudioFormat& audioFormat)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_awakenVoiceAssistantTask *task = new UCar_awakenVoiceAssistantTask(obj);

    instance.data()._d() = 0x1B523A37;

    instance.data().awakenVoiceAssistant().bytes(bytes);
    instance.data().awakenVoiceAssistant().audioFormat(audioFormat);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_presetVendorCustomFields(/*in*/ const ByteArray& bytes)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x68A2963D;

    instance.data().presetVendorCustomFields().bytes(bytes);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().presetVendorCustomFields()._d())
            {
                case 0:
		            return_ = retInstance.data().presetVendorCustomFields().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_presetVendorCustomFields_async(UCar_presetVendorCustomFieldsCallbackHandler &obj, /*in*/ const ByteArray& bytes)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_presetVendorCustomFieldsTask *task = new UCar_presetVendorCustomFieldsTask(obj);

    instance.data()._d() = 0x68A2963D;

    instance.data().presetVendorCustomFields().bytes(bytes);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool ucarProtocol::UCar_presetConnectMode(/*in*/ int32_t connectMode)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    UCar_Request instance;
    UCar_Reply retInstance;



    instance.data()._d() = 0x24914CCE;

    instance.data().presetConnectMode().connectMode(connectMode);

    retcode = UCar_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().presetConnectMode()._d())
            {
                case 0:
		            return_ = retInstance.data().presetConnectMode().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void ucarProtocol::UCar_presetConnectMode_async(UCar_presetConnectModeCallbackHandler &obj, /*in*/ int32_t connectMode)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Request instance;
    UCar_presetConnectModeTask *task = new UCar_presetConnectModeTask(obj);

    instance.data()._d() = 0x24914CCE;

    instance.data().presetConnectMode().connectMode(connectMode);

    retcode = UCar_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



void ucarProtocol::UCar_videoInitialized(/*in*/ int32_t type, /*in*/ const VideoFormat& videFormat)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0xBC612B69;
    replyData.data().videoInitialized()._d() = 0;

    replyData.data().videoInitialized().result().type(type);
    replyData.data().videoInitialized().result().videFormat(std::move(videFormat));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_videoDataReceived(/*in*/ int32_t type, /*in*/ int32_t size, /*in*/ const ByteArray& byte)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x0AED1DEF;
    replyData.data().videoDataReceived()._d() = 0;

    replyData.data().videoDataReceived().result().type(type);
    replyData.data().videoDataReceived().result().size(size);
    replyData.data().videoDataReceived().result().byte(std::move(byte));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_requestGotoHUDesktop()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0xB9DBD217;
    replyData.data().requestGotoHUDesktop()._d() = 0;


    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_audioStateChanged(/*in*/ int32_t var2, /*in*/ const AudioFormat& audioFormat, /*in*/ int32_t playerState)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x2ED6B8C6;
    replyData.data().audioStateChanged()._d() = 0;

    replyData.data().audioStateChanged().result().var2(var2);
    replyData.data().audioStateChanged().result().audioFormat(std::move(audioFormat));
    replyData.data().audioStateChanged().result().playerState(playerState);

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_audioDataReceived(/*in*/ int32_t var2, /*in*/ int32_t var3, /*in*/ const ByteArray& var4)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x1FCD31F5;
    replyData.data().audioDataReceived()._d() = 0;

    replyData.data().audioDataReceived().result().var2(var2);
    replyData.data().audioDataReceived().result().var3(var3);
    replyData.data().audioDataReceived().result().var4(std::move(var4));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_musicInfoReceived(/*in*/ const MusicInfo& var2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x984FF8BF;
    replyData.data().musicInfoReceived()._d() = 0;

    replyData.data().musicInfoReceived().result().var2(std::move(var2));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_navigationInfoReceived(/*in*/ const NavigationInfo& var2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0xCADE4888;
    replyData.data().navigationInfoReceived()._d() = 0;

    replyData.data().navigationInfoReceived().result().var2(std::move(var2));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_phoneStateInfoReceived(/*in*/ const PhoneStateInfo& var2)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x2F2D8A67;
    replyData.data().phoneStateInfoReceived()._d() = 0;

    replyData.data().phoneStateInfoReceived().result().var2(std::move(var2));

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_micRecordRequest(/*in*/ const AudioFormat& var2, /*in*/ bool var3)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0xF58271B2;
    replyData.data().micRecordRequest()._d() = 0;

    replyData.data().micRecordRequest().result().var2(std::move(var2));
    replyData.data().micRecordRequest().result().var3(var3);

    UCar_se->broadcast(&replyData);
}


void ucarProtocol::UCar_userInterventionNeeded()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    UCar_Reply replyData;


    replyData.data()._d() = 0x2F189293;
    replyData.data().userInterventionNeeded()._d() = 0;


    UCar_se->broadcast(&replyData);
}























