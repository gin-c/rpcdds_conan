/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file CalculatorDDSProtocol.cxx
 * This source file contains the definition of the protocol used to create DDS messages.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "CalculatorDDSProtocol.h"
#include <rpcdds/transports/Transport.h>
#include <rpcdds/transports/dds/RTPSProxyTransport.h>
#include <rpcdds/transports/dds/components/RTPSProxyProcedureEndpoint.h>
#include "CalculatorDDSAsyncSupport.h"
#include <rpcdds/transports/dds/RTPSServerTransport.h>
#include <rpcdds/transports/dds/components/RTPSServerProcedureEndpoint.h>
#include <rpcdds/exceptions/Exceptions.h>

#include <fastrtps/Domain.h>

using namespace eprosima::rpc;
using namespace ::protocol::dds;
using namespace ::transport;
using namespace ::exception;

CalculatorProtocol::CalculatorProtocol() : ::protocol::CalculatorProtocol(), m_ddsTransport(NULL)
, Calculator_str("Calculator")
, Calculator_pe(NULL), Calculator_se(NULL)
{
}

CalculatorProtocol::~CalculatorProtocol()
{
}

bool CalculatorProtocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "DDS") == 0)
    {
        m_ddsTransport = dynamic_cast<eprosima::rpc::transport::dds::RTPSTransport*>(&transport);
        
        m_ddsTransport->initialize();
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

// TODO Si falla que elimine los creados.
bool CalculatorProtocol::activateInterface(const char* interfaceName)
{
    std::string requesttopicName, replytopicName;

    if(m_ddsTransport != NULL)
    {
        TransportBehaviour behaviour = dynamic_cast<Transport*>(m_ddsTransport)->getBehaviour();
        
        if(strcmp(interfaceName, "Calculator") == 0)
        {
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &Calculator_requestPlugin);

            requesttopicName = "Calculator_";
            requesttopicName += m_ddsTransport->getRemoteServiceName();
            requesttopicName += "_Request";
            
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &Calculator_replyPlugin);

            replytopicName = "Calculator_";
            replytopicName += m_ddsTransport->getRemoteServiceName();
            replytopicName += "_Reply";
            
            if(behaviour == ::transport::PROXY_BEHAVIOUR)
            {
                Calculator_pe = dynamic_cast<eprosima::rpc::transport::dds::RTPSProxyProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Calculator_str,
                Calculator_requestPlugin.getName(),
                requesttopicName.c_str(),
                Calculator_replyPlugin.getName(),
                replytopicName.c_str(),
                (::transport::dds::RTPSTransport::Create_data)Calculator_ReplyPlugin::create_data,
                (::transport::dds::RTPSTransport::Copy_data)Calculator_ReplyPlugin::copy_data,
                (::transport::dds::RTPSTransport::Destroy_data)Calculator_ReplyPlugin::delete_data,
                 CalculatorProtocol::Calculator_proxy,
                sizeof(Calculator_Reply)
                ));
            }
            if(behaviour == ::transport::SERVER_BEHAVIOUR)
            {
                Calculator_se = dynamic_cast<eprosima::rpc::transport::dds::RTPSServerProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Calculator_str,
                    Calculator_replyPlugin.getName(),
                    replytopicName.c_str(),
                    Calculator_requestPlugin.getName(),
                    requesttopicName.c_str(),
                    (::transport::dds::RTPSTransport::Create_data)Calculator_RequestPlugin::create_data,
                    (::transport::dds::RTPSTransport::Copy_data)Calculator_RequestPlugin::copy_data,
                    (::transport::dds::RTPSTransport::Destroy_data)Calculator_RequestPlugin::delete_data,
                    CalculatorProtocol::Calculator_serve,
                    sizeof(Calculator_Request)));
            }
        }
        
        return true;
    }
    else
    {
      // TODO Trace.
    }
    
    return false;
}





void CalculatorProtocol::Calculator_serve(eprosima::rpc::protocol::Protocol &protocol,
    void *_data , eprosima::rpc::transport::Endpoint *endpoint)
{
    CalculatorProtocol &_protocol = dynamic_cast<CalculatorProtocol&>(protocol);
    Calculator_Request &requestData = *(Calculator_Request*)_data;

    switch(requestData.data()._d())
    {
                case (int32_t)0x81D4B2D7:
                {
                int32_t  action = 0;
                int32_t  width = 0;
                int32_t  height = 0;
                int32_t  count = 0;
                LongArray  trackID;
                LongArray  x;
                LongArray  y;
                bool  return_ = false;   
                Calculator_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x81D4B2D7;


                action = requestData.data().sendTouchEvent().action();
                width = requestData.data().sendTouchEvent().width();
                height = requestData.data().sendTouchEvent().height();
                count = requestData.data().sendTouchEvent().count();
                trackID = std::move(requestData.data().sendTouchEvent().trackID()); //TODO Probar que esto funciona.
                x = std::move(requestData.data().sendTouchEvent().x()); //TODO Probar que esto funciona.
                y = std::move(requestData.data().sendTouchEvent().y()); //TODO Probar que esto funciona.

                try
                {
                    if(_protocol._Calculator_s_impl != NULL)
                    {
                        return_ = _protocol._Calculator_s_impl->sendTouchEvent(action, width, height, count, trackID, x, y);

                        replyData.data().sendTouchEvent()._d() = 0;

                        replyData.data().sendTouchEvent().result().return_(return_);

                        _protocol.Calculator_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.Calculator_se->sendReply(&replyData);
                }



                }
                break;
                
                case (int32_t)0x5C709BCF:
                {
                bool  return_ = false;   
                Calculator_Reply replyData;
                replyData.header().relatedRequestId(requestData.header().requestId());
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

                replyData.data()._d() = 0x5C709BCF;



                try
                {
                    if(_protocol._Calculator_s_impl != NULL)
                    {
                        return_ = _protocol._Calculator_s_impl->sendGotoForeground();

                        replyData.data().sendGotoForeground()._d() = 0;

                        replyData.data().sendGotoForeground().result().return_(return_);

                        _protocol.Calculator_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &)
                {
                    //TODO Quitar el unsetReply
                    //
                    replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                    _protocol.Calculator_se->sendReply(&replyData);
                }



                }
                break;
                
                
                
    };        
}

void CalculatorProtocol::Calculator_proxy(eprosima::rpc::protocol::Protocol &protocol,
    void *_data , eprosima::rpc::transport::Endpoint *endpoint)
{
    CalculatorProtocol &_protocol = dynamic_cast<CalculatorProtocol&>(protocol);
    Calculator_Reply &replyData = *(Calculator_Reply*)_data;

    switch(replyData.data()._d())
    {
                
                
                case (int32_t)0xBC612B69:
                {
                    VideoType  type = ::STREAM_SYSTEM;
                    VideoFormat  videFormat;
                    type = replyData.data().videoInitialized().result().type();
                    videFormat = std::move(replyData.data().videoInitialized().result().videFormat()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._Calculator_p_impl != NULL)
                        {
        _protocol._Calculator_p_impl->videoInitialized(type, videFormat);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
                case (int32_t)0x0AED1DEF:
                {
                    VideoType  type = ::STREAM_SYSTEM;
                    int32_t  size = 0;
                    ByteArray  byte;
                    type = replyData.data().videoDataReceived().result().type();
                    size = replyData.data().videoDataReceived().result().size();
                    byte = std::move(replyData.data().videoDataReceived().result().byte()); //TODO Probar que esto funciona.
                    try
                    {
                        if(_protocol._Calculator_p_impl != NULL)
                        {
        _protocol._Calculator_p_impl->videoDataReceived(type, size, byte);
                        }
                        // TODO Send exception.
                    }
                    catch(const ServerInternalException &)
                    {
                    }
                    break;
                }
                
    };
}

bool CalculatorProtocol::Calculator_sendTouchEvent(/*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    Calculator_Request instance;
    Calculator_Reply retInstance;



    instance.data()._d() = 0x81D4B2D7;

    instance.data().sendTouchEvent().action(action);
    instance.data().sendTouchEvent().width(width);
    instance.data().sendTouchEvent().height(height);
    instance.data().sendTouchEvent().count(count);
    instance.data().sendTouchEvent().trackID(trackID);
    instance.data().sendTouchEvent().x(x);
    instance.data().sendTouchEvent().y(y);

    retcode = Calculator_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendTouchEvent()._d())
            {
                case 0:
		            return_ = retInstance.data().sendTouchEvent().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void CalculatorProtocol::Calculator_sendTouchEvent_async(Calculator_sendTouchEventCallbackHandler &obj, /*in*/ int32_t action, /*in*/ int32_t width, /*in*/ int32_t height, /*in*/ int32_t count, /*in*/ const LongArray& trackID, /*in*/ const LongArray& x, /*in*/ const LongArray& y)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Request instance;
    Calculator_sendTouchEventTask *task = new Calculator_sendTouchEventTask(obj);

    instance.data()._d() = 0x81D4B2D7;

    instance.data().sendTouchEvent().action(action);
    instance.data().sendTouchEvent().width(width);
    instance.data().sendTouchEvent().height(height);
    instance.data().sendTouchEvent().count(count);
    instance.data().sendTouchEvent().trackID(trackID);
    instance.data().sendTouchEvent().x(x);
    instance.data().sendTouchEvent().y(y);

    retcode = Calculator_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



bool CalculatorProtocol::Calculator_sendGotoForeground()
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool  return_ = false;
    Calculator_Request instance;
    Calculator_Reply retInstance;



    instance.data()._d() = 0x5C709BCF;


    retcode = Calculator_pe->send(&instance, &retInstance);

    if(retcode == OK)
    {
        if(retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK)
        {
            switch (retInstance.data().sendGotoForeground()._d())
            {
                case 0:
		            return_ = retInstance.data().sendGotoForeground().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        }
        else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };


    return return_;
}
void CalculatorProtocol::Calculator_sendGotoForeground_async(Calculator_sendGotoForegroundCallbackHandler &obj)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Request instance;
    Calculator_sendGotoForegroundTask *task = new Calculator_sendGotoForegroundTask(obj);

    instance.data()._d() = 0x5C709BCF;


    retcode = Calculator_pe->send_async(&instance, task);

    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}



void CalculatorProtocol::Calculator_videoInitialized(/*in*/ VideoType type, /*in*/ const VideoFormat& videFormat)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Reply replyData;


    replyData.data()._d() = 0xBC612B69;
    replyData.data().videoInitialized()._d() = 0;

    replyData.data().videoInitialized().result().type(type);
    replyData.data().videoInitialized().result().videFormat(std::move(videFormat));

    Calculator_se->broadcast(&replyData);
}


void CalculatorProtocol::Calculator_videoDataReceived(/*in*/ VideoType type, /*in*/ int32_t size, /*in*/ const ByteArray& byte)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    Calculator_Reply replyData;


    replyData.data()._d() = 0x0AED1DEF;
    replyData.data().videoDataReceived()._d() = 0;

    replyData.data().videoDataReceived().result().type(type);
    replyData.data().videoDataReceived().result().size(size);
    replyData.data().videoDataReceived().result().byte(std::move(byte));

    Calculator_se->broadcast(&replyData);
}






