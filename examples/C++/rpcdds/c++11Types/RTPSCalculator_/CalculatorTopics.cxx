/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 * 
 * @file CalculatorTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "CalculatorTopics.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
#include <rpcdds/exceptions/BadParamException.h>










Calculator_sendTouchEvent_In::Calculator_sendTouchEvent_In()
: m_action(0), m_width(0), m_height(0), m_count(0), m_trackID(), m_x(), m_y(){
}

Calculator_sendTouchEvent_In::~Calculator_sendTouchEvent_In()
{
}

Calculator_sendTouchEvent_In::Calculator_sendTouchEvent_In(const Calculator_sendTouchEvent_In &x)
: m_action(x.m_action), m_width(x.m_width), m_height(x.m_height), m_count(x.m_count), m_trackID(x.m_trackID), m_x(x.m_x), m_y(x.m_y){
}

Calculator_sendTouchEvent_In::Calculator_sendTouchEvent_In(Calculator_sendTouchEvent_In &&x)
: m_action(std::move(x.m_action)), m_width(std::move(x.m_width)), m_height(std::move(x.m_height)), m_count(std::move(x.m_count)), m_trackID(std::move(x.m_trackID)), m_x(std::move(x.m_x)), m_y(std::move(x.m_y)){
}

Calculator_sendTouchEvent_In& Calculator_sendTouchEvent_In::operator=(const Calculator_sendTouchEvent_In &x)
{
    m_action = x.m_action;;
    m_width = x.m_width;;
    m_height = x.m_height;;
    m_count = x.m_count;;
    m_trackID = x.m_trackID;;
    m_x = x.m_x;;
    m_y = x.m_y;;
    
    return *this;
}

Calculator_sendTouchEvent_In& Calculator_sendTouchEvent_In::operator=(Calculator_sendTouchEvent_In &&x)
{
    m_action = x.m_action;;
    m_width = x.m_width;;
    m_height = x.m_height;;
    m_count = x.m_count;;
    m_trackID = x.m_trackID;;
    m_x = x.m_x;;
    m_y = x.m_y;;
    
    return *this;
}

size_t Calculator_sendTouchEvent_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);




    return current_alignment - initial_alignment;
}

size_t Calculator_sendTouchEvent_In::getCdrSerializedSize(const Calculator_sendTouchEvent_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.trackID().size() > 0)
    {
        current_alignment += (data.trackID().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.x().size() > 0)
    {
        current_alignment += (data.x().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }



    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.y().size() > 0)
    {
        current_alignment += (data.y().size() * 4) + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    }




    return current_alignment - initial_alignment;
}

void Calculator_sendTouchEvent_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_action;
    scdr << m_width;
    scdr << m_height;
    scdr << m_count;
    scdr << m_trackID;
    scdr << m_x;
    scdr << m_y;
}

void Calculator_sendTouchEvent_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_action;
    dcdr >> m_width;
    dcdr >> m_height;
    dcdr >> m_count;
    dcdr >> m_trackID;
    dcdr >> m_x;
    dcdr >> m_y;
}

Calculator_sendTouchEvent_Out::Calculator_sendTouchEvent_Out()
: m_return_(false){
}

Calculator_sendTouchEvent_Out::~Calculator_sendTouchEvent_Out()
{
}

Calculator_sendTouchEvent_Out::Calculator_sendTouchEvent_Out(const Calculator_sendTouchEvent_Out &x)
: m_return_(x.m_return_){
}

Calculator_sendTouchEvent_Out::Calculator_sendTouchEvent_Out(Calculator_sendTouchEvent_Out &&x)
: m_return_(std::move(x.m_return_)){
}

Calculator_sendTouchEvent_Out& Calculator_sendTouchEvent_Out::operator=(const Calculator_sendTouchEvent_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

Calculator_sendTouchEvent_Out& Calculator_sendTouchEvent_Out::operator=(Calculator_sendTouchEvent_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t Calculator_sendTouchEvent_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Calculator_sendTouchEvent_Out::getCdrSerializedSize(const Calculator_sendTouchEvent_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Calculator_sendTouchEvent_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void Calculator_sendTouchEvent_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

Calculator_sendTouchEvent_Result::Calculator_sendTouchEvent_Result() : m__d(2)
{
}

Calculator_sendTouchEvent_Result::~Calculator_sendTouchEvent_Result()
{
}

Calculator_sendTouchEvent_Result::Calculator_sendTouchEvent_Result(const Calculator_sendTouchEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

Calculator_sendTouchEvent_Result::Calculator_sendTouchEvent_Result(Calculator_sendTouchEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

Calculator_sendTouchEvent_Result& Calculator_sendTouchEvent_Result::operator=(const Calculator_sendTouchEvent_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

Calculator_sendTouchEvent_Result& Calculator_sendTouchEvent_Result::operator=(Calculator_sendTouchEvent_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void Calculator_sendTouchEvent_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_sendTouchEvent_Result::_d() const
{
    return m__d;
}

int32_t& Calculator_sendTouchEvent_Result::_d()
{
    return m__d;
}

void Calculator_sendTouchEvent_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException Calculator_sendTouchEvent_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& Calculator_sendTouchEvent_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void Calculator_sendTouchEvent_Result::result(const Calculator_sendTouchEvent_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void Calculator_sendTouchEvent_Result::result(Calculator_sendTouchEvent_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const Calculator_sendTouchEvent_Out& Calculator_sendTouchEvent_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

Calculator_sendTouchEvent_Out& Calculator_sendTouchEvent_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t Calculator_sendTouchEvent_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += Calculator_sendTouchEvent_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_sendTouchEvent_Result::getCdrSerializedSize(const Calculator_sendTouchEvent_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += Calculator_sendTouchEvent_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void Calculator_sendTouchEvent_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void Calculator_sendTouchEvent_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

Calculator_sendGotoForeground_In::Calculator_sendGotoForeground_In()
: m_dummy(0){
}

Calculator_sendGotoForeground_In::~Calculator_sendGotoForeground_In()
{
}

Calculator_sendGotoForeground_In::Calculator_sendGotoForeground_In(const Calculator_sendGotoForeground_In &x)
: m_dummy(x.m_dummy){
}

Calculator_sendGotoForeground_In::Calculator_sendGotoForeground_In(Calculator_sendGotoForeground_In &&x)
: m_dummy(x.m_dummy){
}

Calculator_sendGotoForeground_In& Calculator_sendGotoForeground_In::operator=(const Calculator_sendGotoForeground_In &x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

Calculator_sendGotoForeground_In& Calculator_sendGotoForeground_In::operator=(Calculator_sendGotoForeground_In &&x)
{
    m_dummy = x.m_dummy;
    
    return *this;
}

size_t Calculator_sendGotoForeground_In::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t Calculator_sendGotoForeground_In::getCdrSerializedSize(const Calculator_sendGotoForeground_In& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void Calculator_sendGotoForeground_In::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_dummy;
}

void Calculator_sendGotoForeground_In::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_dummy;
}

Calculator_sendGotoForeground_Out::Calculator_sendGotoForeground_Out()
: m_return_(false){
}

Calculator_sendGotoForeground_Out::~Calculator_sendGotoForeground_Out()
{
}

Calculator_sendGotoForeground_Out::Calculator_sendGotoForeground_Out(const Calculator_sendGotoForeground_Out &x)
: m_return_(x.m_return_){
}

Calculator_sendGotoForeground_Out::Calculator_sendGotoForeground_Out(Calculator_sendGotoForeground_Out &&x)
: m_return_(std::move(x.m_return_)){
}

Calculator_sendGotoForeground_Out& Calculator_sendGotoForeground_Out::operator=(const Calculator_sendGotoForeground_Out &x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

Calculator_sendGotoForeground_Out& Calculator_sendGotoForeground_Out::operator=(Calculator_sendGotoForeground_Out &&x)
{
    m_return_ = x.m_return_;;
    
    return *this;
}

size_t Calculator_sendGotoForeground_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Calculator_sendGotoForeground_Out::getCdrSerializedSize(const Calculator_sendGotoForeground_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Calculator_sendGotoForeground_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_return_;
}

void Calculator_sendGotoForeground_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_return_;
}

Calculator_sendGotoForeground_Result::Calculator_sendGotoForeground_Result() : m__d(2)
{
}

Calculator_sendGotoForeground_Result::~Calculator_sendGotoForeground_Result()
{
}

Calculator_sendGotoForeground_Result::Calculator_sendGotoForeground_Result(const Calculator_sendGotoForeground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

Calculator_sendGotoForeground_Result::Calculator_sendGotoForeground_Result(Calculator_sendGotoForeground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

Calculator_sendGotoForeground_Result& Calculator_sendGotoForeground_Result::operator=(const Calculator_sendGotoForeground_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

Calculator_sendGotoForeground_Result& Calculator_sendGotoForeground_Result::operator=(Calculator_sendGotoForeground_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void Calculator_sendGotoForeground_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_sendGotoForeground_Result::_d() const
{
    return m__d;
}

int32_t& Calculator_sendGotoForeground_Result::_d()
{
    return m__d;
}

void Calculator_sendGotoForeground_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException Calculator_sendGotoForeground_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& Calculator_sendGotoForeground_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void Calculator_sendGotoForeground_Result::result(const Calculator_sendGotoForeground_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void Calculator_sendGotoForeground_Result::result(Calculator_sendGotoForeground_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const Calculator_sendGotoForeground_Out& Calculator_sendGotoForeground_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

Calculator_sendGotoForeground_Out& Calculator_sendGotoForeground_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t Calculator_sendGotoForeground_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += Calculator_sendGotoForeground_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_sendGotoForeground_Result::getCdrSerializedSize(const Calculator_sendGotoForeground_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += Calculator_sendGotoForeground_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void Calculator_sendGotoForeground_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void Calculator_sendGotoForeground_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


Calculator_videoInitialized_Out::Calculator_videoInitialized_Out()
: m_type(::STREAM_SYSTEM), m_videFormat(){
}

Calculator_videoInitialized_Out::~Calculator_videoInitialized_Out()
{
}

Calculator_videoInitialized_Out::Calculator_videoInitialized_Out(const Calculator_videoInitialized_Out &x)
: m_type(x.m_type), m_videFormat(x.m_videFormat){
}

Calculator_videoInitialized_Out::Calculator_videoInitialized_Out(Calculator_videoInitialized_Out &&x)
: m_type(std::move(x.m_type)), m_videFormat(std::move(x.m_videFormat)){
}

Calculator_videoInitialized_Out& Calculator_videoInitialized_Out::operator=(const Calculator_videoInitialized_Out &x)
{
    m_type = x.m_type;;
    m_videFormat = x.m_videFormat;;

    return *this;
}

Calculator_videoInitialized_Out& Calculator_videoInitialized_Out::operator=(Calculator_videoInitialized_Out &&x)
{
    m_type = x.m_type;;
    m_videFormat = x.m_videFormat;;

    return *this;
}

size_t Calculator_videoInitialized_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += VideoFormat::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Calculator_videoInitialized_Out::getCdrSerializedSize(const Calculator_videoInitialized_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += VideoFormat::getCdrSerializedSize(data.videFormat(), current_alignment);

    return current_alignment - initial_alignment;
}

void Calculator_videoInitialized_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_type;
    scdr << m_videFormat;
}

void Calculator_videoInitialized_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (VideoType)enum_value;
    }

    dcdr >> m_videFormat;
}

Calculator_videoInitialized_Result::Calculator_videoInitialized_Result() : m__d(2)
{
}

Calculator_videoInitialized_Result::~Calculator_videoInitialized_Result()
{
}

Calculator_videoInitialized_Result::Calculator_videoInitialized_Result(const Calculator_videoInitialized_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

Calculator_videoInitialized_Result::Calculator_videoInitialized_Result(Calculator_videoInitialized_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

Calculator_videoInitialized_Result& Calculator_videoInitialized_Result::operator=(const Calculator_videoInitialized_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

Calculator_videoInitialized_Result& Calculator_videoInitialized_Result::operator=(Calculator_videoInitialized_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void Calculator_videoInitialized_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_videoInitialized_Result::_d() const
{
    return m__d;
}

int32_t& Calculator_videoInitialized_Result::_d()
{
    return m__d;
}

void Calculator_videoInitialized_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException Calculator_videoInitialized_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& Calculator_videoInitialized_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void Calculator_videoInitialized_Result::result(const Calculator_videoInitialized_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void Calculator_videoInitialized_Result::result(Calculator_videoInitialized_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const Calculator_videoInitialized_Out& Calculator_videoInitialized_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

Calculator_videoInitialized_Out& Calculator_videoInitialized_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t Calculator_videoInitialized_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += Calculator_videoInitialized_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_videoInitialized_Result::getCdrSerializedSize(const Calculator_videoInitialized_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += Calculator_videoInitialized_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void Calculator_videoInitialized_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void Calculator_videoInitialized_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


Calculator_videoDataReceived_Out::Calculator_videoDataReceived_Out()
: m_type(::STREAM_SYSTEM), m_size(0), m_byte(){
}

Calculator_videoDataReceived_Out::~Calculator_videoDataReceived_Out()
{
}

Calculator_videoDataReceived_Out::Calculator_videoDataReceived_Out(const Calculator_videoDataReceived_Out &x)
: m_type(x.m_type), m_size(x.m_size), m_byte(x.m_byte){
}

Calculator_videoDataReceived_Out::Calculator_videoDataReceived_Out(Calculator_videoDataReceived_Out &&x)
: m_type(std::move(x.m_type)), m_size(std::move(x.m_size)), m_byte(std::move(x.m_byte)){
}

Calculator_videoDataReceived_Out& Calculator_videoDataReceived_Out::operator=(const Calculator_videoDataReceived_Out &x)
{
    m_type = x.m_type;;
    m_size = x.m_size;;
    m_byte = x.m_byte;;

    return *this;
}

Calculator_videoDataReceived_Out& Calculator_videoDataReceived_Out::operator=(Calculator_videoDataReceived_Out &&x)
{
    m_type = x.m_type;;
    m_size = x.m_size;;
    m_byte = x.m_byte;;

    return *this;
}

size_t Calculator_videoDataReceived_Out::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (40960 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t Calculator_videoDataReceived_Out::getCdrSerializedSize(const Calculator_videoDataReceived_Out& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    if (data.byte().size() > 0)
    {
        current_alignment += (data.byte().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    }




    return current_alignment - initial_alignment;
}

void Calculator_videoDataReceived_Out::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_type;
    scdr << m_size;
    scdr << m_byte;
}

void Calculator_videoDataReceived_Out::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (VideoType)enum_value;
    }

    dcdr >> m_size;
    dcdr >> m_byte;
}

Calculator_videoDataReceived_Result::Calculator_videoDataReceived_Result() : m__d(2)
{
}

Calculator_videoDataReceived_Result::~Calculator_videoDataReceived_Result()
{
}

Calculator_videoDataReceived_Result::Calculator_videoDataReceived_Result(const Calculator_videoDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

Calculator_videoDataReceived_Result::Calculator_videoDataReceived_Result(Calculator_videoDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

Calculator_videoDataReceived_Result& Calculator_videoDataReceived_Result::operator=(const Calculator_videoDataReceived_Result &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
    
    return *this;
}

Calculator_videoDataReceived_Result& Calculator_videoDataReceived_Result::operator=(Calculator_videoDataReceived_Result &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
    
    return *this;
}

void Calculator_videoDataReceived_Result::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_videoDataReceived_Result::_d() const
{
    return m__d;
}

int32_t& Calculator_videoDataReceived_Result::_d()
{
    return m__d;
}

void Calculator_videoDataReceived_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx)
{
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException Calculator_videoDataReceived_Result::unknownEx() const
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException& Calculator_videoDataReceived_Result::unknownEx()
{
    if(m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void Calculator_videoDataReceived_Result::result(const Calculator_videoDataReceived_Out &_result)
{
    m_result = _result;
    m__d = 0;
}

void Calculator_videoDataReceived_Result::result(Calculator_videoDataReceived_Out &&_result)
{
    m_result = std::move(_result);
    m__d = 0;
}

const Calculator_videoDataReceived_Out& Calculator_videoDataReceived_Result::result() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}

Calculator_videoDataReceived_Out& Calculator_videoDataReceived_Result::result()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_result;
}


size_t Calculator_videoDataReceived_Result::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += Calculator_videoDataReceived_Out::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;


    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_videoDataReceived_Result::getCdrSerializedSize(const Calculator_videoDataReceived_Result& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += Calculator_videoDataReceived_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void Calculator_videoDataReceived_Result::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void Calculator_videoDataReceived_Result::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}


Calculator_Call::Calculator_Call() : m__d(0)
{
}

Calculator_Call::~Calculator_Call()
{
}

Calculator_Call::Calculator_Call(const Calculator_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                
                
    }
}

Calculator_Call::Calculator_Call(Calculator_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                
                
    }
}

Calculator_Call& Calculator_Call::operator=(const Calculator_Call &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                
                
    }
    
    return *this;
}

Calculator_Call& Calculator_Call::operator=(Calculator_Call &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                
                
    }
    
    return *this;
}

void Calculator_Call::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_Call::_d() const
{
    return m__d;
}

int32_t& Calculator_Call::_d()
{
    return m__d;
}

void Calculator_Call::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp)
{
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation Calculator_Call::unknownOp() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation& Calculator_Call::unknownOp()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

void Calculator_Call::sendTouchEvent(const Calculator_sendTouchEvent_In &_sendTouchEvent)
{
    m_sendTouchEvent = _sendTouchEvent;
    m__d = (int32_t)0x81D4B2D7;
}

void Calculator_Call::sendTouchEvent(Calculator_sendTouchEvent_In &&_sendTouchEvent)
{
    m_sendTouchEvent = std::move(_sendTouchEvent);
    m__d = (int32_t)0x81D4B2D7;
}

const Calculator_sendTouchEvent_In& Calculator_Call::sendTouchEvent() const
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

Calculator_sendTouchEvent_In& Calculator_Call::sendTouchEvent()
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}
void Calculator_Call::sendGotoForeground(const Calculator_sendGotoForeground_In &_sendGotoForeground)
{
    m_sendGotoForeground = _sendGotoForeground;
    m__d = (int32_t)0x5C709BCF;
}

void Calculator_Call::sendGotoForeground(Calculator_sendGotoForeground_In &&_sendGotoForeground)
{
    m_sendGotoForeground = std::move(_sendGotoForeground);
    m__d = (int32_t)0x5C709BCF;
}

const Calculator_sendGotoForeground_In& Calculator_Call::sendGotoForeground() const
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

Calculator_sendGotoForeground_In& Calculator_Call::sendGotoForeground()
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}



size_t Calculator_Call::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknownOp attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += Calculator_sendTouchEvent_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += Calculator_sendGotoForeground_In::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        
        

    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_Call::getCdrSerializedSize(const Calculator_Call& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
                case (int32_t)0x81D4B2D7:
                    current_alignment += Calculator_sendTouchEvent_In::getCdrSerializedSize(data.m_sendTouchEvent, current_alignment);
                    break;
                
                case (int32_t)0x5C709BCF:
                    current_alignment += Calculator_sendGotoForeground_In::getCdrSerializedSize(data.m_sendGotoForeground, current_alignment);
                    break;
                
                
                
    }

    return current_alignment - initial_alignment;
}

void Calculator_Call::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    scdr << m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    scdr << m_sendGotoForeground;
                    break;
                
                
                
        default:
            scdr << m_unknownOp;
            break;
    }
}

void Calculator_Call::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    dcdr >> m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    dcdr >> m_sendGotoForeground;
                    break;
                
                
                
        default:
            dcdr >> m_unknownOp;
            break;
    }
}

Calculator_Request::Calculator_Request()
{
}

Calculator_Request::~Calculator_Request()
{
}

Calculator_Request::Calculator_Request(const Calculator_Request &x)
: m_header(x.m_header), m_data(x.m_data)
{
}

Calculator_Request::Calculator_Request(Calculator_Request &&x)
: m_header(std::move(x.m_header)), m_data(std::move(x.m_data))
{
}

Calculator_Request& Calculator_Request::operator=(const Calculator_Request &x)
{
    m_header = x.m_header;
    m_data = x.m_data;
    
    return *this;
}

Calculator_Request& Calculator_Request::operator=(Calculator_Request &&x)
{
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t Calculator_Request::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment +=  eprosima::rpc::protocol::dds::rpc::RequestHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Calculator_Call::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t Calculator_Request::getCdrSerializedSize(const Calculator_Request& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += Calculator_Call::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void Calculator_Request::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_data;
}

void Calculator_Request::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_data;
}

Calculator_Return::Calculator_Return() : m__d(0)
{
}

Calculator_Return::~Calculator_Return()
{
}

Calculator_Return::Calculator_Return(const Calculator_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = x.m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = x.m_videoDataReceived;
                    break;
                
    }
}

Calculator_Return::Calculator_Return(Calculator_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = std::move(x.m_videoInitialized);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = std::move(x.m_videoDataReceived);
                    break;
                
    }
}

Calculator_Return& Calculator_Return::operator=(const Calculator_Return &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = x.m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = x.m_sendGotoForeground;
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = x.m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = x.m_videoDataReceived;
                    break;
                
    }
    
    return *this;
}

Calculator_Return& Calculator_Return::operator=(Calculator_Return &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    m_sendTouchEvent = std::move(x.m_sendTouchEvent);
                    break;
                
                case (int32_t)0x5C709BCF:
                    m_sendGotoForeground = std::move(x.m_sendGotoForeground);
                    break;
                
                case (int32_t)0xBC612B69:
                    m_videoInitialized = std::move(x.m_videoInitialized);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    m_videoDataReceived = std::move(x.m_videoDataReceived);
                    break;
                
    }
    
    return *this;
}

void Calculator_Return::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t Calculator_Return::_d() const
{
    return m__d;
}

int32_t& Calculator_Return::_d()
{
    return m__d;
}

void Calculator_Return::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp)
{
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation Calculator_Return::unknownOp() const
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation& Calculator_Return::unknownOp()
{
    if(m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_unknownOp;
}

void Calculator_Return::sendTouchEvent(const Calculator_sendTouchEvent_Result &_sendTouchEvent)
{
    m_sendTouchEvent = _sendTouchEvent;
    m__d = (int32_t)0x81D4B2D7;
}

void Calculator_Return::sendTouchEvent(Calculator_sendTouchEvent_Result &&_sendTouchEvent)
{
    m_sendTouchEvent = std::move(_sendTouchEvent);
    m__d = (int32_t)0x81D4B2D7;
}

const Calculator_sendTouchEvent_Result& Calculator_Return::sendTouchEvent() const
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

Calculator_sendTouchEvent_Result& Calculator_Return::sendTouchEvent()
{
    if(m__d != (int32_t)0x81D4B2D7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendTouchEvent;
}

void Calculator_Return::sendGotoForeground(const Calculator_sendGotoForeground_Result &_sendGotoForeground)
{
    m_sendGotoForeground = _sendGotoForeground;
    m__d = (int32_t)0x5C709BCF;
}

void Calculator_Return::sendGotoForeground(Calculator_sendGotoForeground_Result &&_sendGotoForeground)
{
    m_sendGotoForeground = std::move(_sendGotoForeground);
    m__d = (int32_t)0x5C709BCF;
}

const Calculator_sendGotoForeground_Result& Calculator_Return::sendGotoForeground() const
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

Calculator_sendGotoForeground_Result& Calculator_Return::sendGotoForeground()
{
    if(m__d != (int32_t)0x5C709BCF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_sendGotoForeground;
}

void Calculator_Return::videoInitialized(const Calculator_videoInitialized_Result &_videoInitialized)
{
    m_videoInitialized = _videoInitialized;
    m__d = (int32_t)0xBC612B69;
}

void Calculator_Return::videoInitialized(Calculator_videoInitialized_Result &&_videoInitialized)
{
    m_videoInitialized = std::move(_videoInitialized);
    m__d = (int32_t)0xBC612B69;
}

const Calculator_videoInitialized_Result& Calculator_Return::videoInitialized() const
{
    if(m__d != (int32_t)0xBC612B69)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoInitialized;
}

Calculator_videoInitialized_Result& Calculator_Return::videoInitialized()
{
    if(m__d != (int32_t)0xBC612B69)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoInitialized;
}

void Calculator_Return::videoDataReceived(const Calculator_videoDataReceived_Result &_videoDataReceived)
{
    m_videoDataReceived = _videoDataReceived;
    m__d = (int32_t)0x0AED1DEF;
}

void Calculator_Return::videoDataReceived(Calculator_videoDataReceived_Result &&_videoDataReceived)
{
    m_videoDataReceived = std::move(_videoDataReceived);
    m__d = (int32_t)0x0AED1DEF;
}

const Calculator_videoDataReceived_Result& Calculator_Return::videoDataReceived() const
{
    if(m__d != (int32_t)0x0AED1DEF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoDataReceived;
}

Calculator_videoDataReceived_Result& Calculator_Return::videoDataReceived()
{
    if(m__d != (int32_t)0x0AED1DEF)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_videoDataReceived;
}


size_t Calculator_Return::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

        reset_alignment = current_alignment;

        reset_alignment += Calculator_sendTouchEvent_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += Calculator_sendGotoForeground_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += Calculator_videoInitialized_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += Calculator_videoDataReceived_Result::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

size_t Calculator_Return::getCdrSerializedSize(const Calculator_Return& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch(data.m__d)
    {
                case (int32_t)0x81D4B2D7:
                    current_alignment += Calculator_sendTouchEvent_Result::getCdrSerializedSize(data.m_sendTouchEvent, current_alignment);
                    break;
                
                case (int32_t)0x5C709BCF:
                    current_alignment += Calculator_sendGotoForeground_Result::getCdrSerializedSize(data.m_sendGotoForeground, current_alignment);
                    break;
                
                case (int32_t)0xBC612B69:
                    current_alignment += Calculator_videoInitialized_Result::getCdrSerializedSize(data.m_videoInitialized, current_alignment);
                    break;
                
                case (int32_t)0x0AED1DEF:
                    current_alignment += Calculator_videoDataReceived_Result::getCdrSerializedSize(data.m_videoDataReceived, current_alignment);
                    break;
                
    }

    return current_alignment - initial_alignment;
}

void Calculator_Return::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    scdr << m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    scdr << m_sendGotoForeground;
                    break;
                
                case (int32_t)0xBC612B69:
                    scdr << m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    scdr << m_videoDataReceived;
                    break;
                
        default:
            scdr << m_unknownOp;
            break;
    }
}

void Calculator_Return::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
                case (int32_t)0x81D4B2D7:
                    dcdr >> m_sendTouchEvent;
                    break;
                
                case (int32_t)0x5C709BCF:
                    dcdr >> m_sendGotoForeground;
                    break;
                
                case (int32_t)0xBC612B69:
                    dcdr >> m_videoInitialized;
                    break;
                
                case (int32_t)0x0AED1DEF:
                    dcdr >> m_videoDataReceived;
                    break;
                
        default:
            dcdr >>  m_unknownOp;
            break;
    }
}

Calculator_Reply::Calculator_Reply()
{
}

Calculator_Reply::~Calculator_Reply()
{
}

Calculator_Reply::Calculator_Reply(const Calculator_Reply &x)
: m_header(x.m_header), m_data(x.m_data)
{
}

Calculator_Reply::Calculator_Reply(Calculator_Reply &&x)
: m_header(std::move(x.m_header)), m_data(std::move(x.m_data))
{
}

Calculator_Reply& Calculator_Reply::operator=(const Calculator_Reply &x)
{
    m_header = x.m_header;
    m_data = x.m_data;
    
    return *this;
}

Calculator_Reply& Calculator_Reply::operator=(Calculator_Reply &&x)
{
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t Calculator_Reply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    current_alignment +=  eprosima::rpc::protocol::dds::rpc::ReplyHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Calculator_Return::getMaxCdrSerializedSize(current_alignment);
            
    return current_alignment - initial_alignment;
}

size_t Calculator_Reply::getCdrSerializedSize(const Calculator_Reply& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += Calculator_Return::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void Calculator_Reply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_header;
    scdr << m_data;
}

void Calculator_Reply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_header;
    dcdr >> m_data;
}
