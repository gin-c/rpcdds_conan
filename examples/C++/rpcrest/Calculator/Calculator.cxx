/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * _LICENSE file included in this  distribution.
 *
 *************************************************************************
 * 
 * @file Calculator.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#include "Calculator.h"

#include "rpcrest/exceptions/BadParamException.h"
using namespace eprosima::rpc::exception;

#include <utility>

Calculator::addResource::EmptyAddResponse::EmptyAddResponse()
{
    m_status = 0;
}

Calculator::addResource::EmptyAddResponse::~EmptyAddResponse()
{
}

Calculator::addResource::EmptyAddResponse::EmptyAddResponse(const EmptyAddResponse &x)
{
    m_status = x.m_status;
}

Calculator::addResource::EmptyAddResponse::EmptyAddResponse(EmptyAddResponse &&x)
{
    m_status = x.m_status;
}

Calculator::addResource::EmptyAddResponse& Calculator::addResource::EmptyAddResponse::operator=(const EmptyAddResponse &x)
{
    m_status = x.m_status;
    
    return *this;
}

Calculator::addResource::EmptyAddResponse& Calculator::addResource::EmptyAddResponse::operator=(EmptyAddResponse &&x)
{
    m_status = x.m_status;
    
    return *this;
}


Calculator::addResource::XMLAddResponse::XMLAddResponse()
{
    m_status = 0;
    m_xmlRepresentation = "";
}

Calculator::addResource::XMLAddResponse::~XMLAddResponse()
{
}

Calculator::addResource::XMLAddResponse::XMLAddResponse(const XMLAddResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::addResource::XMLAddResponse::XMLAddResponse(XMLAddResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::addResource::XMLAddResponse& Calculator::addResource::XMLAddResponse::operator=(const XMLAddResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}

Calculator::addResource::XMLAddResponse& Calculator::addResource::XMLAddResponse::operator=(XMLAddResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}


Calculator::addResource::AddResponse::AddResponse()
{
    m__d = -1000;

}

Calculator::addResource::AddResponse::~AddResponse()
{
}

Calculator::addResource::AddResponse::AddResponse(const AddResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyAddResponse = x.m_emptyAddResponse;
        break;
        case 1:
        m_xmlAddResponse = x.m_xmlAddResponse;
        break;
    }
}

Calculator::addResource::AddResponse::AddResponse(AddResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyAddResponse = std::move(x.m_emptyAddResponse);break;
        case 1:
        m_xmlAddResponse = std::move(x.m_xmlAddResponse);break;
    }
}

Calculator::addResource::AddResponse& Calculator::addResource::AddResponse::operator=(const AddResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyAddResponse = x.m_emptyAddResponse;
        break;
        case 1:
        m_xmlAddResponse = x.m_xmlAddResponse;
        break;
    }
    
    return *this;
}

Calculator::addResource::AddResponse& Calculator::addResource::AddResponse::operator=(AddResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyAddResponse = std::move(x.m_emptyAddResponse);break;
        case 1:
        m_xmlAddResponse = std::move(x.m_xmlAddResponse);break;
    }
    
    return *this;
}

void Calculator::addResource::AddResponse::_d(int32_t __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

int32_t Calculator::addResource::AddResponse::_d() const
{
    return m__d;
}

int32_t& Calculator::addResource::AddResponse::_d()
{
    return m__d;
}

void Calculator::addResource::AddResponse::emptyAddResponse(const Calculator::addResource::EmptyAddResponse &_emptyAddResponse)
{
    m_emptyAddResponse = _emptyAddResponse;
    m__d = 0;
}

void Calculator::addResource::AddResponse::emptyAddResponse(Calculator::addResource::EmptyAddResponse &&_emptyAddResponse)
{
    m_emptyAddResponse = std::move(_emptyAddResponse);
    m__d = 0;
}

const Calculator::addResource::EmptyAddResponse& Calculator::addResource::AddResponse::emptyAddResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyAddResponse;
}

Calculator::addResource::EmptyAddResponse& Calculator::addResource::AddResponse::emptyAddResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyAddResponse;
}
void Calculator::addResource::AddResponse::xmlAddResponse(const Calculator::addResource::XMLAddResponse &_xmlAddResponse)
{
    m_xmlAddResponse = _xmlAddResponse;
    m__d = 1;
}

void Calculator::addResource::AddResponse::xmlAddResponse(Calculator::addResource::XMLAddResponse &&_xmlAddResponse)
{
    m_xmlAddResponse = std::move(_xmlAddResponse);
    m__d = 1;
}

const Calculator::addResource::XMLAddResponse& Calculator::addResource::AddResponse::xmlAddResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlAddResponse;
}

Calculator::addResource::XMLAddResponse& Calculator::addResource::AddResponse::xmlAddResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlAddResponse;
}




Calculator::substractResource::EmptySubstractResponse::EmptySubstractResponse()
{
    m_status = 0;
}

Calculator::substractResource::EmptySubstractResponse::~EmptySubstractResponse()
{
}

Calculator::substractResource::EmptySubstractResponse::EmptySubstractResponse(const EmptySubstractResponse &x)
{
    m_status = x.m_status;
}

Calculator::substractResource::EmptySubstractResponse::EmptySubstractResponse(EmptySubstractResponse &&x)
{
    m_status = x.m_status;
}

Calculator::substractResource::EmptySubstractResponse& Calculator::substractResource::EmptySubstractResponse::operator=(const EmptySubstractResponse &x)
{
    m_status = x.m_status;
    
    return *this;
}

Calculator::substractResource::EmptySubstractResponse& Calculator::substractResource::EmptySubstractResponse::operator=(EmptySubstractResponse &&x)
{
    m_status = x.m_status;
    
    return *this;
}


Calculator::substractResource::XMLSubstractResponse::XMLSubstractResponse()
{
    m_status = 0;
    m_xmlRepresentation = "";
}

Calculator::substractResource::XMLSubstractResponse::~XMLSubstractResponse()
{
}

Calculator::substractResource::XMLSubstractResponse::XMLSubstractResponse(const XMLSubstractResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::substractResource::XMLSubstractResponse::XMLSubstractResponse(XMLSubstractResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::substractResource::XMLSubstractResponse& Calculator::substractResource::XMLSubstractResponse::operator=(const XMLSubstractResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}

Calculator::substractResource::XMLSubstractResponse& Calculator::substractResource::XMLSubstractResponse::operator=(XMLSubstractResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}


Calculator::substractResource::SubstractResponse::SubstractResponse()
{
    m__d = -1000;

}

Calculator::substractResource::SubstractResponse::~SubstractResponse()
{
}

Calculator::substractResource::SubstractResponse::SubstractResponse(const SubstractResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptySubstractResponse = x.m_emptySubstractResponse;
        break;
        case 1:
        m_xmlSubstractResponse = x.m_xmlSubstractResponse;
        break;
    }
}

Calculator::substractResource::SubstractResponse::SubstractResponse(SubstractResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptySubstractResponse = std::move(x.m_emptySubstractResponse);break;
        case 1:
        m_xmlSubstractResponse = std::move(x.m_xmlSubstractResponse);break;
    }
}

Calculator::substractResource::SubstractResponse& Calculator::substractResource::SubstractResponse::operator=(const SubstractResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptySubstractResponse = x.m_emptySubstractResponse;
        break;
        case 1:
        m_xmlSubstractResponse = x.m_xmlSubstractResponse;
        break;
    }
    
    return *this;
}

Calculator::substractResource::SubstractResponse& Calculator::substractResource::SubstractResponse::operator=(SubstractResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptySubstractResponse = std::move(x.m_emptySubstractResponse);break;
        case 1:
        m_xmlSubstractResponse = std::move(x.m_xmlSubstractResponse);break;
    }
    
    return *this;
}

void Calculator::substractResource::SubstractResponse::_d(int32_t __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

int32_t Calculator::substractResource::SubstractResponse::_d() const
{
    return m__d;
}

int32_t& Calculator::substractResource::SubstractResponse::_d()
{
    return m__d;
}

void Calculator::substractResource::SubstractResponse::emptySubstractResponse(const Calculator::substractResource::EmptySubstractResponse &_emptySubstractResponse)
{
    m_emptySubstractResponse = _emptySubstractResponse;
    m__d = 0;
}

void Calculator::substractResource::SubstractResponse::emptySubstractResponse(Calculator::substractResource::EmptySubstractResponse &&_emptySubstractResponse)
{
    m_emptySubstractResponse = std::move(_emptySubstractResponse);
    m__d = 0;
}

const Calculator::substractResource::EmptySubstractResponse& Calculator::substractResource::SubstractResponse::emptySubstractResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptySubstractResponse;
}

Calculator::substractResource::EmptySubstractResponse& Calculator::substractResource::SubstractResponse::emptySubstractResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptySubstractResponse;
}
void Calculator::substractResource::SubstractResponse::xmlSubstractResponse(const Calculator::substractResource::XMLSubstractResponse &_xmlSubstractResponse)
{
    m_xmlSubstractResponse = _xmlSubstractResponse;
    m__d = 1;
}

void Calculator::substractResource::SubstractResponse::xmlSubstractResponse(Calculator::substractResource::XMLSubstractResponse &&_xmlSubstractResponse)
{
    m_xmlSubstractResponse = std::move(_xmlSubstractResponse);
    m__d = 1;
}

const Calculator::substractResource::XMLSubstractResponse& Calculator::substractResource::SubstractResponse::xmlSubstractResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlSubstractResponse;
}

Calculator::substractResource::XMLSubstractResponse& Calculator::substractResource::SubstractResponse::xmlSubstractResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlSubstractResponse;
}




Calculator::multiplyResource::EmptyMultiplyResponse::EmptyMultiplyResponse()
{
    m_status = 0;
}

Calculator::multiplyResource::EmptyMultiplyResponse::~EmptyMultiplyResponse()
{
}

Calculator::multiplyResource::EmptyMultiplyResponse::EmptyMultiplyResponse(const EmptyMultiplyResponse &x)
{
    m_status = x.m_status;
}

Calculator::multiplyResource::EmptyMultiplyResponse::EmptyMultiplyResponse(EmptyMultiplyResponse &&x)
{
    m_status = x.m_status;
}

Calculator::multiplyResource::EmptyMultiplyResponse& Calculator::multiplyResource::EmptyMultiplyResponse::operator=(const EmptyMultiplyResponse &x)
{
    m_status = x.m_status;
    
    return *this;
}

Calculator::multiplyResource::EmptyMultiplyResponse& Calculator::multiplyResource::EmptyMultiplyResponse::operator=(EmptyMultiplyResponse &&x)
{
    m_status = x.m_status;
    
    return *this;
}


Calculator::multiplyResource::XMLMultiplyResponse::XMLMultiplyResponse()
{
    m_status = 0;
    m_xmlRepresentation = "";
}

Calculator::multiplyResource::XMLMultiplyResponse::~XMLMultiplyResponse()
{
}

Calculator::multiplyResource::XMLMultiplyResponse::XMLMultiplyResponse(const XMLMultiplyResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::multiplyResource::XMLMultiplyResponse::XMLMultiplyResponse(XMLMultiplyResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::multiplyResource::XMLMultiplyResponse& Calculator::multiplyResource::XMLMultiplyResponse::operator=(const XMLMultiplyResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}

Calculator::multiplyResource::XMLMultiplyResponse& Calculator::multiplyResource::XMLMultiplyResponse::operator=(XMLMultiplyResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}


Calculator::multiplyResource::MultiplyResponse::MultiplyResponse()
{
    m__d = -1000;

}

Calculator::multiplyResource::MultiplyResponse::~MultiplyResponse()
{
}

Calculator::multiplyResource::MultiplyResponse::MultiplyResponse(const MultiplyResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyMultiplyResponse = x.m_emptyMultiplyResponse;
        break;
        case 1:
        m_xmlMultiplyResponse = x.m_xmlMultiplyResponse;
        break;
    }
}

Calculator::multiplyResource::MultiplyResponse::MultiplyResponse(MultiplyResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyMultiplyResponse = std::move(x.m_emptyMultiplyResponse);break;
        case 1:
        m_xmlMultiplyResponse = std::move(x.m_xmlMultiplyResponse);break;
    }
}

Calculator::multiplyResource::MultiplyResponse& Calculator::multiplyResource::MultiplyResponse::operator=(const MultiplyResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyMultiplyResponse = x.m_emptyMultiplyResponse;
        break;
        case 1:
        m_xmlMultiplyResponse = x.m_xmlMultiplyResponse;
        break;
    }
    
    return *this;
}

Calculator::multiplyResource::MultiplyResponse& Calculator::multiplyResource::MultiplyResponse::operator=(MultiplyResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyMultiplyResponse = std::move(x.m_emptyMultiplyResponse);break;
        case 1:
        m_xmlMultiplyResponse = std::move(x.m_xmlMultiplyResponse);break;
    }
    
    return *this;
}

void Calculator::multiplyResource::MultiplyResponse::_d(int32_t __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

int32_t Calculator::multiplyResource::MultiplyResponse::_d() const
{
    return m__d;
}

int32_t& Calculator::multiplyResource::MultiplyResponse::_d()
{
    return m__d;
}

void Calculator::multiplyResource::MultiplyResponse::emptyMultiplyResponse(const Calculator::multiplyResource::EmptyMultiplyResponse &_emptyMultiplyResponse)
{
    m_emptyMultiplyResponse = _emptyMultiplyResponse;
    m__d = 0;
}

void Calculator::multiplyResource::MultiplyResponse::emptyMultiplyResponse(Calculator::multiplyResource::EmptyMultiplyResponse &&_emptyMultiplyResponse)
{
    m_emptyMultiplyResponse = std::move(_emptyMultiplyResponse);
    m__d = 0;
}

const Calculator::multiplyResource::EmptyMultiplyResponse& Calculator::multiplyResource::MultiplyResponse::emptyMultiplyResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyMultiplyResponse;
}

Calculator::multiplyResource::EmptyMultiplyResponse& Calculator::multiplyResource::MultiplyResponse::emptyMultiplyResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyMultiplyResponse;
}
void Calculator::multiplyResource::MultiplyResponse::xmlMultiplyResponse(const Calculator::multiplyResource::XMLMultiplyResponse &_xmlMultiplyResponse)
{
    m_xmlMultiplyResponse = _xmlMultiplyResponse;
    m__d = 1;
}

void Calculator::multiplyResource::MultiplyResponse::xmlMultiplyResponse(Calculator::multiplyResource::XMLMultiplyResponse &&_xmlMultiplyResponse)
{
    m_xmlMultiplyResponse = std::move(_xmlMultiplyResponse);
    m__d = 1;
}

const Calculator::multiplyResource::XMLMultiplyResponse& Calculator::multiplyResource::MultiplyResponse::xmlMultiplyResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlMultiplyResponse;
}

Calculator::multiplyResource::XMLMultiplyResponse& Calculator::multiplyResource::MultiplyResponse::xmlMultiplyResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlMultiplyResponse;
}




Calculator::divideResource::EmptyDivideResponse::EmptyDivideResponse()
{
    m_status = 0;
}

Calculator::divideResource::EmptyDivideResponse::~EmptyDivideResponse()
{
}

Calculator::divideResource::EmptyDivideResponse::EmptyDivideResponse(const EmptyDivideResponse &x)
{
    m_status = x.m_status;
}

Calculator::divideResource::EmptyDivideResponse::EmptyDivideResponse(EmptyDivideResponse &&x)
{
    m_status = x.m_status;
}

Calculator::divideResource::EmptyDivideResponse& Calculator::divideResource::EmptyDivideResponse::operator=(const EmptyDivideResponse &x)
{
    m_status = x.m_status;
    
    return *this;
}

Calculator::divideResource::EmptyDivideResponse& Calculator::divideResource::EmptyDivideResponse::operator=(EmptyDivideResponse &&x)
{
    m_status = x.m_status;
    
    return *this;
}


Calculator::divideResource::XMLDivideResponse::XMLDivideResponse()
{
    m_status = 0;
    m_xmlRepresentation = "";
}

Calculator::divideResource::XMLDivideResponse::~XMLDivideResponse()
{
}

Calculator::divideResource::XMLDivideResponse::XMLDivideResponse(const XMLDivideResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::divideResource::XMLDivideResponse::XMLDivideResponse(XMLDivideResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
}

Calculator::divideResource::XMLDivideResponse& Calculator::divideResource::XMLDivideResponse::operator=(const XMLDivideResponse &x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}

Calculator::divideResource::XMLDivideResponse& Calculator::divideResource::XMLDivideResponse::operator=(XMLDivideResponse &&x)
{
    m_status = x.m_status;
    m_xmlRepresentation = x.m_xmlRepresentation;
    
    return *this;
}


Calculator::divideResource::DivideResponse::DivideResponse()
{
    m__d = -1000;

}

Calculator::divideResource::DivideResponse::~DivideResponse()
{
}

Calculator::divideResource::DivideResponse::DivideResponse(const DivideResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyDivideResponse = x.m_emptyDivideResponse;
        break;
        case 1:
        m_xmlDivideResponse = x.m_xmlDivideResponse;
        break;
    }
}

Calculator::divideResource::DivideResponse::DivideResponse(DivideResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyDivideResponse = std::move(x.m_emptyDivideResponse);break;
        case 1:
        m_xmlDivideResponse = std::move(x.m_xmlDivideResponse);break;
    }
}

Calculator::divideResource::DivideResponse& Calculator::divideResource::DivideResponse::operator=(const DivideResponse &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyDivideResponse = x.m_emptyDivideResponse;
        break;
        case 1:
        m_xmlDivideResponse = x.m_xmlDivideResponse;
        break;
    }
    
    return *this;
}

Calculator::divideResource::DivideResponse& Calculator::divideResource::DivideResponse::operator=(DivideResponse &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case 0:
        m_emptyDivideResponse = std::move(x.m_emptyDivideResponse);break;
        case 1:
        m_xmlDivideResponse = std::move(x.m_xmlDivideResponse);break;
    }
    
    return *this;
}

void Calculator::divideResource::DivideResponse::_d(int32_t __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case 0:
        switch(__d)
        {
            case 0:
            b = true;
            break;
            default:
            break;
        }
        break;
        case 1:
        switch(__d)
        {
            case 1:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

int32_t Calculator::divideResource::DivideResponse::_d() const
{
    return m__d;
}

int32_t& Calculator::divideResource::DivideResponse::_d()
{
    return m__d;
}

void Calculator::divideResource::DivideResponse::emptyDivideResponse(const Calculator::divideResource::EmptyDivideResponse &_emptyDivideResponse)
{
    m_emptyDivideResponse = _emptyDivideResponse;
    m__d = 0;
}

void Calculator::divideResource::DivideResponse::emptyDivideResponse(Calculator::divideResource::EmptyDivideResponse &&_emptyDivideResponse)
{
    m_emptyDivideResponse = std::move(_emptyDivideResponse);
    m__d = 0;
}

const Calculator::divideResource::EmptyDivideResponse& Calculator::divideResource::DivideResponse::emptyDivideResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyDivideResponse;
}

Calculator::divideResource::EmptyDivideResponse& Calculator::divideResource::DivideResponse::emptyDivideResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 0:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_emptyDivideResponse;
}
void Calculator::divideResource::DivideResponse::xmlDivideResponse(const Calculator::divideResource::XMLDivideResponse &_xmlDivideResponse)
{
    m_xmlDivideResponse = _xmlDivideResponse;
    m__d = 1;
}

void Calculator::divideResource::DivideResponse::xmlDivideResponse(Calculator::divideResource::XMLDivideResponse &&_xmlDivideResponse)
{
    m_xmlDivideResponse = std::move(_xmlDivideResponse);
    m__d = 1;
}

const Calculator::divideResource::XMLDivideResponse& Calculator::divideResource::DivideResponse::xmlDivideResponse() const
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlDivideResponse;
}

Calculator::divideResource::XMLDivideResponse& Calculator::divideResource::DivideResponse::xmlDivideResponse()
{
    bool b = false;
        
    switch(m__d)
    {
        case 1:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xmlDivideResponse;
}




