/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcrest_LICENSE file included in this rpcrest distribution.
 *
 *************************************************************************
 * 
 * @file CalculatorRESTProtocol.cxx
 * This source file contains the definition of the protocol used to create REST messages.
 *
 * This file was generated by the tool rpcrestgen.
 */

#include "CalculatorRESTProtocol.h"
#include "rpcrest/exceptions/Exceptions.h"
#include "rpcrest/transports/ProxyTransport.h"
#include "rpcrest/transports/ServerTransport.h"
#include "rpcrest/protocols/rest/RESTSerializer.h"

using namespace eprosima::rpc;
using namespace ::protocol::rest;
using namespace ::transport;
using namespace eprosima::rpc::exception;

#include <sstream>

using namespace std;

CalculatorProtocol::CalculatorProtocol() {}

CalculatorProtocol::~CalculatorProtocol() {}

bool CalculatorProtocol::isNumeric(string&& myString) {
    stringstream ss(myString);
    float f;
    ss >> noskipws >> f;

    return ss.eof() && !ss.fail();
}

bool CalculatorProtocol::setTransport(Transport &transport)
{    
    if(strcmp(transport.getType(), "HTTP") != 0)
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    if(transport.getBehaviour() == SERVER_BEHAVIOUR)
    {
        // If this is a server transport, we set its callback
        eprosima::rpc::transport::ServerTransport &serverTransport = dynamic_cast<eprosima::rpc::transport::ServerTransport&>(transport);
        serverTransport.setCallback(&CalculatorProtocol::worker);
    }
        
    _setTransport(transport);
        
    return true;
}

bool CalculatorProtocol::activateInterface(const char* interfaceName)
{
    return true;
}

int CalculatorProtocol::deserializeContentLength(char* buffer) {
    char contentLength[16];
    strcpy(contentLength, "Content-Length:");
    char *p = strtok(buffer, "\r\n");
    while(p) {
        p[strlen(p)] = '\r'; // strtok puts a '\0', we don't want it
        if(memcmp(p, contentLength, 15) == 0) {
            return atoi(p+15); // 15 = "Content-Length:"
        }
        p = strtok(NULL, "\r\n");
    }

    return 0;
}

size_t CalculatorProtocol::worker(Protocol& protocol, void *&buffer, size_t &bufferLength, size_t &bufferSize, eprosima::rpc::transport::Endpoint *endpoint)
{
    // TODO : Call the protocol
    eprosima::rpc::protocol::rest::CalculatorProtocol &restProtocol = dynamic_cast<eprosima::rpc::protocol::rest::CalculatorProtocol&>( protocol );
    HttpMessage *httpMessage = reinterpret_cast<HttpMessage*>(buffer);

    HttpMessage response = restProtocol.processRequest(*httpMessage);
    
    dynamic_cast<ServerTransport&>(restProtocol.getTransport()).sendReply(&response, 0, endpoint);

    return 1;
}

// Server
HttpMessage CalculatorProtocol::processRequest(HttpMessage &httpMessage)
{
    RESTSerializer restSerializer;
    
    restSerializer.deserializeUri(httpMessage.getUri(), "/calculator/");
    
    // TODO Siempre se crea aunque no haya un error. Cambiar
    HttpMessage http404Response;
    http404Response.setResponseCode(404);
    http404Response.setResponseStatus("Resource not found");
    
    // BEGIN ITERATION 
    string tag;
    if(!restSerializer.existsTagLevel(0)) {
    return http404Response; // ERROR NO OPERATIONS
    }
    if(restSerializer.getTag(0).compare("add") == 0) {
    // BEGIN ITERATION add
    if(!restSerializer.existsTagLevel(1)) {
    if(httpMessage.getMethod() == HttpMessage::HTTP_METHOD_GET) {
    if(restSerializer.existsQueryParameter("a")&&restSerializer.existsQueryParameter("b")) {
    return deserialize_addResource_add(restSerializer, httpMessage); // MATCHING
    }
    }
    }
    // END ITERATION add
    }
    if(restSerializer.getTag(0).compare("substract") == 0) {
    // BEGIN ITERATION substract
    if(!restSerializer.existsTagLevel(1)) {
    if(httpMessage.getMethod() == HttpMessage::HTTP_METHOD_GET) {
    if(restSerializer.existsQueryParameter("a")&&restSerializer.existsQueryParameter("b")) {
    return deserialize_substractResource_substract(restSerializer, httpMessage); // MATCHING
    }
    }
    }
    // END ITERATION substract
    }
    if(restSerializer.getTag(0).compare("multiply") == 0) {
    // BEGIN ITERATION multiply
    if(!restSerializer.existsTagLevel(1)) {
    if(httpMessage.getMethod() == HttpMessage::HTTP_METHOD_GET) {
    if(restSerializer.existsQueryParameter("a")&&restSerializer.existsQueryParameter("b")) {
    return deserialize_multiplyResource_multiply(restSerializer, httpMessage); // MATCHING
    }
    }
    }
    // END ITERATION multiply
    }
    if(restSerializer.getTag(0).compare("divide") == 0) {
    // BEGIN ITERATION divide
    if(!restSerializer.existsTagLevel(1)) {
    if(httpMessage.getMethod() == HttpMessage::HTTP_METHOD_GET) {
    if(restSerializer.existsQueryParameter("a")&&restSerializer.existsQueryParameter("b")) {
    return deserialize_divideResource_divide(restSerializer, httpMessage); // MATCHING
    }
    }
    }
    // END ITERATION divide
    }
    // ERROR NO MATCH FOUND
    // END ITERATION 

    
    return http404Response;
}




Calculator::addResource::AddResponse CalculatorProtocol::Calculator_addResource_add(/*in*/ int32_t a, /*in*/ int32_t b)
{
     stringstream stream;
     RESTSerializer restSerializer;
     eprosima::rpc::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpc::transport::ProxyTransport&>( getTransport() );
     Calculator::addResource::AddResponse  add_ret;
     // XXX TODO if NULL -> error
     
     // Resource Base URI = /calculator/
     // Path = add
     // Method = GET
     // Body Parameter = 

     HttpMessage httpMessage;
     
     httpMessage.setMethod(HttpMessage::HTTP_METHOD_GET);
     //TODO Chequear host en el transport.
     httpMessage.setHost("example.com");
     std::string uri("/calculator/add"); 
     
        std::string paramValue;
        stream << a;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "a", paramValue);

        stream << b;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "b", paramValue);       

     
     httpMessage.setUri(uri);
     




     
     // HTTP connection
     // TODO Check connection error.
     proxyTransport.connect();
     proxyTransport.send(&httpMessage, 0);
     HttpMessage httpResponse;
     size_t dump;
     proxyTransport.receive(&httpResponse, 0, dump);
     
     
     int discriminator = 0;

     if(httpResponse.getBodyContentType().find("xml") != string::npos)
     {
        discriminator = 1;
     } 
     else if(httpResponse.getBodyContentType().find("json") != string::npos)
     {
        discriminator = 2;
     }
    
     switch(discriminator)
     {
     case 0:
          add_ret._d() = discriminator;
          add_ret.emptyAddResponse().status(httpResponse.getResponseCode());
          break;
          case 1:
          add_ret._d() = discriminator;
          add_ret.xmlAddResponse().status(httpResponse.getResponseCode());
          add_ret.xmlAddResponse().xmlRepresentation(httpResponse.getBodyData());
          break;
          
     }
     
              
     return add_ret;
}

HttpMessage CalculatorProtocol::deserialize_addResource_add(RESTSerializer &restSerializer, HttpMessage &httpMessage)
{
    std::stringstream stream;
    

    // Deserialize a
    int32_t  a = 0;
    stream << restSerializer.getQueryParameter("a");
    stream >> a;
    stream.str(std::string());
    stream.clear();

    // Deserialize b
    int32_t  b = 0;
    stream << restSerializer.getQueryParameter("b");
    stream >> b;
    stream.str(std::string());
    stream.clear();

    




    
    // TODO Check implementation.
    Calculator::addResource::AddResponse AddResponse = _Calculator_addResource_impl->add(  a, b  );
    
    HttpMessage httpResponse;
    switch(AddResponse._d())
    {
    case 0:
        httpResponse.setResponseCode(AddResponse.emptyAddResponse().status());
        break;
    case 1:
        httpResponse.setResponseCode(AddResponse.xmlAddResponse().status());
    httpResponse.setBodyData(AddResponse.xmlAddResponse().xmlRepresentation()); 
        break;

    }

    if(httpResponse.getBodyData().size() > 0)
    {
        if(AddResponse._d() == 1)
            httpResponse.setBodyContentType("application/xml");
        else if(AddResponse._d() == 2)
            httpResponse.setBodyContentType("application/json");
    }
    
    return httpResponse;
}



Calculator::substractResource::SubstractResponse CalculatorProtocol::Calculator_substractResource_substract(/*in*/ int32_t a, /*in*/ int32_t b)
{
     stringstream stream;
     RESTSerializer restSerializer;
     eprosima::rpc::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpc::transport::ProxyTransport&>( getTransport() );
     Calculator::substractResource::SubstractResponse  substract_ret;
     // XXX TODO if NULL -> error
     
     // Resource Base URI = /calculator/
     // Path = substract
     // Method = GET
     // Body Parameter = 

     HttpMessage httpMessage;
     
     httpMessage.setMethod(HttpMessage::HTTP_METHOD_GET);
     //TODO Chequear host en el transport.
     httpMessage.setHost("example.com");
     std::string uri("/calculator/substract"); 
     
        std::string paramValue;
        stream << a;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "a", paramValue);

        stream << b;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "b", paramValue);       

     
     httpMessage.setUri(uri);
     




     
     // HTTP connection
     // TODO Check connection error.
     proxyTransport.connect();
     proxyTransport.send(&httpMessage, 0);
     HttpMessage httpResponse;
     size_t dump;
     proxyTransport.receive(&httpResponse, 0, dump);
     
     
     int discriminator = 0;

     if(httpResponse.getBodyContentType().find("xml") != string::npos)
     {
        discriminator = 1;
     } 
     else if(httpResponse.getBodyContentType().find("json") != string::npos)
     {
        discriminator = 2;
     }
    
     switch(discriminator)
     {
     case 0:
          substract_ret._d() = discriminator;
          substract_ret.emptySubstractResponse().status(httpResponse.getResponseCode());
          break;
          case 1:
          substract_ret._d() = discriminator;
          substract_ret.xmlSubstractResponse().status(httpResponse.getResponseCode());
          substract_ret.xmlSubstractResponse().xmlRepresentation(httpResponse.getBodyData());
          break;
          
     }
     
              
     return substract_ret;
}

HttpMessage CalculatorProtocol::deserialize_substractResource_substract(RESTSerializer &restSerializer, HttpMessage &httpMessage)
{
    std::stringstream stream;
    

    // Deserialize a
    int32_t  a = 0;
    stream << restSerializer.getQueryParameter("a");
    stream >> a;
    stream.str(std::string());
    stream.clear();

    // Deserialize b
    int32_t  b = 0;
    stream << restSerializer.getQueryParameter("b");
    stream >> b;
    stream.str(std::string());
    stream.clear();

    




    
    // TODO Check implementation.
    Calculator::substractResource::SubstractResponse SubstractResponse = _Calculator_substractResource_impl->substract(  a, b  );
    
    HttpMessage httpResponse;
    switch(SubstractResponse._d())
    {
    case 0:
        httpResponse.setResponseCode(SubstractResponse.emptySubstractResponse().status());
        break;
    case 1:
        httpResponse.setResponseCode(SubstractResponse.xmlSubstractResponse().status());
    httpResponse.setBodyData(SubstractResponse.xmlSubstractResponse().xmlRepresentation()); 
        break;

    }

    if(httpResponse.getBodyData().size() > 0)
    {
        if(SubstractResponse._d() == 1)
            httpResponse.setBodyContentType("application/xml");
        else if(SubstractResponse._d() == 2)
            httpResponse.setBodyContentType("application/json");
    }
    
    return httpResponse;
}



Calculator::multiplyResource::MultiplyResponse CalculatorProtocol::Calculator_multiplyResource_multiply(/*in*/ int32_t a, /*in*/ int32_t b)
{
     stringstream stream;
     RESTSerializer restSerializer;
     eprosima::rpc::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpc::transport::ProxyTransport&>( getTransport() );
     Calculator::multiplyResource::MultiplyResponse  multiply_ret;
     // XXX TODO if NULL -> error
     
     // Resource Base URI = /calculator/
     // Path = multiply
     // Method = GET
     // Body Parameter = 

     HttpMessage httpMessage;
     
     httpMessage.setMethod(HttpMessage::HTTP_METHOD_GET);
     //TODO Chequear host en el transport.
     httpMessage.setHost("example.com");
     std::string uri("/calculator/multiply"); 
     
        std::string paramValue;
        stream << a;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "a", paramValue);

        stream << b;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "b", paramValue);       

     
     httpMessage.setUri(uri);
     




     
     // HTTP connection
     // TODO Check connection error.
     proxyTransport.connect();
     proxyTransport.send(&httpMessage, 0);
     HttpMessage httpResponse;
     size_t dump;
     proxyTransport.receive(&httpResponse, 0, dump);
     
     
     int discriminator = 0;

     if(httpResponse.getBodyContentType().find("xml") != string::npos)
     {
        discriminator = 1;
     } 
     else if(httpResponse.getBodyContentType().find("json") != string::npos)
     {
        discriminator = 2;
     }
    
     switch(discriminator)
     {
     case 0:
          multiply_ret._d() = discriminator;
          multiply_ret.emptyMultiplyResponse().status(httpResponse.getResponseCode());
          break;
          case 1:
          multiply_ret._d() = discriminator;
          multiply_ret.xmlMultiplyResponse().status(httpResponse.getResponseCode());
          multiply_ret.xmlMultiplyResponse().xmlRepresentation(httpResponse.getBodyData());
          break;
          
     }
     
              
     return multiply_ret;
}

HttpMessage CalculatorProtocol::deserialize_multiplyResource_multiply(RESTSerializer &restSerializer, HttpMessage &httpMessage)
{
    std::stringstream stream;
    

    // Deserialize a
    int32_t  a = 0;
    stream << restSerializer.getQueryParameter("a");
    stream >> a;
    stream.str(std::string());
    stream.clear();

    // Deserialize b
    int32_t  b = 0;
    stream << restSerializer.getQueryParameter("b");
    stream >> b;
    stream.str(std::string());
    stream.clear();

    




    
    // TODO Check implementation.
    Calculator::multiplyResource::MultiplyResponse MultiplyResponse = _Calculator_multiplyResource_impl->multiply(  a, b  );
    
    HttpMessage httpResponse;
    switch(MultiplyResponse._d())
    {
    case 0:
        httpResponse.setResponseCode(MultiplyResponse.emptyMultiplyResponse().status());
        break;
    case 1:
        httpResponse.setResponseCode(MultiplyResponse.xmlMultiplyResponse().status());
    httpResponse.setBodyData(MultiplyResponse.xmlMultiplyResponse().xmlRepresentation()); 
        break;

    }

    if(httpResponse.getBodyData().size() > 0)
    {
        if(MultiplyResponse._d() == 1)
            httpResponse.setBodyContentType("application/xml");
        else if(MultiplyResponse._d() == 2)
            httpResponse.setBodyContentType("application/json");
    }
    
    return httpResponse;
}



Calculator::divideResource::DivideResponse CalculatorProtocol::Calculator_divideResource_divide(/*in*/ int32_t a, /*in*/ int32_t b)
{
     stringstream stream;
     RESTSerializer restSerializer;
     eprosima::rpc::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpc::transport::ProxyTransport&>( getTransport() );
     Calculator::divideResource::DivideResponse  divide_ret;
     // XXX TODO if NULL -> error
     
     // Resource Base URI = /calculator/
     // Path = divide
     // Method = GET
     // Body Parameter = 

     HttpMessage httpMessage;
     
     httpMessage.setMethod(HttpMessage::HTTP_METHOD_GET);
     //TODO Chequear host en el transport.
     httpMessage.setHost("example.com");
     std::string uri("/calculator/divide"); 
     
        std::string paramValue;
        stream << a;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "a", paramValue);

        stream << b;
        paramValue = stream.str();
        stream.str(std::string());
        stream.clear();
        restSerializer.serializeQueryParameter(uri, "b", paramValue);       

     
     httpMessage.setUri(uri);
     




     
     // HTTP connection
     // TODO Check connection error.
     proxyTransport.connect();
     proxyTransport.send(&httpMessage, 0);
     HttpMessage httpResponse;
     size_t dump;
     proxyTransport.receive(&httpResponse, 0, dump);
     
     
     int discriminator = 0;

     if(httpResponse.getBodyContentType().find("xml") != string::npos)
     {
        discriminator = 1;
     } 
     else if(httpResponse.getBodyContentType().find("json") != string::npos)
     {
        discriminator = 2;
     }
    
     switch(discriminator)
     {
     case 0:
          divide_ret._d() = discriminator;
          divide_ret.emptyDivideResponse().status(httpResponse.getResponseCode());
          break;
          case 1:
          divide_ret._d() = discriminator;
          divide_ret.xmlDivideResponse().status(httpResponse.getResponseCode());
          divide_ret.xmlDivideResponse().xmlRepresentation(httpResponse.getBodyData());
          break;
          
     }
     
              
     return divide_ret;
}

HttpMessage CalculatorProtocol::deserialize_divideResource_divide(RESTSerializer &restSerializer, HttpMessage &httpMessage)
{
    std::stringstream stream;
    

    // Deserialize a
    int32_t  a = 0;
    stream << restSerializer.getQueryParameter("a");
    stream >> a;
    stream.str(std::string());
    stream.clear();

    // Deserialize b
    int32_t  b = 0;
    stream << restSerializer.getQueryParameter("b");
    stream >> b;
    stream.str(std::string());
    stream.clear();

    




    
    // TODO Check implementation.
    Calculator::divideResource::DivideResponse DivideResponse = _Calculator_divideResource_impl->divide(  a, b  );
    
    HttpMessage httpResponse;
    switch(DivideResponse._d())
    {
    case 0:
        httpResponse.setResponseCode(DivideResponse.emptyDivideResponse().status());
        break;
    case 1:
        httpResponse.setResponseCode(DivideResponse.xmlDivideResponse().status());
    httpResponse.setBodyData(DivideResponse.xmlDivideResponse().xmlRepresentation()); 
        break;

    }

    if(httpResponse.getBodyData().size() > 0)
    {
        if(DivideResponse._d() == 1)
            httpResponse.setBodyContentType("application/xml");
        else if(DivideResponse._d() == 2)
            httpResponse.setBodyContentType("application/json");
    }
    
    return httpResponse;
}

