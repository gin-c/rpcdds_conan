/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 *
 * @file AIOpenApiTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "AIOpenApiTopics.h"

#include <fastcdr/Cdr.h>
#include <fastcdr/exceptions/BadParamException.h>
#include <rpcdds/exceptions/BadParamException.h>

AI::OpenApi::VSP_beginVoice_In::VSP_beginVoice_In() : m_dummy(0) {}

AI::OpenApi::VSP_beginVoice_In::~VSP_beginVoice_In() {}

AI::OpenApi::VSP_beginVoice_In::VSP_beginVoice_In(const VSP_beginVoice_In &x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_beginVoice_In::VSP_beginVoice_In(VSP_beginVoice_In &&x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_beginVoice_In &AI::OpenApi::VSP_beginVoice_In::operator=(const AI::OpenApi::VSP_beginVoice_In &x) {
    m_dummy = x.m_dummy;

    return *this;
}

AI::OpenApi::VSP_beginVoice_In &AI::OpenApi::VSP_beginVoice_In::operator=(AI::OpenApi::VSP_beginVoice_In &&x) {
    m_dummy = x.m_dummy;

    return *this;
}

size_t AI::OpenApi::VSP_beginVoice_In::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_beginVoice_In::getCdrSerializedSize(const AI::OpenApi::VSP_beginVoice_In &data,
                                                            size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_beginVoice_In::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_dummy; }

void AI::OpenApi::VSP_beginVoice_In::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_dummy; }

AI::OpenApi::VSP_beginVoice_Out::VSP_beginVoice_Out() : m_return_(false) {}

AI::OpenApi::VSP_beginVoice_Out::~VSP_beginVoice_Out() {}

AI::OpenApi::VSP_beginVoice_Out::VSP_beginVoice_Out(const VSP_beginVoice_Out &x) : m_return_(x.m_return_) {}

AI::OpenApi::VSP_beginVoice_Out::VSP_beginVoice_Out(VSP_beginVoice_Out &&x) : m_return_(std::move(x.m_return_)) {}

AI::OpenApi::VSP_beginVoice_Out &AI::OpenApi::VSP_beginVoice_Out::operator=(const AI::OpenApi::VSP_beginVoice_Out &x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

AI::OpenApi::VSP_beginVoice_Out &AI::OpenApi::VSP_beginVoice_Out::operator=(AI::OpenApi::VSP_beginVoice_Out &&x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_beginVoice_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_beginVoice_Out::getCdrSerializedSize(const AI::OpenApi::VSP_beginVoice_Out &data,
                                                             size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_beginVoice_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_return_; }

void AI::OpenApi::VSP_beginVoice_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_return_; }

AI::OpenApi::VSP_beginVoice_Result::VSP_beginVoice_Result() : m__d(2) {}

AI::OpenApi::VSP_beginVoice_Result::~VSP_beginVoice_Result() {}

AI::OpenApi::VSP_beginVoice_Result::VSP_beginVoice_Result(const VSP_beginVoice_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_beginVoice_Result::VSP_beginVoice_Result(VSP_beginVoice_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_beginVoice_Result &AI::OpenApi::VSP_beginVoice_Result::operator=(
    const AI::OpenApi::VSP_beginVoice_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_beginVoice_Result &AI::OpenApi::VSP_beginVoice_Result::operator=(
    AI::OpenApi::VSP_beginVoice_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_beginVoice_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_beginVoice_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_beginVoice_Result::_d() { return m__d; }

void AI::OpenApi::VSP_beginVoice_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_beginVoice_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_beginVoice_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_beginVoice_Result::result(const AI::OpenApi::VSP_beginVoice_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_beginVoice_Result::result(AI::OpenApi::VSP_beginVoice_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_beginVoice_Out &AI::OpenApi::VSP_beginVoice_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_beginVoice_Out &AI::OpenApi::VSP_beginVoice_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_beginVoice_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_beginVoice_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_beginVoice_Result::getCdrSerializedSize(const AI::OpenApi::VSP_beginVoice_Result &data,
                                                                size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_beginVoice_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_beginVoice_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_beginVoice_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_stopVoice_In::VSP_stopVoice_In() : m_dummy(0) {}

AI::OpenApi::VSP_stopVoice_In::~VSP_stopVoice_In() {}

AI::OpenApi::VSP_stopVoice_In::VSP_stopVoice_In(const VSP_stopVoice_In &x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_stopVoice_In::VSP_stopVoice_In(VSP_stopVoice_In &&x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_stopVoice_In &AI::OpenApi::VSP_stopVoice_In::operator=(const AI::OpenApi::VSP_stopVoice_In &x) {
    m_dummy = x.m_dummy;

    return *this;
}

AI::OpenApi::VSP_stopVoice_In &AI::OpenApi::VSP_stopVoice_In::operator=(AI::OpenApi::VSP_stopVoice_In &&x) {
    m_dummy = x.m_dummy;

    return *this;
}

size_t AI::OpenApi::VSP_stopVoice_In::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_stopVoice_In::getCdrSerializedSize(const AI::OpenApi::VSP_stopVoice_In &data,
                                                           size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_stopVoice_In::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_dummy; }

void AI::OpenApi::VSP_stopVoice_In::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_dummy; }

AI::OpenApi::VSP_stopVoice_Out::VSP_stopVoice_Out() : m_return_(false) {}

AI::OpenApi::VSP_stopVoice_Out::~VSP_stopVoice_Out() {}

AI::OpenApi::VSP_stopVoice_Out::VSP_stopVoice_Out(const VSP_stopVoice_Out &x) : m_return_(x.m_return_) {}

AI::OpenApi::VSP_stopVoice_Out::VSP_stopVoice_Out(VSP_stopVoice_Out &&x) : m_return_(std::move(x.m_return_)) {}

AI::OpenApi::VSP_stopVoice_Out &AI::OpenApi::VSP_stopVoice_Out::operator=(const AI::OpenApi::VSP_stopVoice_Out &x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

AI::OpenApi::VSP_stopVoice_Out &AI::OpenApi::VSP_stopVoice_Out::operator=(AI::OpenApi::VSP_stopVoice_Out &&x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_stopVoice_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_stopVoice_Out::getCdrSerializedSize(const AI::OpenApi::VSP_stopVoice_Out &data,
                                                            size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_stopVoice_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_return_; }

void AI::OpenApi::VSP_stopVoice_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_return_; }

AI::OpenApi::VSP_stopVoice_Result::VSP_stopVoice_Result() : m__d(2) {}

AI::OpenApi::VSP_stopVoice_Result::~VSP_stopVoice_Result() {}

AI::OpenApi::VSP_stopVoice_Result::VSP_stopVoice_Result(const VSP_stopVoice_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_stopVoice_Result::VSP_stopVoice_Result(VSP_stopVoice_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_stopVoice_Result &AI::OpenApi::VSP_stopVoice_Result::operator=(
    const AI::OpenApi::VSP_stopVoice_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_stopVoice_Result &AI::OpenApi::VSP_stopVoice_Result::operator=(AI::OpenApi::VSP_stopVoice_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_stopVoice_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_stopVoice_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_stopVoice_Result::_d() { return m__d; }

void AI::OpenApi::VSP_stopVoice_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_stopVoice_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_stopVoice_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_stopVoice_Result::result(const AI::OpenApi::VSP_stopVoice_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_stopVoice_Result::result(AI::OpenApi::VSP_stopVoice_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_stopVoice_Out &AI::OpenApi::VSP_stopVoice_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_stopVoice_Out &AI::OpenApi::VSP_stopVoice_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_stopVoice_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_stopVoice_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_stopVoice_Result::getCdrSerializedSize(const AI::OpenApi::VSP_stopVoice_Result &data,
                                                               size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_stopVoice_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_stopVoice_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_stopVoice_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_init_Out::VSP_init_Out() : m_state(0) {}

AI::OpenApi::VSP_init_Out::~VSP_init_Out() {}

AI::OpenApi::VSP_init_Out::VSP_init_Out(const VSP_init_Out &x) : m_state(x.m_state) {}

AI::OpenApi::VSP_init_Out::VSP_init_Out(VSP_init_Out &&x) : m_state(std::move(x.m_state)) {}

AI::OpenApi::VSP_init_Out &AI::OpenApi::VSP_init_Out::operator=(const AI::OpenApi::VSP_init_Out &x) {
    m_state = x.m_state;
    ;

    return *this;
}

AI::OpenApi::VSP_init_Out &AI::OpenApi::VSP_init_Out::operator=(AI::OpenApi::VSP_init_Out &&x) {
    m_state = x.m_state;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_init_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_init_Out::getCdrSerializedSize(const AI::OpenApi::VSP_init_Out &data,
                                                       size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_init_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_state; }

void AI::OpenApi::VSP_init_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_state; }

AI::OpenApi::VSP_init_Result::VSP_init_Result() : m__d(2) {}

AI::OpenApi::VSP_init_Result::~VSP_init_Result() {}

AI::OpenApi::VSP_init_Result::VSP_init_Result(const VSP_init_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_init_Result::VSP_init_Result(VSP_init_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_init_Result &AI::OpenApi::VSP_init_Result::operator=(const AI::OpenApi::VSP_init_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_init_Result &AI::OpenApi::VSP_init_Result::operator=(AI::OpenApi::VSP_init_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_init_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_init_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_init_Result::_d() { return m__d; }

void AI::OpenApi::VSP_init_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_init_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_init_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_init_Result::result(const AI::OpenApi::VSP_init_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_init_Result::result(AI::OpenApi::VSP_init_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_init_Out &AI::OpenApi::VSP_init_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_init_Out &AI::OpenApi::VSP_init_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_init_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_init_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_init_Result::getCdrSerializedSize(const AI::OpenApi::VSP_init_Result &data,
                                                          size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_init_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_init_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_init_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_ready_Out::VSP_ready_Out() : m_dummy(0) {}

AI::OpenApi::VSP_ready_Out::~VSP_ready_Out() {}

AI::OpenApi::VSP_ready_Out::VSP_ready_Out(const VSP_ready_Out &x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_ready_Out::VSP_ready_Out(VSP_ready_Out &&x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_ready_Out &AI::OpenApi::VSP_ready_Out::operator=(const AI::OpenApi::VSP_ready_Out &x) {
    m_dummy = x.m_dummy;

    return *this;
}

AI::OpenApi::VSP_ready_Out &AI::OpenApi::VSP_ready_Out::operator=(AI::OpenApi::VSP_ready_Out &&x) {
    m_dummy = x.m_dummy;

    return *this;
}

size_t AI::OpenApi::VSP_ready_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_ready_Out::getCdrSerializedSize(const AI::OpenApi::VSP_ready_Out &data,
                                                        size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_ready_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_dummy; }

void AI::OpenApi::VSP_ready_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_dummy; }

AI::OpenApi::VSP_ready_Result::VSP_ready_Result() : m__d(2) {}

AI::OpenApi::VSP_ready_Result::~VSP_ready_Result() {}

AI::OpenApi::VSP_ready_Result::VSP_ready_Result(const VSP_ready_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_ready_Result::VSP_ready_Result(VSP_ready_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_ready_Result &AI::OpenApi::VSP_ready_Result::operator=(const AI::OpenApi::VSP_ready_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_ready_Result &AI::OpenApi::VSP_ready_Result::operator=(AI::OpenApi::VSP_ready_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_ready_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_ready_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_ready_Result::_d() { return m__d; }

void AI::OpenApi::VSP_ready_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_ready_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_ready_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_ready_Result::result(const AI::OpenApi::VSP_ready_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_ready_Result::result(AI::OpenApi::VSP_ready_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_ready_Out &AI::OpenApi::VSP_ready_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_ready_Out &AI::OpenApi::VSP_ready_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_ready_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_ready_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_ready_Result::getCdrSerializedSize(const AI::OpenApi::VSP_ready_Result &data,
                                                           size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_ready_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_ready_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_ready_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_vadBegin_Out::VSP_vadBegin_Out() : m_dummy(0) {}

AI::OpenApi::VSP_vadBegin_Out::~VSP_vadBegin_Out() {}

AI::OpenApi::VSP_vadBegin_Out::VSP_vadBegin_Out(const VSP_vadBegin_Out &x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_vadBegin_Out::VSP_vadBegin_Out(VSP_vadBegin_Out &&x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_vadBegin_Out &AI::OpenApi::VSP_vadBegin_Out::operator=(const AI::OpenApi::VSP_vadBegin_Out &x) {
    m_dummy = x.m_dummy;

    return *this;
}

AI::OpenApi::VSP_vadBegin_Out &AI::OpenApi::VSP_vadBegin_Out::operator=(AI::OpenApi::VSP_vadBegin_Out &&x) {
    m_dummy = x.m_dummy;

    return *this;
}

size_t AI::OpenApi::VSP_vadBegin_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_vadBegin_Out::getCdrSerializedSize(const AI::OpenApi::VSP_vadBegin_Out &data,
                                                           size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_vadBegin_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_dummy; }

void AI::OpenApi::VSP_vadBegin_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_dummy; }

AI::OpenApi::VSP_vadBegin_Result::VSP_vadBegin_Result() : m__d(2) {}

AI::OpenApi::VSP_vadBegin_Result::~VSP_vadBegin_Result() {}

AI::OpenApi::VSP_vadBegin_Result::VSP_vadBegin_Result(const VSP_vadBegin_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_vadBegin_Result::VSP_vadBegin_Result(VSP_vadBegin_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_vadBegin_Result &AI::OpenApi::VSP_vadBegin_Result::operator=(
    const AI::OpenApi::VSP_vadBegin_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_vadBegin_Result &AI::OpenApi::VSP_vadBegin_Result::operator=(AI::OpenApi::VSP_vadBegin_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_vadBegin_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_vadBegin_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_vadBegin_Result::_d() { return m__d; }

void AI::OpenApi::VSP_vadBegin_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_vadBegin_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_vadBegin_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_vadBegin_Result::result(const AI::OpenApi::VSP_vadBegin_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_vadBegin_Result::result(AI::OpenApi::VSP_vadBegin_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_vadBegin_Out &AI::OpenApi::VSP_vadBegin_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_vadBegin_Out &AI::OpenApi::VSP_vadBegin_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_vadBegin_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_vadBegin_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_vadBegin_Result::getCdrSerializedSize(const AI::OpenApi::VSP_vadBegin_Result &data,
                                                              size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_vadBegin_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_vadBegin_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_vadBegin_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_vadEnd_Out::VSP_vadEnd_Out() : m_dummy(0) {}

AI::OpenApi::VSP_vadEnd_Out::~VSP_vadEnd_Out() {}

AI::OpenApi::VSP_vadEnd_Out::VSP_vadEnd_Out(const VSP_vadEnd_Out &x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_vadEnd_Out::VSP_vadEnd_Out(VSP_vadEnd_Out &&x) : m_dummy(x.m_dummy) {}

AI::OpenApi::VSP_vadEnd_Out &AI::OpenApi::VSP_vadEnd_Out::operator=(const AI::OpenApi::VSP_vadEnd_Out &x) {
    m_dummy = x.m_dummy;

    return *this;
}

AI::OpenApi::VSP_vadEnd_Out &AI::OpenApi::VSP_vadEnd_Out::operator=(AI::OpenApi::VSP_vadEnd_Out &&x) {
    m_dummy = x.m_dummy;

    return *this;
}

size_t AI::OpenApi::VSP_vadEnd_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_vadEnd_Out::getCdrSerializedSize(const AI::OpenApi::VSP_vadEnd_Out &data,
                                                         size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_vadEnd_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_dummy; }

void AI::OpenApi::VSP_vadEnd_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_dummy; }

AI::OpenApi::VSP_vadEnd_Result::VSP_vadEnd_Result() : m__d(2) {}

AI::OpenApi::VSP_vadEnd_Result::~VSP_vadEnd_Result() {}

AI::OpenApi::VSP_vadEnd_Result::VSP_vadEnd_Result(const VSP_vadEnd_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_vadEnd_Result::VSP_vadEnd_Result(VSP_vadEnd_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_vadEnd_Result &AI::OpenApi::VSP_vadEnd_Result::operator=(const AI::OpenApi::VSP_vadEnd_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_vadEnd_Result &AI::OpenApi::VSP_vadEnd_Result::operator=(AI::OpenApi::VSP_vadEnd_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_vadEnd_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_vadEnd_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_vadEnd_Result::_d() { return m__d; }

void AI::OpenApi::VSP_vadEnd_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_vadEnd_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_vadEnd_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_vadEnd_Result::result(const AI::OpenApi::VSP_vadEnd_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_vadEnd_Result::result(AI::OpenApi::VSP_vadEnd_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_vadEnd_Out &AI::OpenApi::VSP_vadEnd_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_vadEnd_Out &AI::OpenApi::VSP_vadEnd_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_vadEnd_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_vadEnd_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_vadEnd_Result::getCdrSerializedSize(const AI::OpenApi::VSP_vadEnd_Result &data,
                                                            size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_vadEnd_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_vadEnd_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_vadEnd_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_error_Out::VSP_error_Out() : m_error() {}

AI::OpenApi::VSP_error_Out::~VSP_error_Out() {}

AI::OpenApi::VSP_error_Out::VSP_error_Out(const VSP_error_Out &x) : m_error(x.m_error) {}

AI::OpenApi::VSP_error_Out::VSP_error_Out(VSP_error_Out &&x) : m_error(std::move(x.m_error)) {}

AI::OpenApi::VSP_error_Out &AI::OpenApi::VSP_error_Out::operator=(const AI::OpenApi::VSP_error_Out &x) {
    m_error = x.m_error;
    ;

    return *this;
}

AI::OpenApi::VSP_error_Out &AI::OpenApi::VSP_error_Out::operator=(AI::OpenApi::VSP_error_Out &&x) {
    m_error = x.m_error;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_error_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += AI::Error::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_error_Out::getCdrSerializedSize(const AI::OpenApi::VSP_error_Out &data,
                                                        size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += AI::Error::getCdrSerializedSize(data.error(), current_alignment);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_error_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_error; }

void AI::OpenApi::VSP_error_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_error; }

AI::OpenApi::VSP_error_Result::VSP_error_Result() : m__d(2) {}

AI::OpenApi::VSP_error_Result::~VSP_error_Result() {}

AI::OpenApi::VSP_error_Result::VSP_error_Result(const VSP_error_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_error_Result::VSP_error_Result(VSP_error_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_error_Result &AI::OpenApi::VSP_error_Result::operator=(const AI::OpenApi::VSP_error_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_error_Result &AI::OpenApi::VSP_error_Result::operator=(AI::OpenApi::VSP_error_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_error_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_error_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_error_Result::_d() { return m__d; }

void AI::OpenApi::VSP_error_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_error_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_error_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_error_Result::result(const AI::OpenApi::VSP_error_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_error_Result::result(AI::OpenApi::VSP_error_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_error_Out &AI::OpenApi::VSP_error_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_error_Out &AI::OpenApi::VSP_error_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_error_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_error_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_error_Result::getCdrSerializedSize(const AI::OpenApi::VSP_error_Result &data,
                                                           size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_error_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_error_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_error_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_partial_Out::VSP_partial_Out() : m_text() {}

AI::OpenApi::VSP_partial_Out::~VSP_partial_Out() {}

AI::OpenApi::VSP_partial_Out::VSP_partial_Out(const VSP_partial_Out &x) : m_text(x.m_text) {}

AI::OpenApi::VSP_partial_Out::VSP_partial_Out(VSP_partial_Out &&x) : m_text(std::move(x.m_text)) {}

AI::OpenApi::VSP_partial_Out &AI::OpenApi::VSP_partial_Out::operator=(const AI::OpenApi::VSP_partial_Out &x) {
    m_text = x.m_text;
    ;

    return *this;
}

AI::OpenApi::VSP_partial_Out &AI::OpenApi::VSP_partial_Out::operator=(AI::OpenApi::VSP_partial_Out &&x) {
    m_text = x.m_text;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_partial_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 1024 + 1;

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_partial_Out::getCdrSerializedSize(const AI::OpenApi::VSP_partial_Out &data,
                                                          size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.text().size() + 1;

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_partial_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_text; }

void AI::OpenApi::VSP_partial_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_text; }

AI::OpenApi::VSP_partial_Result::VSP_partial_Result() : m__d(2) {}

AI::OpenApi::VSP_partial_Result::~VSP_partial_Result() {}

AI::OpenApi::VSP_partial_Result::VSP_partial_Result(const VSP_partial_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_partial_Result::VSP_partial_Result(VSP_partial_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_partial_Result &AI::OpenApi::VSP_partial_Result::operator=(const AI::OpenApi::VSP_partial_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_partial_Result &AI::OpenApi::VSP_partial_Result::operator=(AI::OpenApi::VSP_partial_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_partial_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_partial_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_partial_Result::_d() { return m__d; }

void AI::OpenApi::VSP_partial_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_partial_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_partial_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_partial_Result::result(const AI::OpenApi::VSP_partial_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_partial_Result::result(AI::OpenApi::VSP_partial_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_partial_Out &AI::OpenApi::VSP_partial_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_partial_Out &AI::OpenApi::VSP_partial_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_partial_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_partial_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_partial_Result::getCdrSerializedSize(const AI::OpenApi::VSP_partial_Result &data,
                                                             size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_partial_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_partial_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_partial_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_finalResult_Out::VSP_finalResult_Out() : m_text() {}

AI::OpenApi::VSP_finalResult_Out::~VSP_finalResult_Out() {}

AI::OpenApi::VSP_finalResult_Out::VSP_finalResult_Out(const VSP_finalResult_Out &x) : m_text(x.m_text) {}

AI::OpenApi::VSP_finalResult_Out::VSP_finalResult_Out(VSP_finalResult_Out &&x) : m_text(std::move(x.m_text)) {}

AI::OpenApi::VSP_finalResult_Out &AI::OpenApi::VSP_finalResult_Out::operator=(
    const AI::OpenApi::VSP_finalResult_Out &x) {
    m_text = x.m_text;
    ;

    return *this;
}

AI::OpenApi::VSP_finalResult_Out &AI::OpenApi::VSP_finalResult_Out::operator=(AI::OpenApi::VSP_finalResult_Out &&x) {
    m_text = x.m_text;
    ;

    return *this;
}

size_t AI::OpenApi::VSP_finalResult_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 1024 + 1;

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_finalResult_Out::getCdrSerializedSize(const AI::OpenApi::VSP_finalResult_Out &data,
                                                              size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.text().size() + 1;

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_finalResult_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_text; }

void AI::OpenApi::VSP_finalResult_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_text; }

AI::OpenApi::VSP_finalResult_Result::VSP_finalResult_Result() : m__d(2) {}

AI::OpenApi::VSP_finalResult_Result::~VSP_finalResult_Result() {}

AI::OpenApi::VSP_finalResult_Result::VSP_finalResult_Result(const VSP_finalResult_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::VSP_finalResult_Result::VSP_finalResult_Result(VSP_finalResult_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::VSP_finalResult_Result &AI::OpenApi::VSP_finalResult_Result::operator=(
    const AI::OpenApi::VSP_finalResult_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_finalResult_Result &AI::OpenApi::VSP_finalResult_Result::operator=(
    AI::OpenApi::VSP_finalResult_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_finalResult_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_finalResult_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_finalResult_Result::_d() { return m__d; }

void AI::OpenApi::VSP_finalResult_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::VSP_finalResult_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::VSP_finalResult_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::VSP_finalResult_Result::result(const AI::OpenApi::VSP_finalResult_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::VSP_finalResult_Result::result(AI::OpenApi::VSP_finalResult_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::VSP_finalResult_Out &AI::OpenApi::VSP_finalResult_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::VSP_finalResult_Out &AI::OpenApi::VSP_finalResult_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::VSP_finalResult_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::VSP_finalResult_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_finalResult_Result::getCdrSerializedSize(const AI::OpenApi::VSP_finalResult_Result &data,
                                                                 size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += VSP_finalResult_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_finalResult_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::VSP_finalResult_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::VSP_Call::VSP_Call() : m__d(0) {}

AI::OpenApi::VSP_Call::~VSP_Call() {}

AI::OpenApi::VSP_Call::VSP_Call(const VSP_Call &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = x.m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = x.m_stopVoice;
            break;
    }
}

AI::OpenApi::VSP_Call::VSP_Call(VSP_Call &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = std::move(x.m_beginVoice);
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = std::move(x.m_stopVoice);
            break;
    }
}

AI::OpenApi::VSP_Call &AI::OpenApi::VSP_Call::operator=(const VSP_Call &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = x.m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = x.m_stopVoice;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_Call &AI::OpenApi::VSP_Call::operator=(VSP_Call &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = std::move(x.m_beginVoice);
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = std::move(x.m_stopVoice);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_Call::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_Call::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_Call::_d() { return m__d; }

void AI::OpenApi::VSP_Call::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp) {
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation AI::OpenApi::VSP_Call::unknownOp() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation &AI::OpenApi::VSP_Call::unknownOp() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

void AI::OpenApi::VSP_Call::beginVoice(const AI::OpenApi::VSP_beginVoice_In &_beginVoice) {
    m_beginVoice = _beginVoice;
    m__d = (int32_t)0x68F1FC67;
}

void AI::OpenApi::VSP_Call::beginVoice(AI::OpenApi::VSP_beginVoice_In &&_beginVoice) {
    m_beginVoice = std::move(_beginVoice);
    m__d = (int32_t)0x68F1FC67;
}

const AI::OpenApi::VSP_beginVoice_In &AI::OpenApi::VSP_Call::beginVoice() const {
    if (m__d != (int32_t)0x68F1FC67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_beginVoice;
}

AI::OpenApi::VSP_beginVoice_In &AI::OpenApi::VSP_Call::beginVoice() {
    if (m__d != (int32_t)0x68F1FC67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_beginVoice;
}
void AI::OpenApi::VSP_Call::stopVoice(const AI::OpenApi::VSP_stopVoice_In &_stopVoice) {
    m_stopVoice = _stopVoice;
    m__d = (int32_t)0xD928FA97;
}

void AI::OpenApi::VSP_Call::stopVoice(AI::OpenApi::VSP_stopVoice_In &&_stopVoice) {
    m_stopVoice = std::move(_stopVoice);
    m__d = (int32_t)0xD928FA97;
}

const AI::OpenApi::VSP_stopVoice_In &AI::OpenApi::VSP_Call::stopVoice() const {
    if (m__d != (int32_t)0xD928FA97)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_stopVoice;
}

AI::OpenApi::VSP_stopVoice_In &AI::OpenApi::VSP_Call::stopVoice() {
    if (m__d != (int32_t)0xD928FA97)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_stopVoice;
}

size_t AI::OpenApi::VSP_Call::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknownOp attribute;
    union_max_size_serialized = current_alignment + 1;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_beginVoice_In::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_stopVoice_In::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_Call::getCdrSerializedSize(const AI::OpenApi::VSP_Call &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case (int32_t)0x68F1FC67:
            current_alignment += VSP_beginVoice_In::getCdrSerializedSize(data.m_beginVoice, current_alignment);
            break;

        case (int32_t)0xD928FA97:
            current_alignment += VSP_stopVoice_In::getCdrSerializedSize(data.m_stopVoice, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_Call::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            scdr << m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            scdr << m_stopVoice;
            break;

        default:
            scdr << m_unknownOp;
            break;
    }
}

void AI::OpenApi::VSP_Call::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            dcdr >> m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            dcdr >> m_stopVoice;
            break;

        default:
            dcdr >> m_unknownOp;
            break;
    }
}

AI::OpenApi::VSP_Request::VSP_Request() {}

AI::OpenApi::VSP_Request::~VSP_Request() {}

AI::OpenApi::VSP_Request::VSP_Request(const VSP_Request &x) : m_header(x.m_header), m_data(x.m_data) {}

AI::OpenApi::VSP_Request::VSP_Request(VSP_Request &&x) : m_header(std::move(x.m_header)), m_data(std::move(x.m_data)) {}

AI::OpenApi::VSP_Request &AI::OpenApi::VSP_Request::operator=(const VSP_Request &x) {
    m_header = x.m_header;
    m_data = x.m_data;

    return *this;
}

AI::OpenApi::VSP_Request &AI::OpenApi::VSP_Request::operator=(VSP_Request &&x) {
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AI::OpenApi::VSP_Request::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::rpc::protocol::dds::rpc::RequestHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += VSP_Call::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_Request::getCdrSerializedSize(const AI::OpenApi::VSP_Request &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += VSP_Call::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_Request::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m_header;
    scdr << m_data;
}

void AI::OpenApi::VSP_Request::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m_header;
    dcdr >> m_data;
}

AI::OpenApi::VSP_Return::VSP_Return() : m__d(0) {}

AI::OpenApi::VSP_Return::~VSP_Return() {}

AI::OpenApi::VSP_Return::VSP_Return(const VSP_Return &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = x.m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = x.m_stopVoice;
            break;

        case (int32_t)0xA4C948E9:
            m_init = x.m_init;
            break;

        case (int32_t)0x61863CB7:
            m_ready = x.m_ready;
            break;

        case (int32_t)0xC815E808:
            m_vadBegin = x.m_vadBegin;
            break;

        case (int32_t)0x296CC74B:
            m_vadEnd = x.m_vadEnd;
            break;

        case (int32_t)0x12215282:
            m_error = x.m_error;
            break;

        case (int32_t)0xF3E0EB2F:
            m_partial = x.m_partial;
            break;

        case (int32_t)0x3188DCD9:
            m_finalResult = x.m_finalResult;
            break;
    }
}

AI::OpenApi::VSP_Return::VSP_Return(VSP_Return &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = std::move(x.m_beginVoice);
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = std::move(x.m_stopVoice);
            break;

        case (int32_t)0xA4C948E9:
            m_init = std::move(x.m_init);
            break;

        case (int32_t)0x61863CB7:
            m_ready = std::move(x.m_ready);
            break;

        case (int32_t)0xC815E808:
            m_vadBegin = std::move(x.m_vadBegin);
            break;

        case (int32_t)0x296CC74B:
            m_vadEnd = std::move(x.m_vadEnd);
            break;

        case (int32_t)0x12215282:
            m_error = std::move(x.m_error);
            break;

        case (int32_t)0xF3E0EB2F:
            m_partial = std::move(x.m_partial);
            break;

        case (int32_t)0x3188DCD9:
            m_finalResult = std::move(x.m_finalResult);
            break;
    }
}

AI::OpenApi::VSP_Return &AI::OpenApi::VSP_Return::operator=(const VSP_Return &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = x.m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = x.m_stopVoice;
            break;

        case (int32_t)0xA4C948E9:
            m_init = x.m_init;
            break;

        case (int32_t)0x61863CB7:
            m_ready = x.m_ready;
            break;

        case (int32_t)0xC815E808:
            m_vadBegin = x.m_vadBegin;
            break;

        case (int32_t)0x296CC74B:
            m_vadEnd = x.m_vadEnd;
            break;

        case (int32_t)0x12215282:
            m_error = x.m_error;
            break;

        case (int32_t)0xF3E0EB2F:
            m_partial = x.m_partial;
            break;

        case (int32_t)0x3188DCD9:
            m_finalResult = x.m_finalResult;
            break;
    }

    return *this;
}

AI::OpenApi::VSP_Return &AI::OpenApi::VSP_Return::operator=(VSP_Return &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            m_beginVoice = std::move(x.m_beginVoice);
            break;

        case (int32_t)0xD928FA97:
            m_stopVoice = std::move(x.m_stopVoice);
            break;

        case (int32_t)0xA4C948E9:
            m_init = std::move(x.m_init);
            break;

        case (int32_t)0x61863CB7:
            m_ready = std::move(x.m_ready);
            break;

        case (int32_t)0xC815E808:
            m_vadBegin = std::move(x.m_vadBegin);
            break;

        case (int32_t)0x296CC74B:
            m_vadEnd = std::move(x.m_vadEnd);
            break;

        case (int32_t)0x12215282:
            m_error = std::move(x.m_error);
            break;

        case (int32_t)0xF3E0EB2F:
            m_partial = std::move(x.m_partial);
            break;

        case (int32_t)0x3188DCD9:
            m_finalResult = std::move(x.m_finalResult);
            break;
    }

    return *this;
}

void AI::OpenApi::VSP_Return::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::VSP_Return::_d() const { return m__d; }

int32_t &AI::OpenApi::VSP_Return::_d() { return m__d; }

void AI::OpenApi::VSP_Return::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp) {
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation AI::OpenApi::VSP_Return::unknownOp() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation &AI::OpenApi::VSP_Return::unknownOp() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

void AI::OpenApi::VSP_Return::beginVoice(const AI::OpenApi::VSP_beginVoice_Result &_beginVoice) {
    m_beginVoice = _beginVoice;
    m__d = (int32_t)0x68F1FC67;
}

void AI::OpenApi::VSP_Return::beginVoice(AI::OpenApi::VSP_beginVoice_Result &&_beginVoice) {
    m_beginVoice = std::move(_beginVoice);
    m__d = (int32_t)0x68F1FC67;
}

const AI::OpenApi::VSP_beginVoice_Result &AI::OpenApi::VSP_Return::beginVoice() const {
    if (m__d != (int32_t)0x68F1FC67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_beginVoice;
}

AI::OpenApi::VSP_beginVoice_Result &AI::OpenApi::VSP_Return::beginVoice() {
    if (m__d != (int32_t)0x68F1FC67)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_beginVoice;
}

void AI::OpenApi::VSP_Return::stopVoice(const AI::OpenApi::VSP_stopVoice_Result &_stopVoice) {
    m_stopVoice = _stopVoice;
    m__d = (int32_t)0xD928FA97;
}

void AI::OpenApi::VSP_Return::stopVoice(AI::OpenApi::VSP_stopVoice_Result &&_stopVoice) {
    m_stopVoice = std::move(_stopVoice);
    m__d = (int32_t)0xD928FA97;
}

const AI::OpenApi::VSP_stopVoice_Result &AI::OpenApi::VSP_Return::stopVoice() const {
    if (m__d != (int32_t)0xD928FA97)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_stopVoice;
}

AI::OpenApi::VSP_stopVoice_Result &AI::OpenApi::VSP_Return::stopVoice() {
    if (m__d != (int32_t)0xD928FA97)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_stopVoice;
}

void AI::OpenApi::VSP_Return::init(const AI::OpenApi::VSP_init_Result &_init) {
    m_init = _init;
    m__d = (int32_t)0xA4C948E9;
}

void AI::OpenApi::VSP_Return::init(AI::OpenApi::VSP_init_Result &&_init) {
    m_init = std::move(_init);
    m__d = (int32_t)0xA4C948E9;
}

const AI::OpenApi::VSP_init_Result &AI::OpenApi::VSP_Return::init() const {
    if (m__d != (int32_t)0xA4C948E9)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_init;
}

AI::OpenApi::VSP_init_Result &AI::OpenApi::VSP_Return::init() {
    if (m__d != (int32_t)0xA4C948E9)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_init;
}

void AI::OpenApi::VSP_Return::ready(const AI::OpenApi::VSP_ready_Result &_ready) {
    m_ready = _ready;
    m__d = (int32_t)0x61863CB7;
}

void AI::OpenApi::VSP_Return::ready(AI::OpenApi::VSP_ready_Result &&_ready) {
    m_ready = std::move(_ready);
    m__d = (int32_t)0x61863CB7;
}

const AI::OpenApi::VSP_ready_Result &AI::OpenApi::VSP_Return::ready() const {
    if (m__d != (int32_t)0x61863CB7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_ready;
}

AI::OpenApi::VSP_ready_Result &AI::OpenApi::VSP_Return::ready() {
    if (m__d != (int32_t)0x61863CB7)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_ready;
}

void AI::OpenApi::VSP_Return::vadBegin(const AI::OpenApi::VSP_vadBegin_Result &_vadBegin) {
    m_vadBegin = _vadBegin;
    m__d = (int32_t)0xC815E808;
}

void AI::OpenApi::VSP_Return::vadBegin(AI::OpenApi::VSP_vadBegin_Result &&_vadBegin) {
    m_vadBegin = std::move(_vadBegin);
    m__d = (int32_t)0xC815E808;
}

const AI::OpenApi::VSP_vadBegin_Result &AI::OpenApi::VSP_Return::vadBegin() const {
    if (m__d != (int32_t)0xC815E808)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_vadBegin;
}

AI::OpenApi::VSP_vadBegin_Result &AI::OpenApi::VSP_Return::vadBegin() {
    if (m__d != (int32_t)0xC815E808)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_vadBegin;
}

void AI::OpenApi::VSP_Return::vadEnd(const AI::OpenApi::VSP_vadEnd_Result &_vadEnd) {
    m_vadEnd = _vadEnd;
    m__d = (int32_t)0x296CC74B;
}

void AI::OpenApi::VSP_Return::vadEnd(AI::OpenApi::VSP_vadEnd_Result &&_vadEnd) {
    m_vadEnd = std::move(_vadEnd);
    m__d = (int32_t)0x296CC74B;
}

const AI::OpenApi::VSP_vadEnd_Result &AI::OpenApi::VSP_Return::vadEnd() const {
    if (m__d != (int32_t)0x296CC74B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_vadEnd;
}

AI::OpenApi::VSP_vadEnd_Result &AI::OpenApi::VSP_Return::vadEnd() {
    if (m__d != (int32_t)0x296CC74B)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_vadEnd;
}

void AI::OpenApi::VSP_Return::error(const AI::OpenApi::VSP_error_Result &_error) {
    m_error = _error;
    m__d = (int32_t)0x12215282;
}

void AI::OpenApi::VSP_Return::error(AI::OpenApi::VSP_error_Result &&_error) {
    m_error = std::move(_error);
    m__d = (int32_t)0x12215282;
}

const AI::OpenApi::VSP_error_Result &AI::OpenApi::VSP_Return::error() const {
    if (m__d != (int32_t)0x12215282)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_error;
}

AI::OpenApi::VSP_error_Result &AI::OpenApi::VSP_Return::error() {
    if (m__d != (int32_t)0x12215282)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_error;
}

void AI::OpenApi::VSP_Return::partial(const AI::OpenApi::VSP_partial_Result &_partial) {
    m_partial = _partial;
    m__d = (int32_t)0xF3E0EB2F;
}

void AI::OpenApi::VSP_Return::partial(AI::OpenApi::VSP_partial_Result &&_partial) {
    m_partial = std::move(_partial);
    m__d = (int32_t)0xF3E0EB2F;
}

const AI::OpenApi::VSP_partial_Result &AI::OpenApi::VSP_Return::partial() const {
    if (m__d != (int32_t)0xF3E0EB2F)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_partial;
}

AI::OpenApi::VSP_partial_Result &AI::OpenApi::VSP_Return::partial() {
    if (m__d != (int32_t)0xF3E0EB2F)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_partial;
}

void AI::OpenApi::VSP_Return::finalResult(const AI::OpenApi::VSP_finalResult_Result &_finalResult) {
    m_finalResult = _finalResult;
    m__d = (int32_t)0x3188DCD9;
}

void AI::OpenApi::VSP_Return::finalResult(AI::OpenApi::VSP_finalResult_Result &&_finalResult) {
    m_finalResult = std::move(_finalResult);
    m__d = (int32_t)0x3188DCD9;
}

const AI::OpenApi::VSP_finalResult_Result &AI::OpenApi::VSP_Return::finalResult() const {
    if (m__d != (int32_t)0x3188DCD9)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_finalResult;
}

AI::OpenApi::VSP_finalResult_Result &AI::OpenApi::VSP_Return::finalResult() {
    if (m__d != (int32_t)0x3188DCD9)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_finalResult;
}

size_t AI::OpenApi::VSP_Return::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_beginVoice_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_stopVoice_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_init_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_ready_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_vadBegin_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_vadEnd_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_error_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_partial_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::VSP_finalResult_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::VSP_Return::getCdrSerializedSize(const AI::OpenApi::VSP_Return &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case (int32_t)0x68F1FC67:
            current_alignment += VSP_beginVoice_Result::getCdrSerializedSize(data.m_beginVoice, current_alignment);
            break;

        case (int32_t)0xD928FA97:
            current_alignment += VSP_stopVoice_Result::getCdrSerializedSize(data.m_stopVoice, current_alignment);
            break;

        case (int32_t)0xA4C948E9:
            current_alignment += VSP_init_Result::getCdrSerializedSize(data.m_init, current_alignment);
            break;

        case (int32_t)0x61863CB7:
            current_alignment += VSP_ready_Result::getCdrSerializedSize(data.m_ready, current_alignment);
            break;

        case (int32_t)0xC815E808:
            current_alignment += VSP_vadBegin_Result::getCdrSerializedSize(data.m_vadBegin, current_alignment);
            break;

        case (int32_t)0x296CC74B:
            current_alignment += VSP_vadEnd_Result::getCdrSerializedSize(data.m_vadEnd, current_alignment);
            break;

        case (int32_t)0x12215282:
            current_alignment += VSP_error_Result::getCdrSerializedSize(data.m_error, current_alignment);
            break;

        case (int32_t)0xF3E0EB2F:
            current_alignment += VSP_partial_Result::getCdrSerializedSize(data.m_partial, current_alignment);
            break;

        case (int32_t)0x3188DCD9:
            current_alignment += VSP_finalResult_Result::getCdrSerializedSize(data.m_finalResult, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_Return::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            scdr << m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            scdr << m_stopVoice;
            break;

        case (int32_t)0xA4C948E9:
            scdr << m_init;
            break;

        case (int32_t)0x61863CB7:
            scdr << m_ready;
            break;

        case (int32_t)0xC815E808:
            scdr << m_vadBegin;
            break;

        case (int32_t)0x296CC74B:
            scdr << m_vadEnd;
            break;

        case (int32_t)0x12215282:
            scdr << m_error;
            break;

        case (int32_t)0xF3E0EB2F:
            scdr << m_partial;
            break;

        case (int32_t)0x3188DCD9:
            scdr << m_finalResult;
            break;

        default:
            scdr << m_unknownOp;
            break;
    }
}

void AI::OpenApi::VSP_Return::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case (int32_t)0x68F1FC67:
            dcdr >> m_beginVoice;
            break;

        case (int32_t)0xD928FA97:
            dcdr >> m_stopVoice;
            break;

        case (int32_t)0xA4C948E9:
            dcdr >> m_init;
            break;

        case (int32_t)0x61863CB7:
            dcdr >> m_ready;
            break;

        case (int32_t)0xC815E808:
            dcdr >> m_vadBegin;
            break;

        case (int32_t)0x296CC74B:
            dcdr >> m_vadEnd;
            break;

        case (int32_t)0x12215282:
            dcdr >> m_error;
            break;

        case (int32_t)0xF3E0EB2F:
            dcdr >> m_partial;
            break;

        case (int32_t)0x3188DCD9:
            dcdr >> m_finalResult;
            break;

        default:
            dcdr >> m_unknownOp;
            break;
    }
}

AI::OpenApi::VSP_Reply::VSP_Reply() {}

AI::OpenApi::VSP_Reply::~VSP_Reply() {}

AI::OpenApi::VSP_Reply::VSP_Reply(const VSP_Reply &x) : m_header(x.m_header), m_data(x.m_data) {}

AI::OpenApi::VSP_Reply::VSP_Reply(VSP_Reply &&x) : m_header(std::move(x.m_header)), m_data(std::move(x.m_data)) {}

AI::OpenApi::VSP_Reply &AI::OpenApi::VSP_Reply::operator=(const VSP_Reply &x) {
    m_header = x.m_header;
    m_data = x.m_data;

    return *this;
}

AI::OpenApi::VSP_Reply &AI::OpenApi::VSP_Reply::operator=(VSP_Reply &&x) {
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AI::OpenApi::VSP_Reply::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    current_alignment += eprosima::rpc::protocol::dds::rpc::ReplyHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += VSP_Return::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::VSP_Reply::getCdrSerializedSize(const AI::OpenApi::VSP_Reply &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += VSP_Return::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::VSP_Reply::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m_header;
    scdr << m_data;
}

void AI::OpenApi::VSP_Reply::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m_header;
    dcdr >> m_data;
}

AI::OpenApi::Photo_getPhotoInfo_In::Photo_getPhotoInfo_In() : m_pId() {}

AI::OpenApi::Photo_getPhotoInfo_In::~Photo_getPhotoInfo_In() {}

AI::OpenApi::Photo_getPhotoInfo_In::Photo_getPhotoInfo_In(const Photo_getPhotoInfo_In &x) : m_pId(x.m_pId) {}

AI::OpenApi::Photo_getPhotoInfo_In::Photo_getPhotoInfo_In(Photo_getPhotoInfo_In &&x) : m_pId(std::move(x.m_pId)) {}

AI::OpenApi::Photo_getPhotoInfo_In &AI::OpenApi::Photo_getPhotoInfo_In::operator=(
    const AI::OpenApi::Photo_getPhotoInfo_In &x) {
    m_pId = x.m_pId;
    ;

    return *this;
}

AI::OpenApi::Photo_getPhotoInfo_In &AI::OpenApi::Photo_getPhotoInfo_In::operator=(
    AI::OpenApi::Photo_getPhotoInfo_In &&x) {
    m_pId = x.m_pId;
    ;

    return *this;
}

size_t AI::OpenApi::Photo_getPhotoInfo_In::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::Photo_getPhotoInfo_In::getCdrSerializedSize(const AI::OpenApi::Photo_getPhotoInfo_In &data,
                                                                size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.pId().size() + 1;

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_getPhotoInfo_In::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_pId; }

void AI::OpenApi::Photo_getPhotoInfo_In::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_pId; }

AI::OpenApi::Photo_getPhotoInfo_Out::Photo_getPhotoInfo_Out() : m_return_() {}

AI::OpenApi::Photo_getPhotoInfo_Out::~Photo_getPhotoInfo_Out() {}

AI::OpenApi::Photo_getPhotoInfo_Out::Photo_getPhotoInfo_Out(const Photo_getPhotoInfo_Out &x) : m_return_(x.m_return_) {}

AI::OpenApi::Photo_getPhotoInfo_Out::Photo_getPhotoInfo_Out(Photo_getPhotoInfo_Out &&x)
    : m_return_(std::move(x.m_return_)) {}

AI::OpenApi::Photo_getPhotoInfo_Out &AI::OpenApi::Photo_getPhotoInfo_Out::operator=(
    const AI::OpenApi::Photo_getPhotoInfo_Out &x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

AI::OpenApi::Photo_getPhotoInfo_Out &AI::OpenApi::Photo_getPhotoInfo_Out::operator=(
    AI::OpenApi::Photo_getPhotoInfo_Out &&x) {
    m_return_ = x.m_return_;
    ;

    return *this;
}

size_t AI::OpenApi::Photo_getPhotoInfo_Out::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::Photo_getPhotoInfo_Out::getCdrSerializedSize(const AI::OpenApi::Photo_getPhotoInfo_Out &data,
                                                                 size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.return_().size() + 1;

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_getPhotoInfo_Out::serialize(eprosima::fastcdr::Cdr &scdr) const { scdr << m_return_; }

void AI::OpenApi::Photo_getPhotoInfo_Out::deserialize(eprosima::fastcdr::Cdr &dcdr) { dcdr >> m_return_; }

AI::OpenApi::Photo_getPhotoInfo_Result::Photo_getPhotoInfo_Result() : m__d(2) {}

AI::OpenApi::Photo_getPhotoInfo_Result::~Photo_getPhotoInfo_Result() {}

AI::OpenApi::Photo_getPhotoInfo_Result::Photo_getPhotoInfo_Result(const Photo_getPhotoInfo_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }
}

AI::OpenApi::Photo_getPhotoInfo_Result::Photo_getPhotoInfo_Result(Photo_getPhotoInfo_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }
}

AI::OpenApi::Photo_getPhotoInfo_Result &AI::OpenApi::Photo_getPhotoInfo_Result::operator=(
    const AI::OpenApi::Photo_getPhotoInfo_Result &x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = x.m_result;
            break;
    }

    return *this;
}

AI::OpenApi::Photo_getPhotoInfo_Result &AI::OpenApi::Photo_getPhotoInfo_Result::operator=(
    AI::OpenApi::Photo_getPhotoInfo_Result &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            m_result = std::move(x.m_result);
            break;
    }

    return *this;
}

void AI::OpenApi::Photo_getPhotoInfo_Result::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::Photo_getPhotoInfo_Result::_d() const { return m__d; }

int32_t &AI::OpenApi::Photo_getPhotoInfo_Result::_d() { return m__d; }

void AI::OpenApi::Photo_getPhotoInfo_Result::unknownEx(eprosima::rpc::protocol::dds::rpc::UnknownException _unknownEx) {
    m_unknownEx = _unknownEx;
    m__d = 2;
}

eprosima::rpc::protocol::dds::rpc::UnknownException AI::OpenApi::Photo_getPhotoInfo_Result::unknownEx() const {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

eprosima::rpc::protocol::dds::rpc::UnknownException &AI::OpenApi::Photo_getPhotoInfo_Result::unknownEx() {
    if (m__d != 2)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownEx;
}

void AI::OpenApi::Photo_getPhotoInfo_Result::result(const AI::OpenApi::Photo_getPhotoInfo_Out &_result) {
    m_result = _result;
    m__d = 0;
}

void AI::OpenApi::Photo_getPhotoInfo_Result::result(AI::OpenApi::Photo_getPhotoInfo_Out &&_result) {
    m_result = std::move(_result);
    m__d = 0;
}

const AI::OpenApi::Photo_getPhotoInfo_Out &AI::OpenApi::Photo_getPhotoInfo_Result::result() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

AI::OpenApi::Photo_getPhotoInfo_Out &AI::OpenApi::Photo_getPhotoInfo_Result::result() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_result;
}

size_t AI::OpenApi::Photo_getPhotoInfo_Result::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // UnknowEx
    union_max_size_serialized = current_alignment;
    union_max_size_serialized += 1;

    reset_alignment = current_alignment;
    reset_alignment += AI::OpenApi::Photo_getPhotoInfo_Out::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::Photo_getPhotoInfo_Result::getCdrSerializedSize(const AI::OpenApi::Photo_getPhotoInfo_Result &data,
                                                                    size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            current_alignment += Photo_getPhotoInfo_Out::getCdrSerializedSize(data.m_result, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_getPhotoInfo_Result::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            scdr << m_result;
            break;

        default:
            scdr << m_unknownEx;
            break;
    }
}

void AI::OpenApi::Photo_getPhotoInfo_Result::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK:
            dcdr >> m_result;
            break;

        default:
            dcdr >> m_unknownEx;
            break;
    }
}

AI::OpenApi::Photo_Call::Photo_Call() : m__d(0) {}

AI::OpenApi::Photo_Call::~Photo_Call() {}

AI::OpenApi::Photo_Call::Photo_Call(const Photo_Call &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = x.m_getPhotoInfo;
            break;
    }
}

AI::OpenApi::Photo_Call::Photo_Call(Photo_Call &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = std::move(x.m_getPhotoInfo);
            break;
    }
}

AI::OpenApi::Photo_Call &AI::OpenApi::Photo_Call::operator=(const Photo_Call &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = x.m_getPhotoInfo;
            break;
    }

    return *this;
}

AI::OpenApi::Photo_Call &AI::OpenApi::Photo_Call::operator=(Photo_Call &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = std::move(x.m_getPhotoInfo);
            break;
    }

    return *this;
}

void AI::OpenApi::Photo_Call::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::Photo_Call::_d() const { return m__d; }

int32_t &AI::OpenApi::Photo_Call::_d() { return m__d; }

void AI::OpenApi::Photo_Call::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp) {
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation AI::OpenApi::Photo_Call::unknownOp() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation &AI::OpenApi::Photo_Call::unknownOp() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

void AI::OpenApi::Photo_Call::getPhotoInfo(const AI::OpenApi::Photo_getPhotoInfo_In &_getPhotoInfo) {
    m_getPhotoInfo = _getPhotoInfo;
    m__d = (int32_t)0xE84B15F6;
}

void AI::OpenApi::Photo_Call::getPhotoInfo(AI::OpenApi::Photo_getPhotoInfo_In &&_getPhotoInfo) {
    m_getPhotoInfo = std::move(_getPhotoInfo);
    m__d = (int32_t)0xE84B15F6;
}

const AI::OpenApi::Photo_getPhotoInfo_In &AI::OpenApi::Photo_Call::getPhotoInfo() const {
    if (m__d != (int32_t)0xE84B15F6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_getPhotoInfo;
}

AI::OpenApi::Photo_getPhotoInfo_In &AI::OpenApi::Photo_Call::getPhotoInfo() {
    if (m__d != (int32_t)0xE84B15F6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_getPhotoInfo;
}

size_t AI::OpenApi::Photo_Call::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknownOp attribute;
    union_max_size_serialized = current_alignment + 1;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::Photo_getPhotoInfo_In::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::Photo_Call::getCdrSerializedSize(const AI::OpenApi::Photo_Call &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case (int32_t)0xE84B15F6:
            current_alignment += Photo_getPhotoInfo_In::getCdrSerializedSize(data.m_getPhotoInfo, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_Call::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            scdr << m_getPhotoInfo;
            break;

        default:
            scdr << m_unknownOp;
            break;
    }
}

void AI::OpenApi::Photo_Call::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            dcdr >> m_getPhotoInfo;
            break;

        default:
            dcdr >> m_unknownOp;
            break;
    }
}

AI::OpenApi::Photo_Request::Photo_Request() {}

AI::OpenApi::Photo_Request::~Photo_Request() {}

AI::OpenApi::Photo_Request::Photo_Request(const Photo_Request &x) : m_header(x.m_header), m_data(x.m_data) {}

AI::OpenApi::Photo_Request::Photo_Request(Photo_Request &&x)
    : m_header(std::move(x.m_header)), m_data(std::move(x.m_data)) {}

AI::OpenApi::Photo_Request &AI::OpenApi::Photo_Request::operator=(const Photo_Request &x) {
    m_header = x.m_header;
    m_data = x.m_data;

    return *this;
}

AI::OpenApi::Photo_Request &AI::OpenApi::Photo_Request::operator=(Photo_Request &&x) {
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AI::OpenApi::Photo_Request::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::rpc::protocol::dds::rpc::RequestHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Photo_Call::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::Photo_Request::getCdrSerializedSize(const AI::OpenApi::Photo_Request &data,
                                                        size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += Photo_Call::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_Request::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m_header;
    scdr << m_data;
}

void AI::OpenApi::Photo_Request::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m_header;
    dcdr >> m_data;
}

AI::OpenApi::Photo_Return::Photo_Return() : m__d(0) {}

AI::OpenApi::Photo_Return::~Photo_Return() {}

AI::OpenApi::Photo_Return::Photo_Return(const Photo_Return &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = x.m_getPhotoInfo;
            break;
    }
}

AI::OpenApi::Photo_Return::Photo_Return(Photo_Return &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = std::move(x.m_getPhotoInfo);
            break;
    }
}

AI::OpenApi::Photo_Return &AI::OpenApi::Photo_Return::operator=(const Photo_Return &x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = x.m_getPhotoInfo;
            break;
    }

    return *this;
}

AI::OpenApi::Photo_Return &AI::OpenApi::Photo_Return::operator=(Photo_Return &&x) {
    m__d = x.m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            m_getPhotoInfo = std::move(x.m_getPhotoInfo);
            break;
    }

    return *this;
}

void AI::OpenApi::Photo_Return::_d(int32_t __d) {
    if (m__d != __d) {
        throw eprosima::rpc::exception::BadParamException(
            "Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t AI::OpenApi::Photo_Return::_d() const { return m__d; }

int32_t &AI::OpenApi::Photo_Return::_d() { return m__d; }

void AI::OpenApi::Photo_Return::unknownOp(eprosima::rpc::protocol::dds::rpc::UnknownOperation _unknownOp) {
    m_unknownOp = _unknownOp;
    m__d = 0;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation AI::OpenApi::Photo_Return::unknownOp() const {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

eprosima::rpc::protocol::dds::rpc::UnknownOperation &AI::OpenApi::Photo_Return::unknownOp() {
    if (m__d != 0)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_unknownOp;
}

void AI::OpenApi::Photo_Return::getPhotoInfo(const AI::OpenApi::Photo_getPhotoInfo_Result &_getPhotoInfo) {
    m_getPhotoInfo = _getPhotoInfo;
    m__d = (int32_t)0xE84B15F6;
}

void AI::OpenApi::Photo_Return::getPhotoInfo(AI::OpenApi::Photo_getPhotoInfo_Result &&_getPhotoInfo) {
    m_getPhotoInfo = std::move(_getPhotoInfo);
    m__d = (int32_t)0xE84B15F6;
}

const AI::OpenApi::Photo_getPhotoInfo_Result &AI::OpenApi::Photo_Return::getPhotoInfo() const {
    if (m__d != (int32_t)0xE84B15F6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_getPhotoInfo;
}

AI::OpenApi::Photo_getPhotoInfo_Result &AI::OpenApi::Photo_Return::getPhotoInfo() {
    if (m__d != (int32_t)0xE84B15F6)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");

    return m_getPhotoInfo;
}

size_t AI::OpenApi::Photo_Return::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // Default unknown_operation attribute;
    union_max_size_serialized = current_alignment + 1;

    reset_alignment = current_alignment;

    reset_alignment += AI::OpenApi::Photo_getPhotoInfo_Result::getMaxCdrSerializedSize(reset_alignment);

    if (union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

size_t AI::OpenApi::Photo_Return::getCdrSerializedSize(const AI::OpenApi::Photo_Return &data,
                                                       size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    switch (data.m__d) {
        case (int32_t)0xE84B15F6:
            current_alignment +=
                Photo_getPhotoInfo_Result::getCdrSerializedSize(data.m_getPhotoInfo, current_alignment);
            break;
    }

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_Return::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            scdr << m_getPhotoInfo;
            break;

        default:
            scdr << m_unknownOp;
            break;
    }
}

void AI::OpenApi::Photo_Return::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m__d;

    switch (m__d) {
        case (int32_t)0xE84B15F6:
            dcdr >> m_getPhotoInfo;
            break;

        default:
            dcdr >> m_unknownOp;
            break;
    }
}

AI::OpenApi::Photo_Reply::Photo_Reply() {}

AI::OpenApi::Photo_Reply::~Photo_Reply() {}

AI::OpenApi::Photo_Reply::Photo_Reply(const Photo_Reply &x) : m_header(x.m_header), m_data(x.m_data) {}

AI::OpenApi::Photo_Reply::Photo_Reply(Photo_Reply &&x) : m_header(std::move(x.m_header)), m_data(std::move(x.m_data)) {}

AI::OpenApi::Photo_Reply &AI::OpenApi::Photo_Reply::operator=(const Photo_Reply &x) {
    m_header = x.m_header;
    m_data = x.m_data;

    return *this;
}

AI::OpenApi::Photo_Reply &AI::OpenApi::Photo_Reply::operator=(Photo_Reply &&x) {
    m_header = std::move(x.m_header);
    m_data = std::move(x.m_data);

    return *this;
}

size_t AI::OpenApi::Photo_Reply::getMaxCdrSerializedSize(size_t current_alignment) {
    size_t initial_alignment = current_alignment;
    current_alignment += eprosima::rpc::protocol::dds::rpc::ReplyHeader::getMaxCdrSerializedSize(current_alignment);
    current_alignment += Photo_Return::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t AI::OpenApi::Photo_Reply::getCdrSerializedSize(const AI::OpenApi::Photo_Reply &data, size_t current_alignment) {
    size_t initial_alignment = current_alignment;

    current_alignment += data.m_header.getCdrSerializedSize(current_alignment);
    current_alignment += Photo_Return::getCdrSerializedSize(data.m_data, current_alignment);

    return current_alignment - initial_alignment;
}

void AI::OpenApi::Photo_Reply::serialize(eprosima::fastcdr::Cdr &scdr) const {
    scdr << m_header;
    scdr << m_data;
}

void AI::OpenApi::Photo_Reply::deserialize(eprosima::fastcdr::Cdr &dcdr) {
    dcdr >> m_header;
    dcdr >> m_data;
}
