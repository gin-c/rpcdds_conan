/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 *
 * @file AIOpenApiTopicsPlugin.cpp
 * TODO This header file contains the declaration of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "AIOpenApiTopicsPlugin.h"

#include <fastcdr/Cdr.h>

using namespace eprosima::fastrtps;
using namespace ::rtps;

AI::OpenApi::VSP_RequestPlugin::VSP_RequestPlugin() {
    setName("AI::OpenApi::VSP_Request");
    m_typeSize = (uint32_t)AI::OpenApi::VSP_Request::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = false;
}

AI::OpenApi::VSP_RequestPlugin::~VSP_RequestPlugin() {}

bool AI::OpenApi::VSP_RequestPlugin::getKey(void*, InstanceHandle_t*, bool) { return false; }

bool AI::OpenApi::VSP_RequestPlugin::serialize(void* data, SerializedPayload_t* payload) {
    AI::OpenApi::VSP_Request* p_type = (AI::OpenApi::VSP_Request*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size);
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                               eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try {
        // Serialize the object:
        p_type->serialize(ser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    // Get the serialized length
    payload->length = (uint16_t)ser.getSerializedDataLength();

    return true;
}

bool AI::OpenApi::VSP_RequestPlugin::deserialize(SerializedPayload_t* payload, void* data) {
    // CONVERT DATA to pointer of your type
    AI::OpenApi::VSP_Request* p_type = (AI::OpenApi::VSP_Request*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length);
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                 eprosima::fastcdr::Cdr::DDS_CDR);  // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try {
        // deserialize the object:
        p_type->deserialize(deser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    return true;
}

std::function<uint32_t()> AI::OpenApi::VSP_RequestPlugin::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t {
        return AI::OpenApi::VSP_Request::getCdrSerializedSize(*static_cast<AI::OpenApi::VSP_Request*>(data));
    };
}

void* AI::OpenApi::VSP_RequestPlugin::createData() { return (void*)new AI::OpenApi::VSP_Request(); }

void* AI::OpenApi::VSP_RequestPlugin::create_data() { return (void*)new AI::OpenApi::VSP_Request(); }

void AI::OpenApi::VSP_RequestPlugin::deleteData(void* data) { delete ((AI::OpenApi::VSP_Request*)data); }

void AI::OpenApi::VSP_RequestPlugin::delete_data(void* data) { delete ((AI::OpenApi::VSP_Request*)data); }

void AI::OpenApi::VSP_RequestPlugin::copy_data(VSP_Request* dst, const VSP_Request* src) { *dst = *src; }

// Reply interfaces
AI::OpenApi::VSP_ReplyPlugin::VSP_ReplyPlugin() {
    setName("AI::OpenApi::VSP_Reply");
    m_typeSize = (uint32_t)AI::OpenApi::VSP_Reply::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = false;
}

AI::OpenApi::VSP_ReplyPlugin::~VSP_ReplyPlugin() {}

bool AI::OpenApi::VSP_ReplyPlugin::getKey(void*, InstanceHandle_t*, bool) { return false; }

bool AI::OpenApi::VSP_ReplyPlugin::serialize(void* data, SerializedPayload_t* payload) {
    AI::OpenApi::VSP_Reply* p_type = (AI::OpenApi::VSP_Reply*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size);
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                               eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try {
        // Serialize the object:
        p_type->serialize(ser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    // Get the serialized length
    payload->length = (uint16_t)ser.getSerializedDataLength();

    return true;
}

bool AI::OpenApi::VSP_ReplyPlugin::deserialize(SerializedPayload_t* payload, void* data) {
    // CONVERT DATA to pointer of your type
    AI::OpenApi::VSP_Reply* p_type = (AI::OpenApi::VSP_Reply*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length);
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                 eprosima::fastcdr::Cdr::DDS_CDR);  // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try {
        // deserialize the object:
        p_type->deserialize(deser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    return true;
}

std::function<uint32_t()> AI::OpenApi::VSP_ReplyPlugin::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t {
        return AI::OpenApi::VSP_Reply::getCdrSerializedSize(*static_cast<AI::OpenApi::VSP_Reply*>(data));
    };
}

void* AI::OpenApi::VSP_ReplyPlugin::createData() { return (void*)new AI::OpenApi::VSP_Reply(); }

void* AI::OpenApi::VSP_ReplyPlugin::create_data() { return (void*)new AI::OpenApi::VSP_Reply(); }

void AI::OpenApi::VSP_ReplyPlugin::deleteData(void* data) { delete ((AI::OpenApi::VSP_Reply*)data); }

void AI::OpenApi::VSP_ReplyPlugin::delete_data(void* data) { delete ((AI::OpenApi::VSP_Reply*)data); }

void AI::OpenApi::VSP_ReplyPlugin::copy_data(VSP_Reply* dst, const VSP_Reply* src) { *dst = *src; }

AI::OpenApi::Photo_RequestPlugin::Photo_RequestPlugin() {
    setName("AI::OpenApi::Photo_Request");
    m_typeSize = (uint32_t)AI::OpenApi::Photo_Request::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = false;
}

AI::OpenApi::Photo_RequestPlugin::~Photo_RequestPlugin() {}

bool AI::OpenApi::Photo_RequestPlugin::getKey(void*, InstanceHandle_t*, bool) { return false; }

bool AI::OpenApi::Photo_RequestPlugin::serialize(void* data, SerializedPayload_t* payload) {
    AI::OpenApi::Photo_Request* p_type = (AI::OpenApi::Photo_Request*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size);
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                               eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try {
        // Serialize the object:
        p_type->serialize(ser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    // Get the serialized length
    payload->length = (uint16_t)ser.getSerializedDataLength();

    return true;
}

bool AI::OpenApi::Photo_RequestPlugin::deserialize(SerializedPayload_t* payload, void* data) {
    // CONVERT DATA to pointer of your type
    AI::OpenApi::Photo_Request* p_type = (AI::OpenApi::Photo_Request*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length);
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                 eprosima::fastcdr::Cdr::DDS_CDR);  // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try {
        // deserialize the object:
        p_type->deserialize(deser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    return true;
}

std::function<uint32_t()> AI::OpenApi::Photo_RequestPlugin::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t {
        return AI::OpenApi::Photo_Request::getCdrSerializedSize(*static_cast<AI::OpenApi::Photo_Request*>(data));
    };
}

void* AI::OpenApi::Photo_RequestPlugin::createData() { return (void*)new AI::OpenApi::Photo_Request(); }

void* AI::OpenApi::Photo_RequestPlugin::create_data() { return (void*)new AI::OpenApi::Photo_Request(); }

void AI::OpenApi::Photo_RequestPlugin::deleteData(void* data) { delete ((AI::OpenApi::Photo_Request*)data); }

void AI::OpenApi::Photo_RequestPlugin::delete_data(void* data) { delete ((AI::OpenApi::Photo_Request*)data); }

void AI::OpenApi::Photo_RequestPlugin::copy_data(Photo_Request* dst, const Photo_Request* src) { *dst = *src; }

// Reply interfaces
AI::OpenApi::Photo_ReplyPlugin::Photo_ReplyPlugin() {
    setName("AI::OpenApi::Photo_Reply");
    m_typeSize = (uint32_t)AI::OpenApi::Photo_Reply::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = false;
}

AI::OpenApi::Photo_ReplyPlugin::~Photo_ReplyPlugin() {}

bool AI::OpenApi::Photo_ReplyPlugin::getKey(void*, InstanceHandle_t*, bool) { return false; }

bool AI::OpenApi::Photo_ReplyPlugin::serialize(void* data, SerializedPayload_t* payload) {
    AI::OpenApi::Photo_Reply* p_type = (AI::OpenApi::Photo_Reply*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->max_size);
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                               eprosima::fastcdr::Cdr::DDS_CDR);  // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try {
        // Serialize the object:
        p_type->serialize(ser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    // Get the serialized length
    payload->length = (uint16_t)ser.getSerializedDataLength();

    return true;
}

bool AI::OpenApi::Photo_ReplyPlugin::deserialize(SerializedPayload_t* payload, void* data) {
    // CONVERT DATA to pointer of your type
    AI::OpenApi::Photo_Reply* p_type = (AI::OpenApi::Photo_Reply*)data;

    // Object that manages the raw buffer.
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length);
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                                 eprosima::fastcdr::Cdr::DDS_CDR);  // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try {
        // deserialize the object:
        p_type->deserialize(deser);
    } catch (eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/) {
        return false;
    }

    return true;
}

std::function<uint32_t()> AI::OpenApi::Photo_ReplyPlugin::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t {
        return AI::OpenApi::Photo_Reply::getCdrSerializedSize(*static_cast<AI::OpenApi::Photo_Reply*>(data));
    };
}

void* AI::OpenApi::Photo_ReplyPlugin::createData() { return (void*)new AI::OpenApi::Photo_Reply(); }

void* AI::OpenApi::Photo_ReplyPlugin::create_data() { return (void*)new AI::OpenApi::Photo_Reply(); }

void AI::OpenApi::Photo_ReplyPlugin::deleteData(void* data) { delete ((AI::OpenApi::Photo_Reply*)data); }

void AI::OpenApi::Photo_ReplyPlugin::delete_data(void* data) { delete ((AI::OpenApi::Photo_Reply*)data); }

void AI::OpenApi::Photo_ReplyPlugin::copy_data(Photo_Reply* dst, const Photo_Reply* src) { *dst = *src; }
