/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 *
 * @file AIOpenApiDDSProtocol.cxx
 * This source file contains the definition of the protocol used to create DDS messages.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "AIOpenApiDDSProtocol.h"
#include "AIOpenApiDDSAsyncSupport.h"
#include "rpcdds/utils/dds/Middleware.h"
#include <rpcdds/exceptions/Exceptions.h>
#include <rpcdds/transports/Transport.h>
#include <rpcdds/transports/dds/RTPSProxyTransport.h>
#include <rpcdds/transports/dds/RTPSServerTransport.h>
#include <rpcdds/transports/dds/components/RTPSProxyProcedureEndpoint.h>
#include <rpcdds/transports/dds/components/RTPSServerProcedureEndpoint.h>

#include <fastrtps/Domain.h>

using namespace eprosima::rpc;
using namespace ::protocol::dds;
using namespace ::transport;
using namespace ::exception;

AIOpenApiProtocol::AIOpenApiProtocol()
    : ::protocol::AIOpenApiProtocol(),
      m_ddsTransport(NULL),
      AI_OpenApi_VSP_str("AI_OpenApi_VSP"),
      AI_OpenApi_VSP_pe(NULL),
      AI_OpenApi_VSP_se(NULL),
      AI_OpenApi_Photo_str("AI_OpenApi_Photo"),
      AI_OpenApi_Photo_pe(NULL),
      AI_OpenApi_Photo_se(NULL) {}

AIOpenApiProtocol::~AIOpenApiProtocol() {}

bool AIOpenApiProtocol::setTransport(Transport &transport) {
    if (strcmp(transport.getType(), "DDS") == 0) {
        m_ddsTransport = dynamic_cast<eprosima::rpc::transport::dds::RTPSTransport *>(&transport);

        m_ddsTransport->initialize();

        Protocol::_setTransport(transport);

        return true;
    } else {
        throw IncompatibleException("protocol and transport are incompatibles");
    }

    return false;
}

// TODO Si falla que elimine los creados.
bool AIOpenApiProtocol::activateInterface(const char *interfaceName) {
    std::string requesttopicName, replytopicName;

    if (m_ddsTransport != NULL) {
        TransportBehaviour behaviour = dynamic_cast<Transport *>(m_ddsTransport)->getBehaviour();

        if (strcmp(interfaceName, "AI::OpenApi::VSP") == 0) {
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &AI_OpenApi_VSP_requestPlugin);

            requesttopicName = "AI::OpenApi::VSP_";
            requesttopicName += m_ddsTransport->getRemoteServiceName();
            requesttopicName += "_Request";

            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &AI_OpenApi_VSP_replyPlugin);

            replytopicName = "AI::OpenApi::VSP_";
            replytopicName += m_ddsTransport->getRemoteServiceName();
            replytopicName += "_Reply";

            if (behaviour == ::transport::PROXY_BEHAVIOUR) {
                AI_OpenApi_VSP_pe = dynamic_cast<eprosima::rpc::transport::dds::RTPSProxyProcedureEndpoint *>(
                    m_ddsTransport->createProcedureEndpoint(
                        AI_OpenApi_VSP_str, AI_OpenApi_VSP_requestPlugin.getName(), requesttopicName.c_str(),
                        AI_OpenApi_VSP_replyPlugin.getName(), replytopicName.c_str(),
                        (::transport::dds::RTPSTransport::Create_data)AI::OpenApi::VSP_ReplyPlugin::create_data,
                        (::transport::dds::RTPSTransport::Copy_data)AI::OpenApi::VSP_ReplyPlugin::copy_data,
                        (::transport::dds::RTPSTransport::Destroy_data)AI::OpenApi::VSP_ReplyPlugin::delete_data,
                        AIOpenApiProtocol::AI_OpenApi_VSP_proxy, sizeof(AI::OpenApi::VSP_Reply)));
            }
            if (behaviour == ::transport::SERVER_BEHAVIOUR) {
                AI_OpenApi_VSP_se = dynamic_cast<eprosima::rpc::transport::dds::RTPSServerProcedureEndpoint *>(
                    m_ddsTransport->createProcedureEndpoint(
                        AI_OpenApi_VSP_str, AI_OpenApi_VSP_replyPlugin.getName(), replytopicName.c_str(),
                        AI_OpenApi_VSP_requestPlugin.getName(), requesttopicName.c_str(),
                        (::transport::dds::RTPSTransport::Create_data)AI::OpenApi::VSP_RequestPlugin::create_data,
                        (::transport::dds::RTPSTransport::Copy_data)AI::OpenApi::VSP_RequestPlugin::copy_data,
                        (::transport::dds::RTPSTransport::Destroy_data)AI::OpenApi::VSP_RequestPlugin::delete_data,
                        AIOpenApiProtocol::AI_OpenApi_VSP_serve, sizeof(AI::OpenApi::VSP_Request)));
            }
        } else if (strcmp(interfaceName, "AI::OpenApi::Photo") == 0) {
            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &AI_OpenApi_Photo_requestPlugin);

            requesttopicName = "AI::OpenApi::Photo_";
            requesttopicName += m_ddsTransport->getRemoteServiceName();
            requesttopicName += "_Request";

            eprosima::fastrtps::Domain::registerType(m_ddsTransport->getParticipant(), &AI_OpenApi_Photo_replyPlugin);

            replytopicName = "AI::OpenApi::Photo_";
            replytopicName += m_ddsTransport->getRemoteServiceName();
            replytopicName += "_Reply";

            if (behaviour == ::transport::PROXY_BEHAVIOUR) {
                AI_OpenApi_Photo_pe = dynamic_cast<eprosima::rpc::transport::dds::RTPSProxyProcedureEndpoint *>(
                    m_ddsTransport->createProcedureEndpoint(
                        AI_OpenApi_Photo_str, AI_OpenApi_Photo_requestPlugin.getName(), requesttopicName.c_str(),
                        AI_OpenApi_Photo_replyPlugin.getName(), replytopicName.c_str(),
                        (::transport::dds::RTPSTransport::Create_data)AI::OpenApi::Photo_ReplyPlugin::create_data,
                        (::transport::dds::RTPSTransport::Copy_data)AI::OpenApi::Photo_ReplyPlugin::copy_data,
                        (::transport::dds::RTPSTransport::Destroy_data)AI::OpenApi::Photo_ReplyPlugin::delete_data,
                        NULL, sizeof(AI::OpenApi::Photo_Reply)));
            }
            if (behaviour == ::transport::SERVER_BEHAVIOUR) {
                AI_OpenApi_Photo_se = dynamic_cast<eprosima::rpc::transport::dds::RTPSServerProcedureEndpoint *>(
                    m_ddsTransport->createProcedureEndpoint(
                        AI_OpenApi_Photo_str, AI_OpenApi_Photo_replyPlugin.getName(), replytopicName.c_str(),
                        AI_OpenApi_Photo_requestPlugin.getName(), requesttopicName.c_str(),
                        (::transport::dds::RTPSTransport::Create_data)AI::OpenApi::Photo_RequestPlugin::create_data,
                        (::transport::dds::RTPSTransport::Copy_data)AI::OpenApi::Photo_RequestPlugin::copy_data,
                        (::transport::dds::RTPSTransport::Destroy_data)AI::OpenApi::Photo_RequestPlugin::delete_data,
                        AIOpenApiProtocol::AI_OpenApi_Photo_serve, sizeof(AI::OpenApi::Photo_Request)));
            }
        }

        return true;
    } else {
        // TODO Trace.
    }

    return false;
}

void AIOpenApiProtocol::AI_OpenApi_VSP_serve(eprosima::rpc::protocol::Protocol &protocol, void *_data,
                                             eprosima::rpc::transport::Endpoint *endpoint) {
    AIOpenApiProtocol &_protocol = dynamic_cast<AIOpenApiProtocol &>(protocol);
    AI::OpenApi::VSP_Request &requestData = *(AI::OpenApi::VSP_Request *)_data;
    std::string sendId = ::util::dds::guid2string(requestData.header().requestId().writer_guid());

    switch (requestData.data()._d()) {
        case (int32_t)0x68F1FC67: {
            bool return_ = false;
            AI::OpenApi::VSP_Reply replyData;
            replyData.header().relatedRequestId(requestData.header().requestId());
            replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

            replyData.data()._d() = 0x68F1FC67;

            try {
                if (_protocol._AI_OpenApi_VSP_s_impl != NULL) {
                    return_ = _protocol._AI_OpenApi_VSP_s_impl->beginVoiceHandle(sendId);

                    replyData.data().beginVoice()._d() = 0;

                    replyData.data().beginVoice().result().return_(return_);

                    _protocol.AI_OpenApi_VSP_se->sendReply(&replyData);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
                // TODO Quitar el unsetReply
                //
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                _protocol.AI_OpenApi_VSP_se->sendReply(&replyData);
            }

        } break;

        case (int32_t)0xD928FA97: {
            bool return_ = false;
            AI::OpenApi::VSP_Reply replyData;
            replyData.header().relatedRequestId(requestData.header().requestId());
            replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

            replyData.data()._d() = 0xD928FA97;

            try {
                if (_protocol._AI_OpenApi_VSP_s_impl != NULL) {
                    return_ = _protocol._AI_OpenApi_VSP_s_impl->stopVoiceHandle(sendId);

                    replyData.data().stopVoice()._d() = 0;

                    replyData.data().stopVoice().result().return_(return_);

                    _protocol.AI_OpenApi_VSP_se->sendReply(&replyData);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
                // TODO Quitar el unsetReply
                //
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                _protocol.AI_OpenApi_VSP_se->sendReply(&replyData);
            }

        } break;
    };
}

void AIOpenApiProtocol::AI_OpenApi_VSP_proxy(eprosima::rpc::protocol::Protocol &protocol, void *_data,
                                             eprosima::rpc::transport::Endpoint *endpoint) {
    AIOpenApiProtocol &_protocol = dynamic_cast<AIOpenApiProtocol &>(protocol);
    AI::OpenApi::VSP_Reply &replyData = *(AI::OpenApi::VSP_Reply *)_data;

    std::string sendId = ::util::dds::guid2string(replyData.header().relatedRequestId().writer_guid());
    switch (replyData.data()._d()) {

        case (int32_t)0xA4C948E9: {
            int32_t state = 0;
            state = replyData.data().init().result().state();
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->initHandle(sendId, state);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0x61863CB7: {
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->readyHandle(sendId);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0xC815E808: {
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->vadBeginHandle(sendId);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0x296CC74B: {
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->vadEndHandle(sendId);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0x12215282: {
            AI::Error error;
            error = std::move(replyData.data().error().result().error());  // TODO Probar que esto funciona.
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->errorHandle(sendId, error);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0xF3E0EB2F: {
            std::string text;
            text = std::move(replyData.data().partial().result().text());  // TODO Probar que esto funciona.
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->partialHandle(sendId, text);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }

        case (int32_t)0x3188DCD9: {
            std::string text;
            text = std::move(replyData.data().finalResult().result().text());  // TODO Probar que esto funciona.
            try {
                if (_protocol._AI_OpenApi_VSP_p_impl != NULL) {
                    _protocol._AI_OpenApi_VSP_p_impl->finalResultHandle(sendId, text);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
            }
            break;
        }
    };
}

bool AIOpenApiProtocol::AI_OpenApi_VSP_beginVoice() {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool return_ = false;
    AI::OpenApi::VSP_Request instance;
    AI::OpenApi::VSP_Reply retInstance;

    instance.data()._d() = 0x68F1FC67;

    retcode = AI_OpenApi_VSP_pe->send(&instance, &retInstance);

    if (retcode == OK) {
        if (retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK) {
            switch (retInstance.data().beginVoice()._d()) {
                case 0:
                    return_ = retInstance.data().beginVoice().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        } else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };

    return return_;
}
void AIOpenApiProtocol::AI_OpenApi_VSP_beginVoice_async(AI::OpenApi::VSP_beginVoiceCallbackHandler &obj) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Request instance;
    AI::OpenApi::VSP_beginVoiceTask *task = new AI::OpenApi::VSP_beginVoiceTask(obj);

    instance.data()._d() = 0x68F1FC67;

    retcode = AI_OpenApi_VSP_pe->send_async(&instance, task);

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}

bool AIOpenApiProtocol::AI_OpenApi_VSP_stopVoice() {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    bool return_ = false;
    AI::OpenApi::VSP_Request instance;
    AI::OpenApi::VSP_Reply retInstance;

    instance.data()._d() = 0xD928FA97;

    retcode = AI_OpenApi_VSP_pe->send(&instance, &retInstance);

    if (retcode == OK) {
        if (retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK) {
            switch (retInstance.data().stopVoice()._d()) {
                case 0:
                    return_ = retInstance.data().stopVoice().result().return_();
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        } else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };

    return return_;
}
void AIOpenApiProtocol::AI_OpenApi_VSP_stopVoice_async(AI::OpenApi::VSP_stopVoiceCallbackHandler &obj) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Request instance;
    AI::OpenApi::VSP_stopVoiceTask *task = new AI::OpenApi::VSP_stopVoiceTask(obj);

    instance.data()._d() = 0xD928FA97;

    retcode = AI_OpenApi_VSP_pe->send_async(&instance, task);

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}

void AIOpenApiProtocol::AI_OpenApi_VSP_init(/*in*/ int32_t state) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0xA4C948E9;
    replyData.data().init()._d() = 0;

    replyData.data().init().result().state(state);

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_ready() {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0x61863CB7;
    replyData.data().ready()._d() = 0;

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_vadBegin() {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0xC815E808;
    replyData.data().vadBegin()._d() = 0;

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_vadEnd() {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0x296CC74B;
    replyData.data().vadEnd()._d() = 0;

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_error(/*in*/ const AI::Error &error) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0x12215282;
    replyData.data().error()._d() = 0;

    replyData.data().error().result().error(std::move(error));

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_partial(/*in*/ const std::string &text) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0xF3E0EB2F;
    replyData.data().partial()._d() = 0;

    replyData.data().partial().result().text(std::move(text));

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_VSP_finalResult(/*in*/ const std::string &text) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::VSP_Reply replyData;

    replyData.data()._d() = 0x3188DCD9;
    replyData.data().finalResult()._d() = 0;

    replyData.data().finalResult().result().text(std::move(text));

    AI_OpenApi_VSP_se->broadcast(&replyData);
}

void AIOpenApiProtocol::AI_OpenApi_Photo_serve(eprosima::rpc::protocol::Protocol &protocol, void *_data,
                                               eprosima::rpc::transport::Endpoint *endpoint) {
    AIOpenApiProtocol &_protocol = dynamic_cast<AIOpenApiProtocol &>(protocol);
    AI::OpenApi::Photo_Request &requestData = *(AI::OpenApi::Photo_Request *)_data;
    std::string sendId = ::util::dds::guid2string(requestData.header().requestId().writer_guid());

    switch (requestData.data()._d()) {
        case (int32_t)0xE84B15F6: {
            std::string pId;
            std::string return_;
            AI::OpenApi::Photo_Reply replyData;
            replyData.header().relatedRequestId(requestData.header().requestId());
            replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK);

            replyData.data()._d() = 0xE84B15F6;

            pId = std::move(requestData.data().getPhotoInfo().pId());  // TODO Probar que esto funciona.

            try {
                if (_protocol._AI_OpenApi_Photo_s_impl != NULL) {
                    return_ = _protocol._AI_OpenApi_Photo_s_impl->getPhotoInfoHandle(sendId, pId);

                    replyData.data().getPhotoInfo()._d() = 0;

                    replyData.data().getPhotoInfo().result().return_(std::move(return_));

                    _protocol.AI_OpenApi_Photo_se->sendReply(&replyData);
                }
                // TODO Send exception.
            } catch (const ServerInternalException &) {
                // TODO Quitar el unsetReply
                //
                replyData.header().remoteEx(eprosima::rpc::protocol::dds::rpc::REMOTE_EX_UNSUPPORTED);

                _protocol.AI_OpenApi_Photo_se->sendReply(&replyData);
            }

        } break;
    };
}

void AIOpenApiProtocol::AI_OpenApi_Photo_proxy(eprosima::rpc::protocol::Protocol &protocol, void *_data,
                                               eprosima::rpc::transport::Endpoint *endpoint) {
    AIOpenApiProtocol &_protocol = dynamic_cast<AIOpenApiProtocol &>(protocol);
    AI::OpenApi::Photo_Reply &replyData = *(AI::OpenApi::Photo_Reply *)_data;

    std::string sendId = ::util::dds::guid2string(replyData.header().relatedRequestId().writer_guid());
    switch (replyData.data()._d()) {};
}

std::string AIOpenApiProtocol::AI_OpenApi_Photo_getPhotoInfo(/*in*/ const std::string &pId) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    std::string return_;
    AI::OpenApi::Photo_Request instance;
    AI::OpenApi::Photo_Reply retInstance;

    instance.data()._d() = 0xE84B15F6;

    instance.data().getPhotoInfo().pId(pId);

    retcode = AI_OpenApi_Photo_pe->send(&instance, &retInstance);

    if (retcode == OK) {
        if (retInstance.header().remoteEx() == eprosima::rpc::protocol::dds::rpc::REMOTE_EX_OK) {
            switch (retInstance.data().getPhotoInfo()._d()) {
                case 0:
                    return_ = std::move(retInstance.data().getPhotoInfo().result().return_());  // TODO Probar que esto
                                                                                                // funciona.
                    break;
                default:
                    throw ClientInternalException("Error extracting information from server");
            }
        } else
            retcode = SERVER_INTERNAL_ERROR;
    }

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException("");
            break;
        default:
            break;
    };

    return return_;
}
void AIOpenApiProtocol::AI_OpenApi_Photo_getPhotoInfo_async(AI::OpenApi::Photo_getPhotoInfoCallbackHandler &obj,
                                                            /*in*/ const std::string &pId) {
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    AI::OpenApi::Photo_Request instance;
    AI::OpenApi::Photo_getPhotoInfoTask *task = new AI::OpenApi::Photo_getPhotoInfoTask(obj);

    instance.data()._d() = 0xE84B15F6;

    instance.data().getPhotoInfo().pId(pId);

    retcode = AI_OpenApi_Photo_pe->send_async(&instance, task);

    switch (retcode) {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case SERVER_NOT_FOUND:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}
