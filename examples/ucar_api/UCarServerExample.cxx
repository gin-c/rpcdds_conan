/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 *
 * @file UCarServerExample.cxx
 * This source file shows a simple example of how to create a server for an interface.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "UCarDDSProtocol.h"
#include "UCarServer.h"
#include "UCarServerImplExample.h"
#include <fastrtps/Domain.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <iostream>
#include <rpcdds/exceptions/Exceptions.h>
#include <rpcdds/strategies/ThreadPoolStrategy.h>
#include <rpcdds/transports/dds/RTPSServerTransport.h>
#include <rpcdds/utils/Utilities.h>
#include <time.h>

using namespace eprosima::rpc;
using namespace ::exception;
using namespace ::strategy;
using namespace ::transport::dds;
using namespace ::protocol::dds;

// C++方式生成指定长度随机字符串
std::vector<char> gengerVectorChar(int n) {
    srand((unsigned)time(NULL));  //产生随机化种子
    printf("生成%d个字符的字符串\n", n);
    std::vector<char> str;
    str.resize(n);
    for (int i = 0; i < n; i++) {
        int flag;
        flag = rand() % 2;                            //随机使flag为1或0，为1就是大写，为0就是小写
        if (flag == 1)                                //如果flag=1
            str[i] = rand() % ('Z' - 'A' + 1) + 'A';  //追加大写字母的ascii码
        else
            str[i] = rand() % ('z' - 'a' + 1) + 'a';  //如果flag=0，追加为小写字母的ascii码
    }
    return str;
}

int main(int argc, char **argv) {
    if (argc != 2) {
        std::cout << "Usage: UCarServer <xml path>" << std::endl;
        return 0;
    }
    unsigned int threadPoolSize = 5;
    ThreadPoolStrategy *pool = NULL;
    UCarProtocol *protocol = NULL;
    RTPSServerTransport *transport = NULL;
    UCarServer *server = NULL;
    UCarServerImplExample servant;

    // Create and initialize the server for interface "UCar".
    try {
        std::string errorMessage;
#if 0
       int32_t domainId = 0;
       if (sscanf(argv[1], "%d", &domainId) != 1) {
           std::cout << "Bad parameter (first value)" << std::endl;
           return 0;
       }
       eprosima::fastrtps::ParticipantAttributes pParam;
       pParam.domainId = domainId;
       {
           eprosima::fastrtps::rtps::Locator_t locator;
           eprosima::fastrtps::rtps::IPLocator::setIPv4(locator, 127, 0, 0, 1);
           pParam.rtps.defaultUnicastLocatorList.push_back(locator);
       }

       // Creating the domain participant that will be used to create DDS entities.
       eprosima::fastrtps::Participant *participant = eprosima::fastrtps::Domain::createParticipant(pParam, nullptr);
#else
        bool ret = eprosima::fastrtps::Domain::loadXMLProfilesFile(argv[1]);
        if (!ret) {
            std::cout << "loadXMLProfilesFile failed" << std::endl;
            return 0;
        }
        eprosima::fastrtps::Participant *participant =
            eprosima::fastrtps::Domain::createParticipant("participant_profile");
#endif
        pool = new ThreadPoolStrategy(threadPoolSize);
        protocol = new UCarProtocol();
        transport = new RTPSServerTransport(participant, "UCarService", "Instance");
        server = new UCarServer(*pool, *transport, *protocol, servant);
        server->serve();
    } catch (InitializeException &ex) {
        std::cout << ex.what() << std::endl;
        return -1;
    }

    while (1) {
        eprosima::rpc::sleep(2000);

        time_t currentTime;
        time(&currentTime);
        struct tm *p;
        p = localtime(&currentTime);
        VideoFormat videoFormat;
        videoFormat.mimeType("mimeType");
        videoFormat.width(1920);
        videoFormat.height(1080);
        server->videoInitialized(0, videoFormat);
        std::cout << "videoInitialized::" << std::endl;
        std::vector<char> byte = gengerVectorChar(10240);

        if (byte.size() > 1) {
            std::cout << "videoDataReceived::" << std::setiosflags(std::ios::uppercase) << std::hex << int(byte.at(0))
                      << "..." << int(byte.at(byte.size() - 1)) << std::dec << std::endl;
        }
        server->videoDataReceived(0, byte.size(), byte);
    }

    // Stop and delete the server.
    server->stop();
    delete server;
    delete protocol;
    delete transport;
    delete pool;

    return 0;
}
