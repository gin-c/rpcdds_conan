/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * rpcdds_LICENSE file included in this rpcdds distribution.
 *
 *************************************************************************
 *
 * @file UCarClientExample.cxx
 * This source file shows a simple example of how to create a proxy for an interface.
 *
 * This file was generated by the tool rpcddsgen.
 */

#include "UCar.h"
#include "UCarDDSProtocol.h"
#include "UCarProxy.h"
#include "UCarProxyImplExample.h"
#include <rpcdds/exceptions/Exceptions.h>
#include <rpcdds/strategies/ThreadPoolStrategy.h>
#include <rpcdds/transports/dds/RTPSProxyTransport.h>
#include <rpcdds/utils/Utilities.h>

#include <fastrtps/Domain.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <iostream>

using namespace eprosima::rpc;
using namespace ::exception;
using namespace ::transport::dds;
using namespace ::protocol::dds;
using namespace ::strategy;

int main(int argc, char **argv) {
    if (argc != 2) {
        std::cout << "Usage: UCarClient <xml path>" << std::endl;
        return 0;
    }
    unsigned int threadPoolSize = 5;
    ThreadPoolStrategy *pool = NULL;

    UCarProtocol *protocol = NULL;
    RTPSProxyTransport *transport = NULL;
    UCarProxy *proxy = NULL;
    UCarProxyImplExample servant;

    // Creation of the proxy for interface "UCar".
    try {
        std::string errorMessage;
#if 0
       int32_t domainId = 0;
       if (sscanf(argv[1], "%d", &domainId) != 1) {
           std::cout << "Bad parameter (first value)" << std::endl;
           return 0;
       }

       eprosima::fastrtps::ParticipantAttributes pParam;
       pParam.domainId = domainId;
       {
           eprosima::fastrtps::rtps::Locator_t locator;
           eprosima::fastrtps::rtps::IPLocator::setIPv4(locator, 127, 0, 0, 1);
           pParam.rtps.defaultUnicastLocatorList.push_back(locator);
       }
       // Creating the domain participant that will be used to create DDS entities.
       eprosima::fastrtps::Participant *participant = eprosima::fastrtps::Domain::createParticipant(pParam, nullptr);
#else
        bool ret = eprosima::fastrtps::Domain::loadXMLProfilesFile(argv[1]);
        if (!ret) {
            std::cout << "loadXMLProfilesFile failed" << std::endl;
            return 0;
        }
        eprosima::fastrtps::Participant *participant =
            eprosima::fastrtps::Domain::createParticipant("participant_profile");
#endif

        pool = new ThreadPoolStrategy(threadPoolSize);
        protocol = new UCarProtocol();
        transport = new RTPSProxyTransport(participant, "UCarService", "Instance", 3000);
        proxy = new UCarProxy(*pool, *transport, *protocol, servant);
    } catch (InitializeException &ex) {
        std::cout << ex.what() << std::endl;
        return -1;
    }
    while (1) {

        try {
            int32_t action = 23;
            int32_t width = 1920;
            int32_t height = 1080;
            int32_t count = 100;
            LongArray trackID = {1, 2};
            LongArray x = {20, 21};
            LongArray y = {30, 31};
            bool bret = proxy->sendTouchEvent(action, width, height, count, trackID, x, y);
            std::cout << "sendGotoForeground result: " << bret << std::endl;
        } catch (SystemException &ex) {
            std::cout << ex.what() << std::endl;
        }

        try {
            bool bret = proxy->sendGotoForeground();
            std::cout << "sendGotoForeground result: " << bret << std::endl;
        } catch (SystemException &ex) {
            std::cout << ex.what() << std::endl;
        }

        eprosima::rpc::sleep(2000);
    }
    delete proxy;
    delete transport;
    delete protocol;

    return 0;
}
